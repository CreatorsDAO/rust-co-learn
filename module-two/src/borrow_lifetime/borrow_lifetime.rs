//! 2.2.1 借用和生命周期
//!

/**

```
    // 1 有所有权的变量和没有所有权的变量

    // 有所有权

    let have_ownership = String::from("rust");

    // 没有所有权
    let have_no_ownership = "rust"; // 字符串切片的引用

    // 有所有权
    let num = 42;

    // 没有所有权
    let num_ptr = &num;

    // 2 变量的生命周期 （不管是有所有权的变量还是没所有权的变量）: 从声明开始，到离开作用域结束

    {
        let x = 32;
        println!("{}", x);

        {
            // 引用的生命周期
            let x_ptr = &x;

            // x_ptr 在离开作用域时，生命周期结束，值会被丢弃
        }

        // println!("{}", x_ptr); // 无法再使用 x_ptr,因为它已经被丢弃

        // x 在离开作用域时，生命周期结束，值会被丢弃
    }

    // println!("{}", x); // 无法再使用 x,因为它已经被丢弃

    // 3 使用泛型生命周期参数显式标注参数生命周期

    // 声明一个函数，参数是引用类型，返回值也是引用类型
    // 它无法编译通过，因为编译器无法推断出参数和返回值的生命周期
    // 事实上，i32这种非常轻量的类型，我们直接传值就可以了，不需要传引用

    // fn foo(x: &i32, &y: &i32) -> &i32 {
    //     println!("{}", x);
    // }

    // 如果是比较大的类型，比如结构体，我们就需要传引用了

    struct Foo {
        x: i32,
        y: (i32, bool),
        z: String,
    }

    let f1 = Foo {
        x: 32,
        y: (32, true),
        z: String::from("rust"),
    };
    let f2 = Foo {
        x: 32,
        y: (32, true),
        z: String::from("rust"),
    };

    // 仍然无法编译通过，因为编译器无法推断出参数和返回值的生命周期
    // 这是因为Rust对于函数的检查只会检查签名，而不是函数里面的具体逻辑

    // fn bar(x: &Foo, y: &Foo) -> &Foo {
    //     x
    // }

    // 但是Rust到底在担心什么情况呢，我们来看看下面的代码

    {
        // 假设下面的函数可以编译通过

        // fn bar(x: &Foo, y: &Foo) -> &Foo {
        //     let f3 = &Foo {
        //         x: 32,
        //         y: (32, true),
        //         z: String::from("rust"),
        //     };

        //     f3
        // }

        // 定义两个生命周期不同的变量

        let mut f1 = &Foo {
            x: 32,
            y: (32, true),
            z: String::from("rust"),
        };

        {
            let f2 = &Foo {
                x: 32,
                y: (32, true),
                z: String::from("rust"),
            };

            // 调用函数，传入两个引用
            // 前面假设函数可以通过，会返回函数内部变量的引用

            // let f4 = bar(f1, f2);
            // 将返回结果赋值给f4,显然是不合理的，因f3在函数结束时会被丢弃，f4就会指向一个无效的内存地址
        }

        // 现在使用生命周期参数，来标注参数和返回值的生命周期
        // 注意Rust中的生命周期参数是以单引号开头的小写字母，也是一种泛型，但通常使用 'a，‘b，‘c这样的字母
        // 生命周期参数也像泛型一样需要先声明才能使用
        // 使用了生命周期参数后，编译器通过了，注意这里我们只是告诉编译器返回值的生命周期是y的生命周期，其他的什么都没做
        // 这实际上就告诉编译器我们没有返回局部变量，所以不会有悬垂指针的问题

        fn bar<'a, 'b>(x: &'a Foo, y: &'b Foo) -> &'b Foo {
            y
        }

        // 如果不确定返回哪个参数的引用，可以使用下面的写法,`'b: 'a` 表示'b 的生命周期要不短于'a的生命周期

        fn far<'a, 'b: 'a>(x: &'a Foo, y: &'b Foo) -> &'a Foo {
            if x.x > y.x {
                x
            } else {
                y
            }
        }

        {
            let f3 = &Foo {
                x: 32,
                y: (32, true),
                z: String::from("rust"),
            };

            let f3 = bar(f1, f3);

            f1 = f3;

            println!("{}", f1.x);

            // 调用far
            // 我们在声明函数的时候，要求‘b不短于’a,但是f3的生命周期比f1的生命周期短，但依然会成功执行，这是为什么？
            let f4 = far(f1, f3);
            let f5 = far(f3, f1);

            // 借用检查器
            // 实际上，当我们标注了生命周期以后，Rust编译器会进行计算，而不是简单的检查签名中参数生命周期和参数声明时的生命周期是否一致
            // 生命周期计算过程：Rust先会取所有参数的周期，记录代码最后的覆盖位置，假设记为x，然后对两个参数的生命周期求交集，记录最早结束位置，假设记为y
            // x < = y,编译器通过检查，x > y 编译器会报错
        }
    }

```
*/

pub fn borrow_lifetime() {
    println!("");
}
