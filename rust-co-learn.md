# æ–‡æ¡£è¯´æ˜

æœ¬æ–‡æ¡£çš„è¡Œæ–‡é€»è¾‘ï¼šå…ˆä»‹ç»ä¸€äº›åŸºç¡€çŸ¥è¯†ï¼Œç„¶åå†å±‚å±‚é€’è¿›ã€‚åŸåˆ™æ˜¯å°½é‡ä¸åœ¨å‰é¢å†…å®¹ä¸­å¼•å…¥æ¯”è¾ƒé«˜é˜¶çš„çŸ¥è¯†ç‚¹ã€‚ä½†è¿™æ ·æœ‰ä¸€ä¸ªåå¤„æ˜¯ä¸€ä¸ªçŸ¥è¯†ç‚¹ä¸èƒ½ä¸€æ¬¡æ€§è®²é€ï¼Œæ¯”å¦‚å‡½æ•°ï¼Œæˆ‘ä»¬åœ¨æ¨¡å—ä¸€ä¸­åªä»‹ç»äº†å®ƒçš„å£°æ˜å’Œæ ·å¼ï¼Œåœ¨æ¨¡å—äºŒæ‰ä»‹ç»å‚æ•°å‚æ•°çš„ç”Ÿå‘½å‘¨æœŸã€è¿”å›å€¼ç±»å‹å’Œ traitï¼Œåœ¨æ¨¡å—ä¸‰è¿˜åœ¨ä»‹ç»å®ƒå’Œé—­åŒ…çš„å…³ç³»ç­‰ç­‰ã€‚è¿™æ ·çš„å–èˆæ˜¯ä¸ºäº†ä¸åœ¨å‰é¢å°±å¼•å…¥åé¢çš„å†…å®¹ï¼Œå¢åŠ ç†è§£éš¾åº¦ï¼Œä½†æ˜¯æœ¬è´¨ä¸Š Rust è¯­è¨€çš„å„ç§ç‰¹æ€§éƒ½æ˜¯æ·±åº¦åµŒåˆåœ¨ä¸€èµ·çš„ã€‚æ‰€ä»¥åœ¨å­¦ä¹ æ—¶è¯»è€…å¯ä»¥æ ¹æ®è‡ªå·±çš„ä¸ªäººä¹ æƒ¯å­¦ä¹ ï¼Œä½ å¯ä»¥å°è¯•è‡ªè¡Œæ‰©å±•ï¼Œä¸€æ¬¡ææ¸…æ¥šæŸä¸ªçŸ¥è¯†ç‚¹çš„æ‰€æœ‰æƒ…å†µï¼Œä¹Ÿå¯ä»¥å…ˆææ˜ç™½ä¸€éƒ¨åˆ†ï¼Œåé¢å†ä¸æ–­è¡¥å……å’Œå®Œå–„

æœ¬æ–‡æ¡£çš„çŸ¥è¯†æ·±åº¦ï¼šæ€»ä½“è€Œè¨€ï¼Œæœ¬æ–‡æ¡£ä¸»è¦æ˜¯ä»åº”ç”¨å‡ºå‘ä»‹ç» Rust çš„å„ä¸ªçŸ¥è¯†ç‚¹ï¼Œå¯¹æ ¸å¿ƒåŸç†æ²¡æœ‰åšè¿‡å¤šçš„æ·±å…¥ä»‹ç»ï¼Œå¸Œæœ›æ·±å…¥çš„æœ‹å‹å¯ä»¥å‚é˜…å…¶ä»–èµ„æ–™

æœ¬æ–‡æ¡£çš„æ‰©å±•èµ„æ–™ï¼šä¸ºäº†ç…§é¡¾åˆ°éƒ¨åˆ†æœ‹å‹è§‰å¾—å‰æœŸå¤ªå°‘æˆ–è€…ä¸å¤Ÿæ·±å…¥ï¼Œæ‰€ä»¥åˆ—å‡ºäº†æ‰©å±•èµ„æ–™ï¼Œæœ‰å…´è¶£çš„æœ‹å‹å¯ä»¥æ·±å…¥é˜…è¯»

# æ¨¡å—ä¸€ï¼šåˆè¯† Rust

## 1.1 å®‰è£… Rust

#### 1.1.1 å®‰è£… Rust

`rustup`æ˜¯ä¸€ä¸ªç®¡ç† Rust ç‰ˆæœ¬ä»¥åŠç›¸å…³å·¥å…·çš„å‘½ä»¤è¡Œå·¥å…·ï¼Œä½ å¯ä»¥é€šè¿‡å®ƒæ¥å®‰è£… Rust å¼€å‘ç¯å¢ƒ

[åœ¨ Linux æˆ– macOS ä¸Šå®‰è£… `rustup`](https://rustwiki.org/zh-CN/book/ch01-01-installation.html#åœ¨-linux-æˆ–-macos-ä¸Šå®‰è£…-rustup)

[åœ¨ Windows ä¸Šå®‰è£… `rustup`](https://rustwiki.org/zh-CN/book/ch01-01-installation.html#åœ¨-windows-ä¸Šå®‰è£…-rustup)

#### 1.1.2 æ›´æ–°å’Œå¸è½½

```bash
rustup update # æ›´æ–°
```

```bash
rustup self uninstall # å¸è½½
```

#### 1.1.3 rustc

rustc æ˜¯ Rust çš„ç¼–è¯‘å™¨ï¼Œå¦‚ä¸‹æ˜¯ä¸€äº›ä½¿ç”¨æ¡ˆä¾‹ï¼š

**æŸ¥çœ‹ Rust ç‰ˆæœ¬**

```bash
rustc --version # æŸ¥çœ‹å·²å®‰è£…çš„Rustçš„ç‰ˆæœ¬
```

**ç¼–è¯‘ Rust ä»£ç **

ä½¿ç”¨ rustc æ¥ç›´æ¥ç¼–è¯‘ä»£ç ä¸ºäºŒè¿›åˆ¶ç¨‹åºï¼Œç„¶åè¿è¡Œï¼Œä¾‹å¦‚ï¼š

```bash
mkdir module-one # éšä¾¿åˆ›å»ºä¸€ä¸ªæ–‡ä»¶å¤¹
cd module-one # è¿›å…¥æ–‡ä»¶å¤¹
touch main.rs # éšä¾¿åˆ›å»ºä¸€ä¸ª.rsç»“å°¾çš„æ–‡ä»¶
```

rust-co-learn/module-one/main.rs

```rust
// å†™ä¸€ä¸ªç®€å•çš„mainå‡½æ•°
fn main() {
    println!("Hello Rust")
}
```

**ç¼–è¯‘å’Œè¿è¡Œ**

```bash
rustc main.rs
ls # åˆ—å‡ºå½“å‰ç›®å½•ä¸‹çš„æ‰€æœ‰æ–‡ä»¶
main    main.rs # `main`ä¸ºç¼–è¯‘åçš„å¯æ‰§è¡Œç¨‹åº
./main # ä½¿ç”¨ `./filename` ç›´æ¥è¿è¡Œç¨‹åº
Hello Rust # è¾“å‡ºç»“æœ
```

**æ‰©å±•èµ„æ–™**

1. [å®˜æ–¹æ–‡æ¡£å…³äº rustc çš„ä»‹ç»](https://rustwiki.org/zh-CN/book/ch01-02-hello-world.html)

## 1.2 ä½¿ç”¨ Cargo

`Cargo`æ˜¯ Rust çš„æ„å»ºç³»ç»Ÿå’ŒåŒ…ç®¡ç†å™¨,ç±»ä¼¼äº python çš„åŒ…ç®¡ç†å·¥å…· pipï¼Œä½†æ¯”å®ƒæ›´å¼ºå¤§ã€‚å¯ä»¥ç”¨å®ƒæ¥åˆ›å»ºã€ç¼–è¯‘å’Œè¿è¡Œ Rust é¡¹ç›®

ä»¥ä¸‹æ˜¯ä¸€ä¸ªä¾‹å­ï¼š

```bash
âœ  module-one git:(main) âœ— cargo new hello_rust --lib # åˆ›å»ºä¸€ä¸ª library crate
     Created library `hello_rust` package
âœ  module-one git:(main) âœ— cargo new hello_cargo --bin # åˆ›å»ºä¸€ä¸ª binary crate
     Created binary (application) `hello_cargo` package
âœ  module-one git:(main) âœ— ls
hello_cargo hello_rust
âœ  module-one git:(main) âœ— cd hello_cargo
âœ  hello_cargo git:(main) âœ— ls
Cargo.toml src
âœ  hello_cargo git:(main) âœ— cargo build --release # ç¼–è¯‘ï¼Œè¿™é‡Œä¸å†ä½¿ç”¨ rustc äº†
âœ  hello_cargo git:(main) âœ— cargo run # ç¼–è¯‘+è¿è¡Œ
Hello, world!
```

**æ‰©å±•èµ„æ–™**

1. [å®˜æ–¹æ–‡æ¡£ä¸­ä½¿ç”¨ Cargo æ„å»ºé¡¹ç›®çš„è¯¦ç»†ä»‹ç»](https://rustwiki.org/zh-CN/book/ch01-03-hello-cargo.html)
2. [Cargo Bookï¼šCargo ä½¿ç”¨å¤§å…¨](https://doc.rust-lang.org/cargo/)
3. [Rust ä¸­çš„ crate ä»¥åŠå¦‚ä½•ä½¿ç”¨ Cargo ç®¡ç†åŒ…å«äº†å¤šä¸ª crate çš„é¡¹ç›®](https://zhuanlan.zhihu.com/p/614506900)

## 1.3 Rust åŸºç¡€çŸ¥è¯†

### 1.3.1 å˜é‡å’Œå¯å˜æ€§

```rust
 // 1 å¸¸é‡
    // ä½¿ç”¨ const å£°æ˜; å¸¸é‡åç§°ä½¿ç”¨å¤§å†™å­—æ¯; æ˜¾å¼æ ‡æ³¨ç±»å‹

    const RUST: &str = "rust";
    const WEIGHT: u64 = 100;

    println!("{},{}",RUST,WEIGHT);

    // 2 å˜é‡
    // ä½¿ç”¨let å£°æ˜,å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œç¼–è¯‘å™¨å¯ä»¥æ ¹æ®ä¸Šä¸‹æ–‡æ¨æ–­å˜é‡ç±»å‹

    let name = "rust";
    let age: u32 = 13;

    println!("{},{}", name, age);

    let s = "32";

    let s_to_i32 = s.parse::<i32>().unwrap();
    let s_to_u32 = s.parse::<u32>().unwrap();

    let s_to_unknown = s.parse::<i64>().unwrap();

    print!("{},{}:", s_to_i32, s_to_u32);

    // 3 ä¸å˜æ€§
    // Rustä¸­å˜é‡é»˜è®¤ä¸å¯å˜ï¼Œè‹¥éœ€ä¿®æ”¹å˜é‡ï¼Œéœ€è¦ä½¿ç”¨mutå…³é”®å­—å£°æ˜å˜é‡å…·æœ‰å¯å˜æ€§

    let _language = "go";
    // _language = "rust"; æ— æ³•ä¿®æ”¹

    // 4 å¯å˜æ€§
    // é€šè¿‡ mut å£°æ˜å˜é‡

    let mut language = "go";
    language = "rust";

    println!("{}", language);

    // 5 å˜é‡é®è”½
    let language = 32;
    println!("{}", language);
```

**æ‰©å±•èµ„æ–™**

1. [å®˜æ–¹æ–‡æ¡£å…³äºå˜é‡é®è”½çš„ä»‹ç»](https://rustwiki.org/zh-CN/book/ch03-01-variables-and-mutability.html)
2. [é€šè¿‡å¯å˜å®¹å™¨è®©å˜é‡è·å¾—å¯å˜æ€§](https://zhuanlan.zhihu.com/p/611487702)

### 1.3.2 åŸºç¡€æ•°æ®ç±»å‹

Rust æ˜¯å¼ºç±»å‹è¯­è¨€ï¼Œæ¯ä¸ªå€¼éƒ½æœ‰ç¡®åˆ‡çš„ç±»å‹

#### æ ‡é‡ç±»å‹

```rust
 // 1 æ•´æ•°ç±»å‹

    // Rust ä¸­æ•´æ•°ç±»å‹åˆ†ä¸ºæœ‰ç¬¦å·å’Œæ— ç¬¦å·ç±»å‹ï¼›é•¿åº¦åˆ†ä¸º8ä½ï¼Œ16ä½ï¼Œ32ä½ï¼Œ64ä½ï¼Œ128ä½
    // ç‰¹æ®Šçš„æ•´æ•°ç±»å‹: usize å’Œ isizeï¼Œä¸ç³»ç»Ÿæ¶æ„ç›¸å…³ï¼Œ32ä½çš„ç³»ç»Ÿåˆ™ä¸º32ä½ï¼Œ64ä½çš„ç³»ç»Ÿä¸º64ä½

    let integer: i32 = 42;
    let s: usize = 100;

    // 2 æµ®ç‚¹ç±»å‹
    // Rust çš„æµ®ç‚¹å‹æ˜¯ f32 å’Œ f64ï¼Œå¤§å°åˆ†åˆ«ä¸º 32 ä½å’Œ 64 ä½ã€‚é»˜è®¤æµ®ç‚¹ç±»å‹æ˜¯ f64
    // æµ®ç‚¹å‹éƒ½æ˜¯æœ‰ç¬¦å·çš„

    let x = 2.0; // f64
    let y: f32 = 3.0; // f32

    // 3 å¸ƒå°”ç±»å‹

    let t = true;
    let f: bool = false;

    // 4 å­—ç¬¦ç±»å‹ char
    // Rust çš„å­—ç¬¦ç±»å‹å¤§å°ä¸º 4 ä¸ªå­—èŠ‚ï¼Œè¡¨ç¤ºçš„æ˜¯ä¸€ä¸ª Unicode æ ‡é‡å€¼

    let c = 'z';
    let z = 'â„¤';
    let heart_eyed_cat = 'ğŸ˜»';
    let char_size = std::mem::size_of::<char>();
```

**æ‰©å±•èµ„æ–™**

1. [Rust å®˜æ–¹æ–‡æ¡£å…³äºåŸºç¡€ç±»å‹çš„è¯¦ç»†ä»‹ç»](https://rustwiki.org/zh-CN/book/ch03-02-data-types.html)

#### å¤åˆç±»å‹

Rust ä¸­çš„å¤åˆç±»å‹ä¸»è¦æœ‰å…ƒç»„å’Œæ•°ç»„

```rust
 // 1 å…ƒç»„
    // Rustä¸­çš„å…ƒç»„å¯ä»¥å°†å„ç§ç±»å‹ç»„åˆèµ·æ¥
    let types = (42, "Rust", true);

    // å¯ä»¥é€šè¿‡ä¸‹æ ‡ç´¢å¼•è®¿é—®
    println!("num is {}", types.0);

    // å•å…ƒç±»å‹ ï¼ˆï¼‰
    // å•å…ƒç±»å‹åœ¨Rustä¸­æ˜¯éå¸¸é‡è¦çš„ç±»å‹ï¼Œå¦‚æœè¡¨è¾¾å¼ä¸è¿”å›ä»»ä½•å…¶ä»–å€¼ï¼Œå°±éšå¼åœ°è¿”å›å•å…ƒå€¼ï¼Œ
    // å¦‚æ²¡æœ‰è¿”å›å€¼çš„å‡½æ•°æˆ–è€…ä½œç”¨åŸŸ

    let a: () = {};
    fn return_tuple() {}
    let func: () = return_tuple();
    assert_eq!(a, func);

    // 2 æ•°ç»„
    // é€šè¿‡ç´¢å¼•æ¥è®¿é—®æˆ–è€…ä¿®æ”¹æ•°ç»„ä¸­çš„å…ƒç´ 

    let arr = [1, 2, 3, 4, 5];

    let mut arr1 = [0, 0, 0, 0, 0];
    arr1[0] = 100;
    println!("{:?}", arr1); // [100, 0, 0, 0, 0]
```

**æ‰©å±•èµ„æ–™**

1. [å®˜æ–¹æ–‡æ¡£ä¸­å…³äºå¤åˆç±»å‹çš„ä»‹ç»](https://rustwiki.org/zh-CN/book/ch03-02-data-types.html)
2. [å…³äº Rust ä¸­ç±»å‹ä¸è¡¨è¾¾å¼çš„è¯¦ç»†ä»‹ç»ï¼Œæ­¤è¯¾ç¨‹ä¸ºä»˜è´¹è¯¾ç¨‹ï¼Œä½†æ˜¯å¼ºçƒˆæ¨è](https://time.geekbang.org/course/detail/100060601-289993)

### 1.3.3 è¿›é˜¶æ•°æ®ç±»å‹

#### å­—ç¬¦ä¸²

Rust ä¸­çš„å­—ç¬¦ä¸²æ¯”è¾ƒå¤æ‚ï¼Œæœ‰å¤šç§å½¢å¼ï¼Œé€‚ç”¨äºä¸åŒçš„åœºæ™¯ã€‚æ ¸å¿ƒæ˜¯éœ€è¦æŒæ¡ `&str` å’Œ `String`

Rust åœ¨ç¼–è¯‘ä»£ç æ—¶éœ€è¦åœ¨ç¼–è¯‘æœŸå°±èƒ½å¤Ÿç¡®å®šç±»å‹çš„å¤§å°ï¼Œè€Œå­—ç¬¦ä¸² str æœ¬èº«æ˜¯åŠ¨æ€å¤§å°çš„ï¼Œå› è€Œæ—¥å¸¸ä¸­æˆ‘ä»¬æ›´å¤šä½¿ç”¨çš„æ˜¯å­—ç¬¦ä¸²çš„å¼•ç”¨ `&str` å’Œ `String`

```rust
    // 1 &strï¼šå­—ç¬¦ä¸²å­—é¢é‡çš„å¼•ç”¨
    // å­—ç¬¦ä¸²å­—é¢é‡å®é™…ä¸Šå­˜æ”¾åœ¨ç¨‹åºçš„åªè¯»æ•°æ®æ®µä¸­ï¼Œåœ¨ç¨‹åºè¿è¡Œæ—¶ä¼šè¢«åŠ è½½åˆ°å†…å­˜ä¸­è¯»å–
    let s = "Hello Rust";
    let mut s1 = "Hello Go";

    s1 = "Hello Rust";
    println!("{}", s1);

    // 2 Stringï¼šå­—ç¬¦ä¸²åˆ‡ç‰‡çš„å¼•ç”¨
    // String é€šè¿‡æŒ‡é’ˆæŒ‡å‘å­˜æ”¾åœ¨å †ä¸Šçš„å­—ç¬¦ä¸²

		// æœ‰å¤šç§æ–¹å¼å¯ä»¥åœ¨å †ä¸Šåˆ›å»ºå­—ç¬¦ä¸²
    // let s2 = String::new();         // ç©ºå­—ç¬¦ä¸²
    // let s2 = "Hello Rust".to_string();
    // let s2: String = "Hello Rust".into();
    // let s2 = String::from("Hello Rust");

    // å¯ä»¥ä½¿ç”¨ptrã€lenã€capè·å–Stringçš„æŒ‡é’ˆã€é•¿åº¦å’Œå®¹é‡

    let cap = s2.capacity();
    let len = s2.len();
    let ptr = s2.as_ptr();

    println!("len {}", len);
    println!("cap {}", cap);
    println!("pointer {:?}", ptr);

    // 3 å­—ç¬¦ä¸²åˆ‡ç‰‡
    // å­—ç¬¦ä¸²æœ¬è´¨ä¸Šä¸€ä¸ªu8åºåˆ—ï¼Œæ”¯æŒåˆ‡ç‰‡æ“ä½œ

    let s1 = String::from("Hello Rust");
    let s2 = "Hello Rust";

    let slice1 = &s1[0..5];
    let slice2 = &s2[6..10];

    println!("slice1: {}", slice1); // Hello
    println!("slice2: {}", slice2); // Rust
```

**æ‰©å±•èµ„æ–™**

1. [å®˜æ–¹æ–‡æ¡£ä¸­å…³äºå­—ç¬¦ä¸²çš„æ›´å¤šè§£é‡Š](https://rustwiki.org/zh-CN/book/ch08-02-strings.html)
2. [ä¸€äº›å­—ç¬¦ä¸²ç»ƒä¹ çš„å°ä¾‹å­](https://github.com/rust-lang-cn/rustlings-cn/tree/main/exercises/strings)
3. [å®˜æ–¹æ–‡æ¡£ä¸­å…³äºåˆ‡ç‰‡çš„æ›´å¤šå†…å®¹](https://rustwiki.org/zh-CN/book/ch04-03-slices.html)

#### å¼•ç”¨

Rust ä¸­çš„å¼•ç”¨ç±»å‹æ˜¯ä¸€ç­‰å…¬æ°‘ï¼Œå¹¶ä¸”å’Œå€Ÿç”¨æŒ‡åŒä¸€ä¸ªæ¦‚å¿µã€‚ä»å¯å˜æ€§ä¸Šå¯ä»¥åˆ†ä¸ºå¯å˜å¼•ç”¨å’Œä¸å¯å˜å¼•ç”¨

```rust
    // 1 ä¸å¯å˜å€Ÿç”¨
    let num = 42;
    let immutable_s = &num;

    // 2 å¯å˜å€Ÿç”¨
    let mut num = 42;
    let mutable_s = &mut num;

    // å½“ç±»å‹å ç”¨ç©ºé—´æ¯”è¾ƒå¤§æ—¶ï¼Œå¯ä»¥é€šè¿‡å¼•ç”¨æ¥è®¿é—®æˆ–è€…ä¿®æ”¹æ•°æ®,å°¤å…¶æ˜¯åœ¨ä¼ é€’æ•°æ®çš„åœºæ™¯ä¸‹

    let person_tuple = ("Rust", 13, true);

    let ptr = &person_tuple;
    println!("{}", ptr.0);

    let mut arr = ["Rust", "Go", "C++"];

    let arr_ptr = &mut arr;

    arr_ptr[2] = "Java";

    println!("{:?}", arr_ptr) // ["Rust", "Go", "Java"]
```

**æ‰©å±•èµ„æ–™**

1.[Rust ä¸­å¼•ç”¨å’ŒæŒ‡é’ˆçš„åŒºåˆ«](https://zhuanlan.zhihu.com/p/614970269)

2.[å®˜æ–¹æ–‡æ¡£ä¸­å¯¹å¼•ç”¨çš„æ›´å¤šä»‹ç»](https://rustwiki.org/zh-CN/book/ch04-02-references-and-borrowing.html)

#### é›†åˆ

ä¸¤ä¸ªé‡è¦çš„é›†åˆ Vec å’Œ HashMapï¼Œè¿™é‡Œçš„é›†åˆæŒ‡çš„æ˜¯å®ƒä»¬éƒ½èšé›†äº†å¤šä¸ªåŒç±»å‹çš„å…ƒç´ 

```rust
    // 1 Vec
    // Vecæ˜¯åŠ¨æ€å¤§å°ï¼Œç›¸æ¯”èµ·æ•°ç»„æ¥è¯´ï¼Œå®ƒæ›´åŠ å¸¸ç”¨
    // Vecä¸­çš„å…ƒç´ å¿…é¡»ç›¸åŒ

    let mut vec1 = Vec::new();
    let mut vec2 = vec![];

    // vec æ”¯æŒä¸€ç³»åˆ—çš„æ“ä½œ

    // æ·»åŠ å…ƒç´ 
    vec1.push("Rust");
    vec2.push("Go");

    // å½“ä½œæ ˆ
    vec1.pop();

    // ä¿®æ”¹æ•°æ®
    vec2[0] = "Rust";

    // Vec å’Œ Stringä¸€æ ·ï¼Œæ•°æ®å­˜æ”¾åœ¨å †ä¸Š

    println!("{}", vec2.len()); // 1
    println!("{}", vec2.capacity()); // 4
    println!("{:?}", vec2.as_ptr()); // 0x7fafc9f05b70

    // 2 HashMap

    // HashMapå¹¶ä¸æ˜¯é¢„å¯¼å…¥çš„ï¼Œéœ€è¦æ‰‹åŠ¨å¼•å…¥å½“å‰ä½œç”¨åŸŸ
    use std::collections::HashMap;

    // ä½¿ç”¨newæ–¹æ³•åˆ›å»º
    let mut scores = HashMap::new();

    // æ’å…¥æ•°æ®
    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);

    // ä¿®æ”¹æ•°æ®,ä¿®æ”¹å’Œæ’å…¥æ•°æ®æ˜¯åŒä¸€ä¸ªapi
    scores.insert(String::from("Blue"), 100);

    // è®¿é—®æ•°æ®,æ³¨æ„è®¿é—®çš„keyä¼ é€’çš„æ˜¯å¼•ç”¨
    let key = String::from("Blue");
    println!("{:?}", scores[&key])
```

**æ‰©å±•èµ„æ–™**

1. [å®˜æ–¹æ–‡æ¡£ä¸­å¯¹é›†åˆçš„æ›´å¤šä»‹ç»](https://rustwiki.org/zh-CN/book/ch08-00-common-collections.html)

#### ç»“æ„ä½“

```rust
    // 1 ç»“æ„ä½“
    // Rustä¸­çš„ç»“æ„ä½“æœ‰ä¸‰ç§

    // 1.1 å¸¸è§„ç»“æ„ä½“
    struct Language {
        name: String,
        birth: u32,
        is_popular: bool,
    }

    // 1.2 å…ƒç»„ç»“æ„ä½“
    struct Rust(String);

    // 1.3 å•å…ƒç»“æ„ä½“
    struct Go;

    // 2 ä¸ºç»“æ„ä½“å®ç°æ–¹æ³•
    impl Rust {
        // Self ä»£è¡¨ç»“æ„ä½“æœ¬èº«
        fn new() -> Self {
            Rust(String::from("Rust"))
        }

        fn print() {
            let rust = Rust::new();
            println!("{:?}", rust.0)
        }
    }

    // 3 æ–¹æ³•è°ƒç”¨
    let r = Rust::new();

    Rust::print();

    // 4 è®¿é—®ç»“æ„ä½“æˆå‘˜
    println!("{:?}", r.0)
```

**æ‰©å±•èµ„æ–™**

1. [å®˜æ–¹æ–‡æ¡£å¯¹äºç»“æ„ä½“çš„ä»‹ç»](https://rustwiki.org/zh-CN/book/ch05-00-structs.html)

#### æšä¸¾

```rust
    // æšä¸¾åœ¨å½¢å¼ä¸Šå’Œç»“æ„ä½“è¾ƒä¸ºç›¸ä¼¼
    enum Subject {
        Math,
        Chinese,
        English(String),
    }

    // åˆå§‹åŒ–
    let subject = Subject::English(String::from("English"));

    //æ ‡å‡†åº“ä¸­ä¸¤ä¸ªæ¯”è¾ƒé‡è¦çš„æšä¸¾ Optionå’Œ Result

    // Result ç”¨äºä¸€äº›å¤„æ“ä½œå¯èƒ½é‡åˆ°é”™è¯¯çš„åœºæ™¯ï¼Œæ¯”å¦‚æ‰“å¼€æ–‡ä»¶æ—¶ï¼Œå¦‚æœæˆåŠŸï¼Œè¿”å›æ–‡ä»¶ï¼Œé‡åˆ°é”™è¯¯æ—¶è¿”å›ä¸€ä¸ªError
    use std::fs::File;

    let file: Result<File, std::io::Error> = File::open("tmp.txt");

    // Option ç”¨äºä¸€äº›å€¼å¯èƒ½ä¸ºç©ºçš„æƒ…å†µ
    // å¦‚å°è¯•è·å–å“ˆå¸Œè¡¨ä¸­æŸä¸ªkeyæ‰€å¯¹åº”çš„valueï¼Œå½“å€¼å­˜åœ¨æ—¶ï¼Œè¿”å›å€¼ï¼Œå½“ä¸å­˜åœ¨æ—¶è¿”å›None

    use std::collections::HashMap;

    let map: HashMap<&str, u32> = HashMap::new();
    let v: Option<&u32> = map.get("rust");
```

**æ‰©å±•èµ„æ–™**

1. [å®˜æ–¹æ–‡æ¡£ä¸­å¯¹äºæšä¸¾çš„ä»‹ç»](https://rustwiki.org/zh-CN/book/ch06-01-defining-an-enum.html)

#### å‡½æ•°

```rust
    // 1 å‡½æ•°å®šä¹‰
    // 1.1 æ²¡æœ‰å‚æ•°å’Œè¿”å›å€¼çš„å‡½æ•°
    fn foo() {
        println!("foo")
    }

    // 1.2 æœ‰å‚æ•°å’Œè¿”å›å€¼çš„å‡½æ•°

    fn bar(s: &str) -> String {
        String::from(s)
    }

    // 1.3 å‚æ•°ç±»å‹å¿…é¡»æ˜¾å¼å£°æ˜ï¼Œæ¯”å¦‚å¼•ç”¨æˆ–è€…å¯å˜æ€§

    fn foobar(mut s: &str) -> &str {
        s = "rust";
        s
    }

    // 2 å‡½æ•°è°ƒç”¨

    foo();
    bar("Rust");
    foobar("go");

    // 3 å‡½æ•°ä½œä¸ºå‚æ•°

    fn a(f: fn() -> u32) -> u32 {
        let value = f();

        value
    }

    fn b() -> u32 {
        42
    }

    // æŠŠå‡½æ•°ä½œä¸ºå‚ä¼ ç»™å¦ä¸€ä¸ªå‡½æ•°

    a(b);
```

**æ‰©å±•èµ„æ–™**

1.[å®˜æ–¹æ–‡æ¡£ä¸­å…³äºå‡½æ•°çš„ä»‹ç»](https://rustwiki.org/zh-CN/book/ch03-03-how-functions-work.html)

#### é—­åŒ…

```rust
    // 1 é—­åŒ…å®šä¹‰

    // é—­åŒ…å¯ä»¥æ•è·ç¯å¢ƒå˜é‡,å¹¶ä¸”æ ¹æ®å…¶å¯¹ç¯å¢ƒå˜é‡çš„æ“ä½œå¯ä»¥åˆ†ä¸ºä»¥ä¸‹ä¸‰ç±»

    let c1 = || print!("æœªæ•è·ç¯å¢ƒå˜é‡");

    let v = "rust";
    let c2 = || print!("æ•è·ç¯å¢ƒå˜é‡ä½†ä¸ä¿®æ”¹ {}", v);

    let mut s0 = String::from("hello");

    // é—­åŒ…çš„å‚æ•°å†™åœ¨ ï½œï½œ ä¸­

    let mut c3 = |s: String| {
        s0 = s + v;
        println!("æ•è·å¹¶ä¿®æ”¹ç¯å¢ƒå˜é‡ {:?}", s0)
    };

    // 2 é—­åŒ…çš„è°ƒç”¨

    // é—­åŒ…çš„è°ƒç”¨åŒå‡½æ•°ä¸€æ ·

    c1();
    c2();
    c3(String::from("rust"));
```

**æ‰©å±•èµ„æ–™**

1.[å®˜æ–¹æ–‡æ¡£ä¸­å…³äºé—­åŒ…çš„ä»‹ç»](https://rustwiki.org/zh-CN/book/ch13-01-closures.html)

#### æ³›å‹

Rust è¯­è¨€æ”¯æŒæ³›å‹ç¼–ç¨‹ï¼Œåœ¨å®é™…æ“ä½œä¸­ä¼šå¤§é‡æ¶‰åŠåˆ°æ³›å‹ã€‚æ³›å‹æä¾›äº†æŠ½è±¡èƒ½åŠ›ï¼Œè®©ä»£ç å¤ç”¨æ€§æ›´å¼ºã€‚æ³›å‹ä¸€èˆ¬å’Œå…¶å®ƒæ•°æ®ç»“æ„ç»“åˆä½¿ç”¨

```rust
    // 1 æ³›å‹å‚æ•°çš„è¡¨ç¤º

    // æ³›å‹å‚æ•°ä¸€èˆ¬ç”¨å¤§å†™å­—æ¯`T`è¡¨ç¤º,å¤šä¸ªæ³›å‹å‚æ•°å¯ä»¥ä½¿ç”¨å¤šä¸ªå¤§å†™å­—æ¯

    // å­¦ä¹ æ³›å‹æ—¶å¯ä»¥æŠŠæ³›å‹å½“ä½œè‡ªå®šä¹‰ç±»å‹ï¼Œå®ƒå¿…é¡»å…ˆå£°æ˜æ‰èƒ½ä½¿ç”¨

    // 2 æ³›å‹å¦‚ä½•ä½¿ç”¨

    // 2.1 é›†åˆ Vec<T>
    // é›†åˆvectorå°±æ˜¯ç”±æ³›å‹æä¾›æ”¯æŒçš„,å®ƒå…è®¸æˆ‘ä»¬ä½¿ç”¨æŸä¸ªå…·ä½“ç±»å‹æ—¶å†æŒ‡å®š

    let v1: Vec<u8> = Vec::new();
    let v2: Vec<String> = Vec::new();
    let v3: Vec<bool> = Vec::new();

    // 2.2 æ³›å‹ç»“æ„ä½“

    // å¯ä»¥å£°æ˜ä¸€ä¸ªæ³›å‹ç»“æ„ä½“ï¼Œç„¶åå†ä½¿ç”¨çš„æ—¶å€™åœ¨æŒ‡å®šæˆå‘˜çš„å…·ä½“ç±»å‹
    // æ³¨æ„ï¼šå¿…é¡»å…ˆåœ¨` <> `ä¸­å£°æ˜æ³›å‹å‚æ•°ï¼Œç„¶åæ‰èƒ½ä½¿ç”¨

    struct Type<T>(T);
    struct Point<A, B> {
        a: A,
        b: B,
    }

    let t1 = Type(42);
    let t2 = Type("rust");

    let p1 = Point { a: 42, b: 42 };
    let p2 = Point { a: 42.1, b: 42.1 };

    // ä¸ºæ³›å‹ç»“æ„ä½“å®ç°æ–¹æ³•
    // æ³¨æ„ï¼šä¸ºæ³›å‹ç»“æ„ä½“å®ç°æ–¹æ³•æ—¶ï¼Œimplå’Œç»“æ„ä½“åé¢çš„æ³›å‹å£°æ˜è¦ä¿æŒä¸€è‡´
    impl<A, B> Point<A, B> {
        fn new(a: A, b: B) -> Self {
            Point { a, b }
        }
    }

    // 2.3 æ³›å‹æšä¸¾

    // åŒæ ·ï¼Œå¯ä»¥å®šä¹‰æ³›å‹æšä¸¾

    enum Area<A, B, C> {
        Rectangle(A),
        Square(B),
        Circle(C),
    }

    let a1: Area<f64, u32, &str> = Area::Rectangle(42f64);
    let a2: Area<f32, u64, &str> = Area::Square(42u64);
    let a3: Area<f64, u32, &str> = Area::Circle("100 cm^2");

    // 2.4 æ³›å‹å‡½æ•°

    // å‡½æ•°å‚æ•°ä¹Ÿå¯ä»¥æ˜¯æ³›å‹, å½“ç„¶æ³›å‹ä¹Ÿéœ€è¦åœ¨ `<>` ä¸­å…ˆå£°æ˜

    fn generics<T, B>(a: T, b: B) -> T {
        a
    }
    generics(32, "rust");
    generics("rust", 32);
```

**æ‰©å±•èµ„æ–™**

1.[å®˜æ–¹æ–‡æ¡£ä¸­å…³äºæ³›å‹çš„ä»‹ç»](https://rustwiki.org/zh-CN/book/ch10-00-generics.html)

### 1.3.4 æ§åˆ¶æµ

Rust ç¨‹åºåœ¨ä¹¦å†™ä¸Šå¹¶æ²¡æœ‰å¤ªå¤æ‚çš„ç»“æ„ï¼Œå¾ªç¯å’Œæ¨¡å¼åŒ¹é…åŸºæœ¬èƒ½å¤Ÿæ»¡è¶³ç»å¤§å¤šæ•°åœºæ™¯éœ€æ±‚

#### å¾ªç¯

Rust æœ‰ä¸‰ç§å¾ªç¯ç»“æ„ for å¾ªç¯ï¼Œloop å’Œ while

```rust
    // 1 ä½¿ç”¨forå¾ªç¯éå†é›†åˆ
    // æ³¨æ„ï¼šRustä¸­çš„forå¾ªç¯æœ¬è´¨ä¸Šæ˜¯è¿­ä»£å™¨çš„è¯­æ³•ç³–ï¼Œè¿™ä¸ªæˆ‘ä»¬åé¢è¿˜ä¼šå†ä»‹ç»
    // è¿­ä»£å™¨æ¶‰åŠåˆ°æ›´å¤æ‚çš„çŸ¥è¯†ç‚¹ï¼Œåç»­ä¼šä»‹ç»

    let v = vec![1, 2, 3, 4, 5];

    for num in v {
        println!("{}", num);
    }

    let mut map = std::collections::HashMap::new();
    map.insert("a", 2);
    map.insert("b", 2);
    map.insert("c", 2);

    for kv_pair in map {
        println!("{:?}", kv_pair);
    }

    // 2 ä½¿ç”¨ loop æ‰§è¡Œæ— é™å¾ªç¯ï¼Œå¹¶ä½¿ç”¨breakç»ˆæ­¢

    let mut x = 0;

    loop {
        println!("{:?}", x);

        if x == 10 {
            break;
        } else {
            x = x + 1;
        }
    }

    // 3 ä½¿ç”¨ while æ‰§è¡Œæ¡ä»¶å¾ªç¯

    let mut x = 0;
    while x < 5 {
        println!("x is {}", x);
        x += 1;
    }
```

#### æ¨¡å¼åŒ¹é…

Rust ä¸­çš„æ¨¡å¼åŒ¹é…æŒ‡çš„æ˜¯ç»“æ„ä¸Šçš„åŒ¹é…ï¼Œæœ€å¸¸ç”¨æœ‰ matchã€while let ã€let ã€if let

```rust
    // 1 match
    // match æ˜¯æœ€é•¿ç”¨çš„æ¨¡å¼åŒ¹é…ï¼Œä¸»è¦å’Œæšä¸¾æ­é…ä½¿ç”¨ï¼Œä»¥åŒ¹é…ä¸åŒçš„æšä¸¾æˆå‘˜

    match std::fs::File::open("rust.txtr") {
        Ok(file) => println!("{:?}", file),
        Err(err) => panic!("{}", err),
    }

    // 2 if let
    // if let å¯ä»¥è®©æˆ‘ä»¬åªå…³æ³¨æˆ‘ä»¬æƒ³è¦çš„ç»“æœ

    if let Ok(file) = std::fs::File::open("rust.txtr") {
        println!("{:?}", file);
    }

    // 3 while let
    // å’Œ if let ç±»ä¼¼ï¼Œåªå¤„ç†æ­£ç¡®çš„ç»“æœ

    while let Ok(file) = std::fs::File::open("rust.txt") {
        println!("{:?}", file);
    }

    // 4 let
    // let æœ¬èº«ä¹Ÿæ˜¯ä¸€ç§æ¨¡å¼åŒ¹é…
    // ä½¿ç”¨ let åŒ¹é…å…ƒç»„ä¸­çš„å…ƒç´ 

    let tuple = (42, true, "rust");

    let (x, y, z) = tuple;

    println!("{:?}", x);
    println!("{:?}", y);
    println!("{:?}", z);
```

### 1.3.5 æ³¨é‡Š

Rust ä¸­çš„æ³¨é‡Šä¸»è¦åŒ…æ‹¬æ–‡æ¡£æ³¨é‡Šï¼Œå¤šè¡Œæ³¨é‡Šå’Œå•è¡Œæ³¨é‡Š

```rust
  /// 1. æ–‡æ¡£æ³¨é‡Š,ä¸€èˆ¬å†™åœ¨å½“å‰æ–‡ä»¶çš„æœ€é¡¶ç«¯

  fn main() {
      /*
         2. å¤šè¡Œæ³¨é‡Š
         Point ç»“æ„ä½“ä»£è¡¨äºŒç»´åæ ‡ç³»ä¸‹çš„ä¸€ä¸ªç‚¹ï¼Œé€šè¿‡åæ ‡å¯ä»¥æ±‚çš„ä»»æ„ä¸€ç‚¹åˆ°åŸç‚¹çš„è·ç¦»
      */
      struct Point(u32, u32);

      // 3. å•è¡Œæ³¨é‡Š
      // æ±‚æŸä¸€ç‚¹åˆ°åŸç‚¹è·ç¦»çš„å¹³æ–¹

      fn distance_square(p: Point) -> u32 {
          p.0 * p.0 + p.1 * p.1
      }

      let p = Point(3, 4);
      distance_square(p);
  }
```

**æ‰©å±•èµ„æ–™**

1.[å®˜æ–¹æ–‡æ¡£ä¸­å…³äºæ³¨é‡Šçš„ä»‹ç»](https://rustwiki.org/zh-CN/book/ch03-04-comments.html)

## 1.4 è¯¾åä¹ é¢˜

1. `rustup`æ˜¯ä»€ä¹ˆï¼Œå¦‚ä½•ç”¨å®ƒæ¥ç®¡ç† Rust ç‰ˆæœ¬ï¼Ÿ
2. Rust ä¸­`&str`å’Œ`String`çš„åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Œæ¯ä¸ªåº”è¯¥åœ¨ä»€ä¹ˆæ—¶å€™ä½¿ç”¨ï¼Ÿ
3. Rust ä¸­çš„æ³›å‹ç±»å‹æ˜¯ä»€ä¹ˆï¼Œä½ å¯ä»¥è‡ªå·±å†™å‡ ä¸ªä¾‹å­å—ï¼Ÿ
4. Rust ä¸­ä½¿ç”¨æ³›å‹ç±»å‹çš„ä¸€äº›å¸¸è§æ•°æ®ç»“æ„æœ‰å“ªäº›ï¼Ÿ
5. Rust ä¸­æœ‰å“ªä¸‰ç§å¾ªç¯ç»“æ„ï¼Œå®ƒä»¬å¦‚ä½•ä½¿ç”¨ï¼Ÿ
6. åœ¨ Rust ä¸­ï¼Œ`match`ã€`while let`ã€`let`å’Œ`if let`ä¹‹é—´çš„åŒºåˆ«æ˜¯ä»€ä¹ˆï¼Œæ¯ä¸ªåº”è¯¥åœ¨ä»€ä¹ˆæ—¶å€™ä½¿ç”¨ï¼Ÿ
7. Rust ä¸­æœ‰å“ªä¸‰ç§ç±»å‹çš„æ³¨é‡Šï¼Ÿ

# æ¨¡å—äºŒï¼šRust æ ¸å¿ƒçŸ¥è¯†

**å‰ç½®çŸ¥è¯†ï¼šç¼–ç¨‹è¯­è¨€éƒ½æ˜¯å¦‚ä½•ç®¡ç†å†…å­˜çš„ï¼Ÿ**

æ‰‹åŠ¨ç®¡ç†å†…å­˜ï¼Œä»£è¡¨è¯­è¨€ï¼šCã€C++ï¼Œå¦‚ä¸‹æ˜¯ä¸€æ®µ C++ä»£ç 

```c++
#include<iostream>

int main(){
    // ä½¿ç”¨ new åˆ†é…å†…å­˜
    int* myInt = new int;

    // æ£€æŸ¥å†…å­˜æ˜¯å¦æˆåŠŸåˆ†é…
    if(myInt == nullptr){
        std::cout << "Memory not allocated.\n";
        return 1;
    }

    // åœ¨åˆ†é…çš„å†…å­˜ä¸­å­˜å‚¨ä¸€ä¸ªå€¼
    *myInt = 10;
    std::cout << "Value of myInt: " << *myInt << "\n";

    // ä½¿ç”¨ delete é‡Šæ”¾å†…å­˜
    delete myInt;
    myInt = nullptr; // é˜²æ­¢äº§ç”Ÿæ‚¬ç©ºæŒ‡é’ˆ

    // æ£€æŸ¥å†…å­˜æ˜¯å¦å·²è¢«é‡Šæ”¾
    if(myInt == nullptr){
        std::cout << "Memory successfully freed.\n";
    }

    return 0;
}
```

å¼Šç«¯ï¼šå¼€å‘è€…å¿ƒæ™ºè´Ÿæ‹…é‡ï¼ŒæœªåŠæ—¶é‡Šæ”¾å†…å­˜å¯èƒ½å¯¼è‡´å†…å­˜å¥”æºƒï¼Œæœªæ­£ç¡®é‡Šæ”¾å†…å­˜å¯èƒ½å¯¼è‡´æ‚¬å‚æŒ‡é’ˆé—®é¢˜ï¼Œå¥½å¤„ï¼šç¨‹åºæ€§èƒ½ä¼˜è¶Š

è‡ªåŠ¨ç®¡ç†å†…å­˜ï¼ˆä½¿ç”¨åƒåœ¾å›æ”¶æœºåˆ¶ï¼‰ï¼Œä»£è¡¨è¯­è¨€ï¼šJava / GOï¼Œå¦‚ä¸‹æ˜¯ä¸€æ®µ Java ä»£ç 

```java
public class Main {
     public static void main(String[] args) {
         // åˆ›å»ºä¸€ä¸ªæ–°çš„å¯¹è±¡
         MyClass obj = new MyClass();

         // ä½¿ç”¨è¯¥å¯¹è±¡
         obj.printMessage();

         // obj ç°åœ¨è‡ªç„¶ç¦»å¼€äº†ä½œç”¨åŸŸï¼ŒGC åœ¨é€‚å½“çš„æ—¶å€™ä¼šè‡ªåŠ¨æ¸…ç†è¿™ä¸ªå¯¹è±¡æ‰€å ç”¨çš„å†…å­˜, GCåœ¨çœ‹ä¸è§çš„åœ°æ–¹è¿è¡Œ
         System.out.println("End of main method. The JVM will clean up the memory automatically when necessary.");
     }
 }

 class MyClass {
     public void printMessage() {
         System.out.println("Hello, World!");
     }
 }
```

å¼Šç«¯ï¼šç¨‹åºæ€§èƒ½ä½ã€å†…å­˜å¼€é”€å¤§ã€ä¸–ç•Œæš‚åœï¼Œå¥½å¤„æ˜¯å¼€å‘è€…å¿ƒæ™ºè´Ÿæ‹…å°ï¼Œè½»æ¾æ˜“ä¸Šæ‰‹

å…¶å®ƒå†…å­˜ç®¡ç†æ–¹æ¡ˆï¼ˆæ¯”å¦‚ Rust æ‰€æœ‰æƒæœºåˆ¶ä¸æ£€æŸ¥è§„åˆ™ç®¡ç†ï¼‰ï¼Œä»£è¡¨è¯­è¨€ï¼šRustï¼Œå¦‚ä¸‹æ˜¯ Rust ä»£ç 

```rust
fn main() {
    // åˆ†é…å†…å­˜
    // æ‰€æœ‰è€…æ˜¯language,å€¼æ˜¯åˆ†é…åœ¨å †ä¸Šçš„str
    let language = String::from("Chinese");

    {
        //åˆ†é…å†…å­˜
        // x ä¹Ÿæ˜¯ä¸€ä¸ªæ‰€æœ‰è€…ï¼Œå®ƒçš„å€¼å­˜æ”¾åœ¨ç¨‹åºçš„åªè¯»å†…å­˜ä¸­
        let x = "x";

        // å½“xç¦»å¼€å®ƒçš„ä½œç”¨åŸŸæ—¶ï¼Œå®ƒå¯¹åº”çš„å€¼ï¼ˆå†…å­˜ï¼‰ä¹Ÿä¼šè¢«é‡Šæ”¾
    }

    // print!("x:{}", x); // æ— æ³•ä½¿ç”¨ x, å› ä¸ºxå·²ç»ç¦»å¼€äº†å®ƒçš„ä½œç”¨åŸŸ

    println!("Language: {}", language);

    // å½“mainå‡½æ•°ç»“æŸï¼Œlanguageï¼ˆæ‰€æœ‰è€…ï¼‰ç¦»å¼€å…¶ä½œç”¨åŸŸï¼Œå¯¹åº”çš„å€¼ä¹Ÿå°±è¢«é‡Šæ”¾äº†
    // æ‰€æœ‰æƒçš„å†…å­˜ç®¡ç†é€»è¾‘ï¼šâ€œäººåœ¨å€¼åœ¨â€ï¼ˆå³æ‰€æœ‰è€…åœ¨ï¼Œåˆ™å…¶å¯¹åº”çš„å€¼ï¼ˆå†…å­˜ï¼‰å°±åœ¨ï¼Œæ‰€æœ‰è€…ä¸åœ¨æŸä¸ªä½œç”¨åŸŸäº†ï¼Œé‚£å€¼ï¼ˆå†…å­˜ï¼‰ä¹Ÿå°±è¢«é‡Šæ”¾äº†ï¼Œè¿™å°±æŠŠç®¡ç†å†…å­˜çš„é—®é¢˜è½¬å˜ä¸ºç®¡ç†æ‰€æœ‰è€…æ‰€æœ‰æƒçš„é—®é¢˜äº†ï¼Œæ‰€æœ‰æƒæœºåˆ¶ä¹Ÿå°±è¿™ä¹ˆæ¥äº†
}
```

å¼Šç«¯ï¼šéœ€è¦ç†è§£æ‰€æœ‰æƒä¸å€Ÿç”¨æ£€æŸ¥è§„åˆ™ï¼Œå¥½å¤„ï¼šä¸€æ—¦ä¸Šæ‰‹ï¼Œè½»æ¾æ— è´Ÿæ‹…ã€ç¨‹åºæ€§èƒ½ä¼˜è¶Š

Rust æ˜¯æ—  GCï¼ˆgarbage collectionï¼‰çš„è¯­è¨€ï¼Œå¯¹äºå †å†…å­˜çš„ç®¡ç†ä¸»è¦é€šè¿‡æ ˆæ¥å®ç°ã€‚å…·ä½“è€Œè¨€å°±æ˜¯é€šè¿‡å€Ÿç”¨æ£€æŸ¥å’Œæ‰€æœ‰æƒæœºåˆ¶æ¥å®ç°ã€‚æ ¸å¿ƒè§„åˆ™å¦‚ä¸‹

**æ‰€æœ‰æƒæœºåˆ¶ï¼š**

1. æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…ï¼ˆownerï¼‰ï¼ˆå”¯ä¸€æ€§ï¼Œå¤§å¤šæ•°æƒ…å†µä¸‹æ‰€æœ‰è€…å’Œå€¼ä¸€ä¸€å¯¹åº”ï¼‰
2. æ¯ä¸ªå€¼åœ¨ä»»ä¸€æ—¶åˆ»åªæœ‰ä¸€ä¸ªæ‰€æœ‰è€… ï¼ˆæŒç»­æ€§ï¼Œä»»ä½•æƒ…å†µä¸‹å€¼éƒ½åªæœ‰ä¸€ä¸ªæ‰€æœ‰è€…ï¼‰
3. å½“æ‰€æœ‰è€…ï¼ˆå˜é‡ï¼‰ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå®ƒæ‰€æ‹¥æœ‰çš„å€¼å°†è¢«ä¸¢å¼ƒ ï¼ˆå†…å­˜ç®¡ç†ï¼Œå€¼å’Œæ‰€æœ‰è€…ç»‘å®šï¼Œéšæ‰€æœ‰è€…â€œç¦»å¼€â€è€Œâ€œé‡Šæ”¾â€ï¼‰

**Rust çš„å€Ÿç”¨è§„åˆ™ï¼š**

1. åŒä¸€ä¸ªä½œç”¨åŸŸä¸­ï¼Œä¸€ä¸ªèµ„æºåªæœ‰ä¸€ä¸ªå¯å˜**å€Ÿç”¨**ï¼ˆ&mut Tï¼‰ï¼Œä¹Ÿå°±æ˜¯è¯´æ‹¥æœ‰å¯å˜**å€Ÿç”¨**ï¼ˆ&mut Tï¼‰åå°±ä¸èƒ½å†æ‹¥æœ‰ä¸å¯å˜**å€Ÿç”¨**ï¼ˆ&Tï¼‰

2. åŒä¸€ä¸ªä½œç”¨åŸŸä¸­ï¼Œä¸€ä¸ªèµ„æºå¯ä»¥æœ‰å¤šä¸ªä¸å¯å˜**å€Ÿç”¨**ï¼ˆ&Tï¼‰
3. **å€Ÿç”¨**åœ¨å®ƒç¦»å¼€ä½œç”¨åŸŸåä¼šè¢«é‡Šæ”¾

## 2.1 æ•°æ®ç±»å‹ä¸æ‰€æœ‰æƒ

### 2.1.1 å›ºå®šç±»å‹ä¸æ‰€æœ‰æƒ

å›ºå®šå°ºå¯¸ç±»å‹æ˜¯æŒ‡é‚£äº›åœ¨ç¼–è¯‘æœŸå°±å¯ä»¥ç¡®å®šå¤§å°çš„ç±»å‹ã€‚Rust ä¸­ä¸»è¦çš„å›ºå®šå°ºå¯¸ç±»å‹å¦‚ä¸‹ï¼š

| ç±»å‹     | æè¿°                             |
| -------- | -------------------------------- |
| åŸºæœ¬ç±»å‹ | æ•´æ•°ã€æµ®ç‚¹æ•°ã€å¸ƒå°”å€¼å’Œå­—ç¬¦ç±»å‹ç­‰ |
| å¤åˆç±»å‹ | æ•°ç»„ã€å…ƒç»„ç­‰                     |
| æŒ‡é’ˆç±»å‹ | å¼•ç”¨å’Œè£¸æŒ‡é’ˆã€å‡½æ•°æŒ‡é’ˆç­‰         |
| ...      | ...                              |

å›ºå®šå¤§å°ç±»å‹ï¼šä¸€æ—¦å£°æ˜ï¼šåœ°å€å’Œå¤§å°ä¸å¯å†å˜

```
fn main() {
    let mut a: i32 = 32;

    // è·å– 'a' å˜é‡çš„å¤§å°ï¼ˆæ”¹å˜å‰ï¼‰
    let size_before_a = std::mem::size_of_val(&a);
    println!("Size of 'a' before change: {} bytes", size_before_a); // æ‰“å°ç»“æœï¼šSize of 'a' before change: 4 bytes

    // æ‰“å° 'a' å˜é‡çš„åœ°å€ï¼ˆæ”¹å˜å‰ï¼‰
    let address_before_a = &a as *const i32;
    println!("Address of 'a' before change: {:?}", address_before_a);

    a = 64;

    // è·å– 'a' å˜é‡çš„å¤§å°ï¼ˆæ”¹å˜åï¼‰
    let size_after_a = std::mem::size_of_val(&a);
    println!("Size of 'a' after change: {} bytes", size_after_a); // æ‰“å°ç»“æœï¼šSize of 'a' after change: 4 bytes

    // æ‰“å° 'a' å˜é‡çš„åœ°å€ï¼ˆæ”¹å˜åï¼‰
    let address_after_a = &a as *const i32;
    println!("Address of 'a' after change: {:?}", address_after_a);

    let mut t = ('a', 32, true, 42.1);

    // è·å– 't' å˜é‡çš„å¤§å°ï¼ˆæ”¹å˜å‰ï¼‰
    let size_before_t = std::mem::size_of_val(&t);
    println!("Size of 't' before change: {} bytes", size_before_t); // æ‰“å°ç»“æœï¼šSize of 't' before change: 24 bytes

    // æ‰“å° 't' å˜é‡çš„åœ°å€ï¼ˆæ”¹å˜å‰ï¼‰
    let address_before_t = &t as *const (_, _, _, _);
    println!("Address of 't' before change: {:?}", address_before_t);

    t = ('b', 64, false, 84.2);

    // è·å– 't' å˜é‡çš„å¤§å°ï¼ˆæ”¹å˜åï¼‰
    let size_after_t = std::mem::size_of_val(&t);
    println!("Size of 't' after change: {} bytes", size_after_t); // æ‰“å°ç»“æœï¼šSize of 't' after change: 24 bytes

    // æ‰“å° 't' å˜é‡çš„åœ°å€ï¼ˆæ”¹å˜åï¼‰
    let address_after_t = &t as *const (_, _, _, _);
    println!("Address of 't' after change: {:?}", address_after_t);
}
```

å…¶å®ƒçš„å›ºå®šå¤§å°ç±»å‹å®ä¾‹

```
use std::mem::size_of;

fn main() {
    // æ•´æ•°ç±»å‹
    let int_var: i32 = 10;
    println!("Size of integer: {}", size_of::<i32>());  // æ‰“å°ç»“æœï¼šSize of integer: 4

    // æµ®ç‚¹æ•°ç±»å‹
    let float_var: f64 = 10.0;
    println!("Size of float: {}", size_of::<f64>());  // æ‰“å°ç»“æœï¼šSize of float: 8

    // å¸ƒå°”ç±»å‹
    let bool_var: bool = true;
    println!("Size of bool: {}", size_of::<bool>());  // æ‰“å°ç»“æœï¼šSize of bool: 1

    // å­—ç¬¦ç±»å‹
    let char_var: char = 'a';
    println!("Size of char: {}", size_of::<char>());  // æ‰“å°ç»“æœï¼šSize of char: 4

    // æ•°ç»„ç±»å‹
    let array_var: [i32; 5] = [1, 2, 3, 4, 5];
    println!("Size of array: {}", size_of::<[i32; 5]>());  // æ‰“å°ç»“æœï¼šSize of array: 20

    // å…ƒç»„ç±»å‹
    let tuple_var: (i32, f64, bool, char) = (10, 10.0, true, 'a');
    println!("Size of tuple: {}", size_of::<(i32, f64, bool, char)>());  // æ‰“å°ç»“æœï¼šSize of tuple: 24

    // å¼•ç”¨ç±»å‹
    let ref_var: &i32 = &10;
    println!("Size of reference: {}", size_of::<&i32>());  // æ‰“å°ç»“æœï¼šSize of reference: 8

    // è£¸æŒ‡é’ˆç±»å‹
    let raw_pointer_var: *const i32 = &10;
    println!("Size of raw pointer: {}", size_of::<*const i32>());  // æ‰“å°ç»“æœï¼šSize of raw pointer: 8

    // å‡½æ•°æŒ‡é’ˆç±»å‹
    let fn_pointer_var: fn() = foo;
    println!("Size of function pointer: {}", size_of::<fn()>());  // æ‰“å°ç»“æœï¼šSize of function pointer: 8
}

fn foo() {
    println!("This is a function.");
}
```

æ‰€æœ‰æƒè§„åˆ™åœ¨å›ºå®šå¤§å°ç±»å‹ä»£ç ä¸­çš„ä½“ç°ï¼šå°†ä¸€ä¸ªå˜é‡ä½œä¸ºå€¼èµ‹å€¼ç»™å¦ä¸€ä¸ªå˜é‡æ—¶ï¼Œå‘ç”Ÿå€¼æ‹·è´è¡Œä¸º

```

   // 1 æ‰€æœ‰æƒä¸åŸºæœ¬ç±»å‹

    // ä¸‹é¢çš„æ¯ä¸ªå€¼éƒ½åªæœ‰ä¸€ä¸ªæ‰€æœ‰è€…

    let num1 = 42;

    let num2 = num1; // num2æ˜¯ä¸€ä¸ªæ–°çš„æ‰€æœ‰è€…ï¼Œå®ƒçš„å€¼æ˜¯ num1å€¼çš„å¤åˆ¶å“ï¼Œnum1ä»ç„¶æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„æ‰€æœ‰è€…
    println!("{}", num1); // 42,å¯ä»¥é€šè¿‡ num1 ä½¿ç”¨å€¼

    // ç°åœ¨æœ‰ä¸¤ä¸ªå€¼å’Œå¯¹åº”çš„ä¸¤ä¸ªæœ‰æ•ˆçš„æ‰€æœ‰è€…ï¼Œnum1 å’Œ num2

    println!("num1 addr {}", num1);
    println!("num2 addr {}", num2);

    // å¯ä»¥çœ‹åˆ°å€¼çš„åœ°å€ä¹Ÿæ˜¯ä¸ç›¸åŒï¼ˆä½è¯num1å’Œnum2å„æ‹¥æœ‰ä¸€ä¸ªå€¼ï¼‰
    // å¯¹äºå€¼42æ¥è¯´ï¼Œå®ƒåªæœ‰ä¸€ä¸ªæ‰€æœ‰è€…ï¼Œå› æ­¤ç°åœ¨æœ‰ä¸¤ä¸ª42çš„å€¼ï¼Œå¹¶ä¸”å®ƒä»¬çš„åœ°å€æ˜¯ä¸åŒçš„

    println!("num1 addr {:p}", &num1); // 0x7ff7b404dd90
    println!("num2 addr {:p}", &num2); // 0x7ff7b404dd94

    let f1 = 42.0;
    let b1 = true;

    {
        let c1 = '4'; // â€˜4â€™ è¿™ä¸ªå€¼çš„æ‰€æœ‰è€… `c1` åœ¨ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå€¼ä¼šè¢«ä¸¢å¼ƒ

        let c2 = c1;

        println!("c1 addr {:p}", &c1); // 0x7ff7b404dde8
        println!("c2 addr {:p}", &c2); // 0x7ff7b404ddec
    }

    // println!("{}", c1) // æ— æ³•å†ä½¿ç”¨ owner4,å› ä¸ºå®ƒå·²ç»è¢«ä¸¢å¼ƒ

    // 2 æ‰€æœ‰æƒä¸å¤åˆç±»å‹

    let arr1: [i32; 3] = [1, 2, 3];
    let arr2 = arr1;

    println!("arr1 addr {:p}", &arr1); // 0x7ff7b404dd90
    println!("arr2 addr {:p}", &arr2); // 0x7ff7b404dd94

    let tuple1 = (32, true, 42.0);
    let tuple2 = tuple1;

    println!("tuple1 addr {:p}", &tuple1); // 0x7ff7b404dd91
    println!("tuple2 addr {:p}", &tuple2); // 0x7ff7b404dd93

    // 3 æ‰€æœ‰æƒä¸æŒ‡é’ˆç±»å‹

    // è¿™é‡Œæ‰€è¯´çš„æŒ‡é’ˆæ˜¯æŒ‡æŒ‡å‘æŸä¸ªå†…å­˜åœ°å€çš„å˜é‡ç±»å‹ï¼ŒåŒ…æ‹¬å¼•ç”¨ã€è£¸æŒ‡é’ˆä»¥åŠå‡½æ•°æŒ‡é’ˆ

    // 3.1 å¼•ç”¨
    let num = 21;

    let p1 = &num;
    let p2 = p1;

    println!("num {}", &num);

    println!("p1 addr {:p}", &p1); // 0x7ff7ba58c938
    println!("p2 addr {:p}", &p2); // 0x7ff7ba58c940

    // 3.1 è£¸æŒ‡é’ˆ
    // åœ¨rustä¸­ä½¿ç”¨ `as *const T` å¯ä»¥å°†å¼•ç”¨è½¬ä¸ºè£¸æŒ‡é’ˆ

    let num = 32;

    let r_p1 = &num as *const i32;
    let r_p2 = r_p1;

    println!("r_p1 addr {:p}", &r_p1); // 0x7ff7b9ecc940
    println!("r_p2 addr {:p}", &r_p2); // 0x7ff7b9ecc948

    // 3.2 å‡½æ•°æŒ‡é’ˆ
    fn add(a: i32, b: i32) -> i32 {
        a + b
    }

    let f_p1: fn(i32, i32) -> i32 = add;
    let f_p2 = f_p1;

    println!("f_p1 addr {:p}", &f_p1); // 0x7ff7b606f9d0
    println!("f_p2 addr {:p}", &f_p2); // 0x7ff7b606f9d8

    // æ€»ç»“ï¼šå¯¹äºå›ºå®šå¤§å°ç±»å‹è€Œè¨€ï¼Œå°†ä¸€ä¸ªå˜é‡èµ‹å€¼ç»™å¦ä¸€ä¸ªå˜é‡æ—¶ï¼Œå®é™…ä¸Šæ˜¯ä¸ºæ–°å˜é‡å¼€è¾Ÿäº†æ–°çš„å†…å­˜ç©ºé—´ï¼Œå¹¶æŠŠå€¼æ‹·è´è¿‡æ¥ï¼Œä¹Ÿå°±Copyè¯­ä¹‰
    // æœ€ç»ˆçš„ç»“æœæ˜¯äº§ç”Ÿä¸€ä¸ªæ–°çš„æ‰€æœ‰è€…ä»¥åŠå¯¹åº”çš„å€¼ï¼Œå¹¶ä¸”æ–°å˜é‡å’ŒåŸå˜é‡äº’ä¸å½±å“
```

### 2.1.2 åŠ¨æ€ç±»å‹ä¸æ‰€æœ‰æƒ

Rust æ˜¯ä¸€é—¨é™æ€ç±»å‹è¯­è¨€ï¼Œè¿™æ„å‘³ç€æ‰€æœ‰å˜é‡åœ¨ç¼–è¯‘æœŸå¿…é¡»æ˜¯å¤§å°ç¡®å®šçš„ï¼Œä½†æ˜¯åœ¨å®é™…åœºæ™¯ä¸­ï¼Œæ¯”å¦‚å­—ç¬¦ä¸²å’Œåˆ‡ç‰‡ç±»å‹çš„å¤§å°å–å†³äºè¿è¡Œæ—¶çš„å…·ä½“æƒ…å†µã€‚Rust å¯¹è¿™ç±»æ•°æ®çš„å¤„ç†æ–¹æ³•æ˜¯ä½¿ç”¨å®ƒä»¬çš„æŒ‡é’ˆï¼ˆå¼•ç”¨ï¼‰ï¼Œè€Œä¸æ˜¯æ•°æ®æœ¬èº«ï¼Œä¼—æ‰€å‘¨çŸ¥ï¼Œä¸€ä¸ªç±»å‹ä¸ç®¡å¤šå¤§ï¼Œå¯¹åº”çš„æŒ‡é’ˆï¼ˆå¼•ç”¨ï¼‰å¤§å°æ˜¯ç¡®å®šçš„

| ç±»å‹         | æè¿°                                                                                       |
| ------------ | ------------------------------------------------------------------------------------------ |
| å­—ç¬¦ä¸²ç±»å‹   | str, æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ª u8 ç±»å‹çš„æ•°æ®åºåˆ—ï¼Œå®é™…ä¸­ç»å¸¸ä½¿ç”¨çš„å½¢å¼ï¼š&str å’Œ String                  |
| åˆ‡ç‰‡ç±»å‹     | [T], å®ƒä»£è¡¨ç±»å‹ä¸º `T` çš„å…ƒç´ ç»„æˆçš„æ•°æ®åºåˆ—ï¼šå®é™…ä¸­ç»å¸¸ä½¿ç”¨çš„å½¢å¼ï¼š Vec<T>                  |
| trait object | trait object çš„å¤§å°åªæœ‰åœ¨è¿è¡Œæ—¶æ‰èƒ½ç¡®å®šï¼ˆå¯ä»¥å…ˆä¸ç”¨äº†è§£ï¼Œå…³äº trait çš„å†…å®¹åé¢ä¼šç»§ç»­è®²è§£ï¼‰ |
| ...          | ...                                                                                        |

åŠ¨æ€ç±»å‹å¤§å°ï¼Œå£°æ˜åå†æ¬¡ä¿®æ”¹æ—¶ï¼Œå¤§å°å’Œåœ°å€å¯èƒ½ä¼šåŠ¨æ€å˜åŒ–

```
fn main() {
    // 1. &str
    let mut a = "rust";
    let size_of_a = std::mem::size_of_val(a);
    let ptr_of_a = a.as_ptr();

    println!("Size of 'rust': {} bytes", size_of_a); // æ‰“å°ç»“æœï¼šSize of 'rust': 4 bytes
    println!("Address of 'rust': {:p}", ptr_of_a); // æ‰“å°ç»“æœï¼šAddress of 'rust': 0x107e52fa0

    a = "go";
    let size_of_a = std::mem::size_of_val(a);
    let ptr_of_a = a.as_ptr();

    println!("Size of 'go': {} bytes", size_of_a); // æ‰“å°ç»“æœï¼šSize of 'go': 2 bytes
    println!("Address of 'go': {:p}", ptr_of_a); // æ‰“å°ç»“æœï¼šAddress of 'go': 0x107e52fdb

    let ptr_of_rust = "rust".as_ptr(); // è®¿é—®åˆè¯•çš„â€œrustâ€
    println!("Address of 'rust' after reassignment: {:p}", ptr_of_rust); // æ‰“å°ç»“æœï¼šAddress of 'rust' after reassignment: 0x107e52fa0

    // 2 String

    let mut string_data = String::from("Hello, Rust!");
    let size_of_string = string_data.len();
    let ptr_of_string = string_data.as_ptr();

    println!("Size of string data: {} bytes", size_of_string);
    println!("Address of string data: {:p}", ptr_of_string);

    string_data = String::from("Hello Rust, how are you today?");

    let size_of_string = string_data.len();
    let ptr_of_string = string_data.as_ptr();

    println!("Size of string data: {} bytes", size_of_string);
    println!("Address of string data: {:p}", ptr_of_string);

    // 3 vec

    let mut vec_data = vec![1];
    let size_of_vec = vec_data.len();
    let ptr_of_vec = vec_data.as_ptr();

    println!("Size of vector data: {} bytes", size_of_vec);
    println!("Address of vector data: {:p}", ptr_of_vec);

    vec_data.push(2);
    vec_data.push(3);
    vec_data.push(4);
    vec_data.push(5);
    vec_data.push(6);
    vec_data.push(7);
    vec_data.push(8);
    vec_data.push(9);

    let size_of_vec = vec_data.len();
    let ptr_of_vec = vec_data.as_ptr();

    println!("Size of vector data: {} bytes", size_of_vec);
    println!("Address of vector data: {:p}", ptr_of_vec);
}
```

æ‰€æœ‰æƒè§„åˆ™åœ¨åŠ¨æ€å¤§å°ç±»å‹ä¸­çš„ä½“ç°ï¼šå°†ä¸€ä¸ªå˜é‡ä½œä¸ºå€¼èµ‹å€¼ç»™å¦ä¸€ä¸ªå˜é‡æ—¶ï¼Œå‘ç”Ÿæ‰€æœ‰æƒè½¬ç§»è¡Œä¸º

```
    // 1 æ‰€æœ‰æƒä¸å­—ç¬¦ä¸²

    // æˆ‘ä»¬åœ¨å‰é¢ä»‹ç»è¿‡ï¼Œå­—ç¬¦ä¸²å¯ä»¥å­˜æ”¾åœ¨ç¨‹åºçš„åªè¯»æ•°æ®æ®µä¸­æˆ–è€…å †ä¸Š
    // ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œå­—ç¬¦ä¸²å­—é¢é‡å­˜æ”¾åœ¨åªè¯»æ•°æ®æ®µä¸­çš„ï¼Œå£°æ˜ä¹‹åå¾ˆå°‘å»ä¿®æ”¹å®ƒ
    // è€Œéœ€è¦åŠ¨æ€å˜åŒ–çš„å­—ç¬¦ä¸²æˆ‘ä»¬ä¼šæŠŠå®ƒå­˜æ”¾åˆ°å †ä¸Šï¼Œå¹¶ä¸”é€šè¿‡æ ˆå†…å­˜æ¥ç®¡ç†å †å†…å­˜

    let ptr_owner = "Rust"; // å­˜æ”¾åœ¨åªè¯»æ•°æ®æ®µä¸­
    let heap_ptr_owner = String::from("Rust"); //å­˜æ”¾åœ¨å †ä¸Š

    // 1.1 å¯¹äºå­˜æ”¾åœ¨åªè¯»æ•°æ®æ®µä¸­çš„å­—ç¬¦ä¸²å­—é¢é‡ï¼Œå®ƒçš„æ‰€æœ‰æƒè§„åˆ™å’Œå…¶ä»–åŸºæœ¬ç±»å‹ä¸€æ ·,è¿™é‡Œä¸å†èµ˜è¿°

    let ptr_copy = ptr_owner;

    // ç”±äº ptr_owner å’Œ ptr_copy çš„å€¼éƒ½æ˜¯æŒ‡å‘ç›¸åŒå€¼çš„å¼•ç”¨ï¼Œæ‰€ä»¥å®ƒä»¬æŒ‡å‘çš„å†…å­˜åœ°å€æ˜¯ç›¸åŒçš„
    println!("{:p}", ptr_owner); // 0x10ac12004
    println!("{:p}", ptr_copy); // 0x10ac12004

    let mut _heap_ptr_old = String::from("Rust"); //å­˜æ”¾åœ¨å †ä¸Š

    let heap_ptr_new = _heap_ptr_old;

    // println!("old owner{:?}", _heap_ptr_old); // æ— æ³•å†é€šè¿‡ _heap_ptr_old ä½¿ç”¨å€¼ï¼Œå› ä¸ºå®ƒå·²ç»æŠŠæ•°æ®æ‰€æœ‰æƒç§»äº¤ç»™äº†æ–°çš„æ‰€æœ‰è€… heap_ptr_new
    println!("new owner{:?}", heap_ptr_new); // heap_ptr_new å¯ä»¥æ­£å¸¸è®¿é—®åˆ°å †ä¸Šçš„æ•°æ®ï¼Œå¹¶ä¸”å®ƒæ˜¯å”¯ä¸€çš„æ‰€æœ‰è€…ï¼Œå½“å®ƒç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå †ä¸Šçš„æ•°æ®ä¹Ÿä¼šè¢«ä¸¢å¼ƒ

    {
        let owner_old = String::from("rust");
        let owner_new = owner_old;

        // åœ¨æ­¤å¤„ç¦»å¼€ä½œç”¨åŸŸ
    }

    // println!("{:?}", owner_new); æ— æ³•å†é€šè¿‡ owner_new ä½¿ç”¨å€¼ï¼Œå› ä¸ºå®ƒå·²ç»è¢«ä¸¢å¼ƒ

    _heap_ptr_old = String::from("Go"); // é‡æ–°èµ‹å€¼ï¼Œæ³¨æ„åŸå˜é‡ä¸èƒ½ä½¿ç”¨æ˜¯å› ä¸ºè½¬ç§»æ‰€æœ‰æƒåè¢«æ ‡æ³¨ä¸ºç©ºäº†ï¼Œè€Œä¸æ˜¯ç«‹å³è¢«æ¸…é™¤äº†

    // 2 æ‰€æœ‰æƒä¸slice

    // ä¸Šé¢çš„å­—ç¬¦ä¸²str å®é™…ä¸Šæ˜¯ä¸€ä¸ªç‰¹æ®Šçš„ slice, å®ƒä»…ä»£è¡¨æœ‰æ•ˆçš„utf-8åºåˆ—
    // è€Œåˆ‡ç‰‡ä¸­å¯ä»¥åŒ…å«ä»»ä½•ç±»å‹çš„å…ƒç´ ï¼Œå¦‚å…¶ä»–åŸºç¡€ç±»å‹ã€è‡ªå®šä¹‰ç±»å‹ç­‰, æ­£å¦‚ä¸ç›´æ¥ä½¿ç”¨ strä¸€æ ·ï¼Œæˆ‘ä»¬ä¹Ÿä¸ç›´æ¥ä½¿ç”¨[T],è€Œæ˜¯ä½¿ç”¨å®ƒçš„æŒ‡é’ˆï¼ˆå¼•ç”¨ï¼‰ç±»å‹ï¼ŒVec<T>
    // sliceä¸­çš„æ•°æ®ä¹Ÿå­˜æ”¾åœ¨å †ä¸Šï¼ŒRustä¸­sliceå†…å­˜ç®¡ç†é€»è¾‘åŒå­˜æ”¾åœ¨å †ä¸Šçš„str

    // vec æœ‰ä¸¤ç§åˆ›å»ºæ–¹å¼ï¼šä½¿ç”¨å®æˆ–è€…æ–¹æ³•
    let str_slice = vec!["rust", "go", "cpp"];
    let u32_slice: Vec<u32> = Vec::new();

    let new_owner1 = str_slice;
    let new_owner2 = u32_slice;

    // println!("{:?}", str_slice); // æ— æ³•å†é€šè¿‡ str_slice ä½¿ç”¨å€¼ï¼Œå› ä¸ºå®ƒå·²ç»è¢«ä¸¢å¼ƒ
    // println!("{:?}", u32_slice); // æ— æ³•å†é€šè¿‡ u32_slice ä½¿ç”¨å€¼ï¼Œå› ä¸ºå®ƒå·²ç»è¢«ä¸¢å¼ƒ

    println!("{:?}", new_owner1); // å¯ä»¥é€šè¿‡æ–°çš„æ‰€æœ‰è€…è®¿é—®åˆ°åŸæ¥çš„å€¼
    println!("{:?}", new_owner2); // å¯ä»¥é€šè¿‡æ–°çš„æ‰€æœ‰è€…è®¿é—®åˆ°åŸæ¥çš„å€¼

    // 3 æ€»ç»“
    // å½“æ•°æ®å­˜æ”¾åœ¨å †ä¸Šæ—¶ï¼ŒæŠŠæ‰€æœ‰æƒèµ‹å€¼ç»™å¦ä¸€ä¸ªå˜é‡ï¼Œæ„å‘³ç€æŠŠå †ä¸Šæ‰€æœ‰æƒå°±ä¼šè½¬ç§»ç»™æ–°çš„æ‰€æœ‰è€…ï¼Œå †ä¸Šçš„æ•°æ®æœ¬èº«æ²¡æœ‰è¢«å¤åˆ¶ï¼ŒåŸæ¥çš„æ‰€æœ‰è€…ä¸å†æ‹¥æœ‰æ•°æ®ï¼Œä¹Ÿå°±Moveè¯­ä¹‰ï¼Œè¿™é‡ŒæŒ‡çš„æ˜¯æ‰€æœ‰æƒçš„Move
    // å½“æ•°æ®å­˜æ”¾åœ¨æ ˆä¸Šæ—¶ï¼ŒæŠŠæ‰€æœ‰æƒèµ‹å€¼ç»™å¦ä¸€ä¸ªå˜é‡ï¼Œæ„å‘³ç€æŠŠæ ˆä¸Šçš„æ•°æ®å¤åˆ¶äº†ä¸€ä»½ç»™æ–°çš„æ‰€æœ‰è€…ï¼ŒåŸæ¥çš„æ‰€æœ‰è€…ä»ç„¶æ‹¥æœ‰åŸæ¥çš„æ•°æ®ï¼Œä¹Ÿå°±æ˜¯Copyè¯­ä¹‰ï¼Œè¿™é‡ŒæŒ‡å€¼çš„Copy
```

**æ‰©å±•èµ„æ–™**

1.[å®˜æ–¹æ–‡æ¡£ä¸­å…³äºæ‰€æœ‰æƒçš„ä»‹ç»](https://rustwiki.org/zh-CN/book/ch04-01-what-is-ownership.html)

### 2.1.3 æ‰€æœ‰æƒå…±äº«

æ‰€æœ‰æƒè§„åˆ™æ›´åƒæ˜¯å¯¹èµ„æºçš„ç‹¬å ï¼Œåœ¨å®é™…åœºæ™¯ä¸­ï¼Œä½ å¯èƒ½å¸Œæœ›å¤šä¸ªè§’è‰²å…±äº«è®¿é—®æŸä¸ªåŠ¨æ€èµ„æºã€‚Rust æä¾›äº†ä¸¤ä¸ªå®¹å™¨ç±»å‹ Rc<T>å’Œ Arc<T>ï¼Œå¯ä»¥è®©ä½ åŒæ—¶è®©å¤šä¸ªå˜é‡æ‹¥æœ‰åŠ¨æ€æ•°æ®çš„æ‰€æœ‰æƒ

```rust
    // 1 ç‹¬å è®¿é—®èµ„æº

    let mut dynamic_source = String::from("content");

    let role1 = dynamic_source;
    // let role2 = dynamic_source; // èµ„æºè¢« role1 æ‰€æœ‰ï¼Œæ­¤æ—¶role1ç‹¬å è®¿é—®
    let role2 = role1; // åªæœ‰role1 æŠŠæ‰€æœ‰æƒç§»äº¤ç»™ role2ï¼Œ role2 æ‰å¯ä»¥è®¿é—®

    // è¿™æ ·åšçš„å¥½å¤„æ˜¯ï¼Œå¯ä»¥é¿å…èµ„æºè¢«å¤šä¸ªå˜é‡åŒæ—¶è®¿é—®ï¼Œå¯¼è‡´èµ„æºè¢«ä¿®æ”¹
    // åå¤„æ˜¯ï¼Œèµ„æºåªèƒ½è¢«ä¸€ä¸ªå˜é‡è®¿é—®ï¼Œä½æ•ˆ

    use std::rc::Rc;
    use std::sync::Arc;

    // 2 æ‰€æœ‰æƒä¸å…±äº«å®¹å™¨ Rc<T>,å®ƒé€‚ç”¨äºå•çº¿ç¨‹

    // ä½¿ç”¨å…±äº«å®¹å™¨åŒ…è£¹åŠ¨æ€èµ„æº

    let dynamic_source = vec![1, 2];

    let container = Rc::new(dynamic_source);

    let role1 = container.clone(); // è¿™é‡Œcloneæ–¹æ³•å…¶å®æ˜¯å¤åˆ¶äº†å¯¹èµ„æºè®¿é—®çš„æ‰€æœ‰æƒï¼Œè€Œä¸æ˜¯èµ„æºæœ¬èº«
    let role2 = container.clone();

    // é€šè¿‡å…±äº«å®¹å™¨è®¿é—®èµ„æº,æ­¤æ—¶èµ„å…±äº«èµ„æºæœ‰ä¸‰ä¸ªæ‰€æœ‰è€…ï¼Œå¯ä»¥åŒæ—¶è®¿é—®
    println!("{:?}", container); // [1,2]
    println!("{:?}", role1); // [1,2]
    println!("{:?}", role2); // [1,2]

    // 3 æ‰€æœ‰æƒå…±äº«å®¹å™¨ Arc<T>ï¼Œå®ƒé€‚ç”¨äºå¤šçº¿ç¨‹

    let dynamic_source = String::from("rust");

    let container = Arc::new(dynamic_source);

    let role1 = container.clone(); // è¿™é‡Œcloneæ–¹æ³•å…¶å®æ˜¯å¤åˆ¶äº†å¯¹èµ„æºè®¿é—®çš„æ‰€æœ‰æƒï¼Œè€Œä¸æ˜¯èµ„æºæœ¬èº«
    let role2 = container.clone();

    // é€šè¿‡å…±äº«å®¹å™¨è®¿é—®èµ„æº,æ­¤æ—¶èµ„å…±äº«èµ„æºæœ‰ä¸‰ä¸ªæ‰€æœ‰è€…ï¼Œå¯ä»¥åŒæ—¶è®¿é—®
    println!("{:?}", container); // rust
    println!("{:?}", role1); // rust
    println!("{:?}", role2); // rust

    // 4 å…±äº«å®¹å™¨ä¸å†…å­˜ç®¡ç†
    // æ³¨æ„ï¼šRc<T>å’ŒArc<T>å®é™…ä¸Šæ˜¯ä¸€ç§å¼•ç”¨è®¡æ•°ï¼Œæ¯ä½¿ç”¨cloneæ–¹æ³•ä¸€æ¬¡ï¼Œå¼•ç”¨è®¡æ•°å°±ä¼š+1ï¼Œå½“å˜é‡ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå¼•ç”¨è®¡æ•°ä¼š-1ï¼Œå½“å¼•ç”¨è®¡æ•°ä¸º0æ—¶ï¼Œå †å†…å­˜ä¼šè¢«é‡Šæ”¾
    // æ•´ä¸ªè¿‡ç¨‹åœ¨ç¼–è¯‘å™¨çœ‹æ¥ï¼Œæ¯ä¸ªå˜é‡éƒ½æ‹¥æœ‰ä¸€ä¸ªRcæˆ–è€…Arcã€‚æ‰€ä»¥å¹¶ä¸è¿åæ‰€æœ‰æƒè§„åˆ™
    // è¿™é‡Œæä¸€ç‚¹:ä¸€èˆ¬æƒ…å†µä¸‹ï¼ŒRustä½¿ç”¨æ ˆæ¥ç®¡ç†å †å†…å­˜ã€‚ä½†æ˜¯Rcå’ŒArcæ˜¯ä¸€ç§ç‰¹åˆ«çš„æœºåˆ¶ï¼Œå®ƒå…è®¸ä¸å—æ ˆå†…å­˜æ§åˆ¶çš„å †å†…å­˜ï¼Œä¹Ÿå°±æ˜¯å…è®¸å†…å­˜æ³„éœ²ã€‚å¯¹äºè¿™ç§æ³„æ¼é€šè¿‡å¼•ç”¨è®¡æ•°æ¥ç®¡ç†

    // 4.1 é€šè¿‡æ ˆå†…å­˜æ¥ç®¡ç†å †å†…å­˜

    {
        let source = String::from("hello");

        let role1 = source;
        println!("{:?}", role1);
        // ä¸¢å¼ƒ

        // println!("{:?}", source); // ä¸èƒ½å†ä½¿ç”¨sourceï¼Œå› ä¸ºsourceå·²ç»ç§»äº¤äº†æ‰€æœ‰æƒ
        // å½“role1ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œä¼šç«‹å³ä¸¢å¼ƒ role1å’Œå †ä¸Šçš„æ•°æ®
    }

    // 4.2 é€šè¿‡å¼•ç”¨è®¡æ•°æ¥ç®¡ç†å †å†…å­˜

    {
        let source = String::from("hello");

        // ä½¿ç”¨RcåŒ…è£¹èµ„æºï¼Œè®©å †ä¸Šèµ„æºç”Ÿå‘½å‘¨æœŸæ›´é•¿
        let container = Rc::new(source); // å¼•ç”¨è®¡æ•° + 1
                                         //
        let role1 = container.clone(); // å¼•ç”¨è®¡æ•° + 1
        let role2 = container.clone(); // å¼•ç”¨è®¡æ•° + 1

        // å½“å˜é‡ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œrole2ï¼Œrole1ï¼Œcontainerç›¸ç»§ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå¼•ç”¨è®¡æ•°éƒ½ä¼š-1ï¼Œå½“å¼•ç”¨è®¡æ•°ä¸º0æ—¶ï¼Œå †ä¸Šçš„æ•°æ®æ‰ä¼šè¢«é‡Šæ”¾
    }
```

## 2.2 å€Ÿç”¨å’Œç”Ÿå‘½å‘¨æœŸ

### 2.2.1 å€Ÿç”¨ä¸å¼•ç”¨ä»¥åŠå€Ÿç”¨æ£€æŸ¥è§„åˆ™

å¼•ç”¨å’Œå€Ÿç”¨åœ¨Rustä¸­ä¸åŒè§†è§’ä¸‹çš„åŒä¸€ä¸ªæ¦‚å¿µã€‚Rustä¸­ä»»ä½•ç±»å‹çš„å˜é‡éƒ½éµä»æ‰€æœ‰æƒè§„åˆ™ï¼Œä½†å€¼ä¸ºå¼•ç”¨ç±»å‹çš„å˜é‡è¿˜æœ‰éµä»å€Ÿç”¨æ£€æŸ¥è§„åˆ™

```rust
fn main() {
    let mut s = String::from("Rust"); // å¯¹äºsæ¥è¯´ï¼Œå®ƒå°†å€¼å€Ÿç”¨ç»™äº†s_p
    let mut i = 32;

    let s_p = &mut s; // å¯¹äºs_pæ¥è¯´ï¼Œå®ƒå¼•ç”¨äº†sçš„å€¼
                      // let s_p1 = &mut s; // å¯¹äºs_p1æ¥è¯´ï¼Œå®ƒå¼•ç”¨äº†sçš„å€¼
                      // let s_p3 = &s;

    let i_p2 = &i;
    let i_p = &i;

    // s = String::from("Go");
    *s_p = String::from("Java");

    {
        let c = 'a';

        let c_p = &c;
        println!("{}", c_p);
        // c_p ç¦»å¼€ä½œç”¨åŸŸï¼Œå¯¹åº”çš„å€¼ï¼ˆå¼•ç”¨ï¼‰èµ„æºä¼šè¢«é‡Šæ”¾
    }

    // println!("{}", c_p);
}
```

### 2.2.2 å˜é‡ç”Ÿå‘½å‘¨æœŸ

æ ¹æ®æ˜¯å¦æ‹¥æœ‰æ•°æ®ï¼ˆå€¼ï¼‰ï¼ŒRust ä¸­çš„å˜é‡å¯ä»¥åˆ†ä¸ºæ‹¥æœ‰æ•°æ®çš„å˜é‡å’Œæ²¡æœ‰æ•°æ®å˜é‡ï¼Œä¹Ÿå°±æ˜¯è¯´å®ƒå¯¹åº”çš„å€¼æ˜¯ä¸€ä¸ªå¼•ç”¨

å½“å˜é‡å€¼ä¸ºæ•°æ®æ—¶ï¼Œä¸€èˆ¬Rustå¯ä»¥æ ¹æ®ä¸Šä¸‹æ–‡æ¨æ–­è¿™ä¸ªå˜é‡åœ¨å“ªé‡Œå£°æ˜çš„ä»¥åŠåœ¨å“ªé‡Œç¦»å¼€ä½œç”¨åŸŸçš„ï¼Œç„¶åå®ƒä¼šé€šè¿‡æ‰€æœ‰æƒè§„åˆ™é‡Šæ”¾å˜é‡æ‰€å¯¹åº”çš„å†…å­˜ï¼Œå½“ä¸€ä¸ªå˜é‡çš„å€¼æ˜¯æ¥è‡ªäºå¦ä¸€ä¸ªå€¼çš„å¼•ç”¨æ—¶ï¼ŒRustä¼šé€šè¿‡å€Ÿç”¨æ£€æŸ¥å™¨æ¥ç¡®ä¿æ‰€æœ‰çš„å¼•ç”¨éƒ½æ˜¯æœ‰æ•ˆçš„

```rust
    //1 å˜é‡çš„ç”Ÿå‘½å‘¨æœŸ : ä»å£°æ˜å¼€å§‹ï¼Œåˆ°ç¦»å¼€ä½œç”¨åŸŸç»“æŸ

    {
        let x = 32; // x çš„ç”Ÿå‘½å‘¨æœŸå¼€å§‹
        println!("{}", x);

        {
            let x_ptr = &x;  // x_ptr çš„ç”Ÿå‘½å‘¨æœŸå¼€å§‹
            
        } // x_ptr ç”Ÿå‘½å‘¨æœŸç»“æŸï¼Œå€¼ä¼šè¢«ä¸¢å¼ƒ

        // println!("{}", x_ptr); // æ— æ³•å†ä½¿ç”¨ x_ptr,å› ä¸ºå®ƒå·²ç»è¢«ä¸¢å¼ƒ

       
    }  // x ç”Ÿå‘½å‘¨æœŸç»“æŸï¼Œå€¼ä¼šè¢«ä¸¢å¼ƒ
```

### 2.2.3 ç”Ÿå‘½å‘¨æœŸå‚æ•°

å½“ä¸€ä¸ªå˜é‡çš„å€¼æ˜¯æ¥è‡ªäºå¦ä¸€ä¸ªå€¼çš„å¼•ç”¨æ—¶ï¼Œæœ‰æ—¶å€™ç¼–è¯‘å™¨å¹¶ä¸èƒ½å‡†ç¡®æ¨æ–­è¿™ä¸ªå¼•ç”¨çš„æœ‰æ•ˆæ€§

```
    // å¯ä»¥æ¨æ–­å¼•ç”¨çš„æœ‰æ•ˆæ€§
    // fn return_strings(x: &String) -> &String {
    //     let s = String::from("Rust");

    //     &s
    // }

    let s_p = return_string(&String::from("Rust"));

    fn return_string(x: &String) -> &String {
        x
    }

    struct Foo {
        x: i32,
        y: (i32, bool),
        z: String,
    }

    let f1 = Foo {
        x: 32,
        y: (32, true),
        z: String::from("rust"),
    };

    let f2 = Foo {
        x: 32,
        y: (32, true),
        z: String::from("rust"),
    };

    // ä»ç„¶æ— æ³•ç¼–è¯‘é€šè¿‡ï¼Œå› ä¸ºç¼–è¯‘å™¨æ— æ³•æ¨æ–­å‡ºå‚æ•°å’Œè¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸ
    // è¿™æ˜¯å› ä¸ºRustå¯¹äºå‡½æ•°çš„æ£€æŸ¥åªä¼šæ£€æŸ¥ç­¾åï¼Œè€Œä¸æ˜¯å‡½æ•°é‡Œé¢çš„å…·ä½“é€»è¾‘
    // å¯¹äºè¿™ä¸ªå‡½æ•°è¿”å›çš„å¼•ç”¨ï¼Œå› ä¸ºåªä»å‡½æ•°ç­¾åæ¥çœ‹ï¼Œè¿”å›çš„è¿™ä¸ªå¼•ç”¨ä¸çŸ¥é“æ˜¯æ¥è‡ªäºå“ªé‡Œï¼Œä¸€ä¸ªå¯èƒ½æ˜¯æ¥è‡ªäºä¸¤ä¸ªå‚æ•°çš„æŸä¸€ä¸ªï¼Œå¦ä¸€ç§æƒ…å†µæ˜¯å¯èƒ½æ¥è‡ªäºæŸä¸ªå†…éƒ¨å®šä¹‰çš„å˜é‡ï¼Œè¿™å°±ä¼šå¯¼è‡´æ‚¬å‚æŒ‡é’ˆ

    // æ— æ³•æ¨æ–­å¼•ç”¨çš„æœ‰æ•ˆæ€§
    // fn bar(x: &Foo, y: &Foo) -> &Foo {
    //     let f3 = Foo {
    //         x: 32,
    //         y: (32, true),
    //         z: String::from("rust"),
    //     };
    //     &f3
    // }

    // let new = bar(&f1, &f2);

    // é€šè¿‡ç”Ÿå‘½å‘¨æœŸå‚æ•°æ˜¾ç¤ºæŒ‡å®šå‚æ•°çš„ç”Ÿå‘½å‘¨æœŸ

    // &i32        // å¼•ç”¨
    // &'a i32     // å¸¦æœ‰æ˜¾å¼ç”Ÿå‘½å‘¨æœŸçš„å¼•ç”¨
    // &'a mut i32 // å¸¦æœ‰æ˜¾å¼ç”Ÿå‘½å‘¨æœŸçš„å¯å˜å¼•ç”¨

    let s: &'static str = "I have a static lifetime.";

    // è¿”å›å˜é‡çš„ç”Ÿå‘½å‘¨æœŸå’Œè‡³å°‘å’Œyä¸€æ ·é•¿
    fn bar<'a, 'b>(x: &'a Foo, y: &'b Foo) -> &'b Foo {
        y
    }

    fn bar1<'b>(x: &Foo, y: &'b Foo) -> &'b Foo {
        y
    }

    // 'a:'b,è¡¨ç¤º'aä¸çŸ­äº'b, åªèƒ½è¿”å›x
    fn bar2<'a: 'b, 'b>(x: &'a Foo, y: &'b Foo) -> &'a Foo {
        x
        // y
    }

    // xï¼Œy éƒ½å¯ä»¥
    fn bar3<'a: 'b, 'b>(x: &'a Foo, y: &'b Foo) -> &'b Foo {
        // x
        y
    }

    // è°ƒç”¨

    let f1 = Foo {
        x: 32,
        y: (32, true),
        z: String::from("rust"),
    };
    {
        let f2 = Foo {
            x: 32,
            y: (32, true),
            z: String::from("rust"),
        };

        bar(&f1, &f2);
        bar1(&f1, &f2);
        bar2(&f1, &f2);
        bar3(&f1, &f2);
    }
```

**æ‰©å±•èµ„æ–™**

1.[å®˜æ–¹æ–‡æ¡£ä¸­å…³äºå€Ÿç”¨çš„ä»‹ç»](https://rustwiki.org/zh-CN/book/ch04-02-references-and-borrowing.html)

2.[å®˜æ–¹æ–‡æ¡£ä¸­å…³äºç”Ÿå‘½å‘¨æœŸçš„ä»‹ç»](https://rustwiki.org/zh-CN/book/ch10-03-lifetime-syntax.html)

## 2.3 trait ä¸ trait object

### 2.3.1 trait 

åœ¨Rustç¼–ç¨‹è¯­è¨€ä¸­ï¼Œ`trait` æ˜¯ä¸€ç§å®šä¹‰åœ¨ç¼–è¯‘å™¨çº§åˆ«çš„æ¥å£æœºåˆ¶ï¼Œå¯ä»¥å®šä¹‰åœ¨æŸç§æ•°æ®ç±»å‹ä¸Šçš„è¡Œä¸ºã€‚ä¹Ÿå¯ä»¥å°† `trait` ç†è§£ä¸ºä¸€ç§ç±»å‹å±‚çº§çš„åè®®ï¼Œåè®®çº¦å®šäº†ç±»å‹å…±åŒçš„è¡Œä¸ºï¼Œå¹¶é€šè¿‡æ–¹æ³•æ¥æš´éœ²è¿™äº›åè®®æ¥å£

**traitçš„å£°æ˜åŠç§ç±»**

```
 // 1 trait ç§ç±»

    // 1.1 ç©ºtrait

    trait A {}

    // 1.2 æœ‰æ–¹æ³•çš„trait

    trait B {
        fn method(&self);
        fn method2(&self);

        // ...
    }

    // 1.3 æœ‰å…³è”ç±»å‹çš„trait

    trait C {
        type T;

        fn method1(&self) -> Self::T;
    }

    // 1.4 æœ‰é»˜è®¤å®ç°çš„trait

    trait D {
        // è¿™ä¸ªæ–¹æ³•æ˜¯é»˜è®¤å®ç°
        fn method1(&self) {
            println!("method1");
        }
        fn consume_method(&mut self);
    }

    // 1.5 æœ‰è‡ªç”±æ–¹æ³•ï¼ˆå‡½æ•°ï¼‰çš„trait

    trait E {
        // è¿™ä¸ªæ–¹æ³•æ˜¯é»˜è®¤å®ç°
        fn method1(&self) {
            println!("method1");
        }
        // è¿™ä¸ªæ–¹æ³•éœ€è¦æ‰‹åŠ¨å®ç°
        fn method2(&self);

        // è¿™ä¸ªæ–¹æ³•æ˜¯é»˜è®¤å®ç°
        fn method3() {
            println!("freedom method")
        }

        // è¿™ä¸ªæ–¹æ³•éœ€è¦æ‰‹åŠ¨å®ç°
        fn method4(a: &str) -> &str;
    }

    // 1.6 traitç»§æ‰¿

    trait F: E {
        // method
    }
```

**traitçš„å®ç°**

traitä¸€èˆ¬å’Œç±»å‹ç»“åˆä½¿ç”¨ï¼Œç‹¬ç«‹traitå¹¶æ²¡æœ‰å¤ªå¤§çš„æ„ä¹‰

```rust
    // 2 å¦‚ä½•å®ç° trait

    // 2.1 æ‰‹åŠ¨å®ç°

    struct Teacher;

    impl Teacher {
        fn method1() {
            print!("è¿™æ˜¯ç±»å‹çš„å…³è”æ–¹æ³•");
        }
    }

    Teacher::method1(); // å…³è”æ–¹æ³•è°ƒç”¨

    impl A for Teacher {}

    impl B for Teacher {
        fn method(&self) {
            print!("")
        }
        fn method2(&self) {
            print!("")
        }
    }

    let mut t = Teacher;
    t.method(); // æ–¹æ³•é€šè¿‡å®ä¾‹è°ƒç”¨
    t.method();

    impl C for Teacher {
        type T = Teacher;

        fn method1(&self) -> Self::T {
            let t = String::from("Teacher");

            // t
            Teacher
        }
    }

    impl D for Teacher {
        fn consume_method(&mut self) {
            // let x = self;
            // let y = self;
        }
    }

    t.consume_method();
    t.consume_method();

    impl E for Teacher {
        fn method2(&self) {}
        fn method4(a: &str) -> &str {
            "Rust"
        }
    }

    Teacher::method4("Go"); // å¯¹traitä¸­è‡ªç”±æ–¹æ³•çš„è°ƒç”¨åŒè°ƒç”¨ç±»å‹çš„å…³è”æ–¹æ³•

    struct Professor;

    // impl F for Professor {}

    impl F for Teacher {}

    // 2.2 ä½¿ç”¨å®å®ç°
    // æ ‡å‡†åº“å’Œç¬¬ä¸‰æ–¹åº“ä¸­ä¸€äº›traitå¯ä»¥é€šè¿‡æ´¾ç”Ÿå®æ¥å®ç°

    #[derive(Default, Clone)]
    struct Student {
        name: String,
        age: u32,
    }

    // è°ƒç”¨æ–¹æ³•

    // å¯ä»¥ç›´æ¥è°ƒç”¨traitæä¾›çš„æ–¹æ³•
    let s = Student::default();
    let s1 = s.clone();
```

æ ‡å‡†åº“ä¸­é¢„å¯¼å…¥äº†å¾ˆå¤š traitï¼Œå¯ä»¥ç›´æ¥åœ¨æ–‡ä»¶ä¸­ä½¿ç”¨è€Œä¸ç”¨` use`å¯¼å…¥ï¼Œä½ å¯ä»¥å¤§æ¦‚çœ‹ä¸€ä¸‹ä¸‹åˆ—è¡¨æ ¼ï¼Œæ¶ˆé™¤å¯¹ trait çš„é™Œç”Ÿæ„Ÿ

![image-20230302004216125](https://github.com/CreatorsDAO/rust-co-learn/blob/main/images/prelude_traits.png)

**æ‰©å±•èµ„æ–™**

1. [å®˜æ–¹æ–‡æ¡£ä¸­å…³äº trait çš„ä»‹ç»](https://rustwiki.org/zh-CN/book/ch10-01-syntax.html)

### 2.3.2 trait object 

traitæ—¢å¯ä»¥ä½œä¸ºå¦ä¸€ä¸ªtraitçš„çº¦æŸï¼Œä¹Ÿå¯ä»¥ä½œä¸ºæ³›å‹å‚æ•°çš„çº¦æŸï¼Œä½“ç°çš„æ˜¯å®ƒçš„çº¦æŸèƒ½åŠ›ã€‚trait object æä¾›äº†è¿è¡Œæ—¶åŠ¨æ€åˆ†å‘çš„èƒ½åŠ›

```rust
  // 1 æ³›å‹ä¸trait bound

    trait Animal {
        fn make_sound(&self) -> &'static str;
    }

    trait Food {}

    struct Dog;

    impl Animal for Dog {
        fn make_sound(&self) -> &'static str {
            "Woof!"
        }
    }

    struct Cat;

    impl Animal for Cat {
        fn make_sound(&self) -> &'static str {
            "Meow!"
        }
    }

    struct Pig;

    impl Animal for Pig {
        fn make_sound(&self) -> &'static str {
            "Woof!"
        }
    }

    impl Food for Pig {}

    // trait ä½œä¸ºçº¦æŸæ—¶æœ‰ä¸‰ç§å†™æ³•

    fn get_weight<T: Animal + Food>(x: T) {

        // do sth
    }

    fn get_weight1(x: impl Animal + Food) {

        // do sth
    }

    fn get_weight2<T>(x: T)
    where
        T: Animal + Food,
    {
        // do sth
    }

    let d = Dog;
    let c = Cat;
    let p = Pig;

    // get_weight(d);
    // get_weight(c);
    get_weight(p);

    // 2 trait object
    // trait å¯¹è±¡é€šè¿‡æŒ‡é’ˆæ¥åˆ›å»ºï¼Œå¦‚ & æˆ– Box<T>(ä¸€ç§æ™ºèƒ½æŒ‡é’ˆï¼Œå¯ä»¥æŠŠæ•°æ®å­˜æ”¾åˆ°å †ä¸Š)ï¼š&dyn Trait or Box<dyn Trait>
    // Boxæ˜¯Rustä¸­å”¯ä¸€å¯ä»¥æŠŠæ•°æ®å¼ºåˆ¶åˆ†é…åˆ°å †ä¸Šçš„ç±»å‹

    // é™æ€åˆ†å‘:åœ¨ç¼–è¯‘æœŸé€šè¿‡å…·ä½“ç±»å‹å®ä¾‹ç›´æ¥è°ƒç”¨æ–¹æ³•,ç¼–è¯‘æœŸå•æ€åŒ–

    fn animal_make_sound<T: Animal>(a: T) {
        a.make_sound();
    }
    animal_make_sound(d);
    animal_make_sound(c);

    // åŠ¨æ€åˆ†å‘ï¼šåœ¨è¿è¡Œæ—¶å…ˆåˆ¤æ–­ç±»å‹å†æŸ¥æ‰¾ç±»å‹å¯¹åº”æ–¹æ³•
    // ç‰¹åˆ«è¯´æ˜ï¼Œä½¿ç”¨ trait object ä¼šå¸¦æ¥è¿è¡Œæ—¶å¼€é”€

    fn animal_make_sound2(animals: Vec<&dyn Animal>) {
        for animal in animals {
            animal.make_sound();
        }
    }

    let d = Dog;
    let c = Cat;

    let animals: Vec<&dyn Animal> = vec![&d, &c];

    animal_make_sound2(animals);

    // 3 trait object å®‰å…¨
    // traitä¸­æ–¹æ³•è¿”å›å€¼ç±»å‹ä¸ä¸º Self
    // traitä¸­æ–¹æ³•æ²¡æœ‰ä»»ä½•æ³›å‹ç±»å‹å‚æ•°

    pub trait X {
        fn method(&self) -> Self;
    }

    pub trait Y {
        fn print<T: std::fmt::Display>(&self, t: T);
    }

    // fn use_trait_object(t: &dyn X) {}
    // fn use_trait_object2(t: &dyn Y) {}
```

### 2.3.3 trait å®šä¹‰å…±æœ‰è¡Œä¸º

trait é€šè¿‡æ–¹æ³•å¯ä»¥ä¸ºç±»å‹å®šä¹‰ä¸€äº›é€šç”¨çš„æ–¹æ³•ï¼Œä¸€ä¸ªæ˜¯ä¸ç”¨å†ç»™ç±»å‹ä¸“é—¨å®šä¹‰ï¼Œä»£ç æ›´åŠ ç®€åŒ–ï¼Œç¬¬äºŒä¸ªèƒ½å¤Ÿæ›´å¥½çš„è§„å®šç±»å‹è¡Œä¸ºã€‚

```
 pub struct Book {
        name: String,
        price: f64,
        inventory: u32,
        author: String,
    }

    pub struct Cosmetic {
        name: String,
        price: f64,
        inventory: u32,
    }

    pub trait Record {
        fn set_price(&mut self, price: f64);
        fn set_inventory(&mut self, inventory: u32);
    }

    impl Record for Book {
        fn set_price(&mut self, price: f64) {
            self.price = price;
        }

        fn set_inventory(&mut self, inventory: u32) {
            self.inventory = inventory;
        }
    }

    impl Record for Cosmetic {
        fn set_price(&mut self, price: f64) {
            self.price = price;
        }

        fn set_inventory(&mut self, inventory: u32) {
            self.inventory = inventory;
        }
    }

    let mut book = Book {
        name: String::from("Book A"),
        price: 29.99,
        inventory: 10,
        author: String::from("Author X"),
    };

    let mut cosmetic = Cosmetic {
        name: String::from("Lipstick"),
        price: 9.99,
        inventory: 50,
    };

    book.set_price(39.99);
    book.set_inventory(5);

    cosmetic.set_price(14.99);
    cosmetic.set_inventory(20);

    println!(
        "Book: {} - Price: {} - Inventory: {} - Author: {}",
        book.name, book.price, book.inventory, book.author
    );
    println!(
        "Cosmetic: {} - Price: {} - Inventory: {}",
        cosmetic.name, cosmetic.price, cosmetic.inventory
    );
```

### 2.3.4 trait ä¸æ‰€æœ‰æƒ

æˆ‘ä»¬å·²ç»æ·±å…¥çš„ä»‹ç»äº†æ‰€æœ‰æƒè§„åˆ™ï¼šå®ƒæ˜¯ Rust å®ç°å†…å­˜ç®¡ç†çš„æ€æ‰‹é”ä¹‹ä¸€ã€‚trait ä½œä¸º Rust ä¸­é“¾æ¥ç±»å‹å¤§å¦çš„é‡è¦ç¯èŠ‚ï¼Œå’Œç±»å‹çš„æ‰€æœ‰æƒä¹Ÿæœ‰å¾ˆå¤šé‡è¦çš„è”ç³»

```rust
    // 1 Copy trait å’Œ Clone trait

    // ä¹‹å‰æˆ‘ä»¬ä»‹ç»äº†æ‰€æœ‰çš„å›ºå®šå°ºå¯¸ç±»å‹ï¼Œå½“æŠŠä¸€ä¸ªå˜é‡èµ‹å€¼ç»™å¦ä¸€ä¸ªå˜é‡æ—¶ï¼Œä¼šå‘ç”Ÿå€¼çš„å¤åˆ¶

    // owner_one å’Œ owner_two ç°åœ¨å„è‡ªæ‹¥æœ‰ä¸€ä»½å€¼ï¼Œæ•°æ®å‘ç”Ÿäº†æ‹·è´
    let owner_one = 32;
    let owner_two = owner_one;

    // ä½†æ˜¯å¯¹äºä¸€äº›åŠ¨æ€å°ºå¯¸å¤§å°çš„ç±»å‹ï¼Œæ¯”å¦‚strå’Œ[T],æˆ‘ä»¬åœ¨ä½¿ç”¨å®ƒä»¬çš„æŒ‡é’ˆ Stringå’ŒVec<T>æ—¶ï¼Œä¸ä¼šå‘ç”Ÿå€¼çš„å¤åˆ¶ï¼Œè€Œæ˜¯ä¼šç§»äº¤æ‰€æœ‰æƒ

    let owner_one = String::from("hello");
    let owner_two = owner_one;

    // println!("{:?}", owner_one); // ä¸å¯é€šè¿‡owner_oneè®¿é—®æ•°æ®ï¼Œå› ä¸ºå®ƒå·²ç»ç§»äº¤äº†æ‰€æœ‰æƒ

    // ä»traitçš„è§’åº¦æ¥è®²ï¼Œå°±æ˜¯æ‰€æœ‰å›ºå®šå°ºå¯¸ç±»å‹éƒ½å®ç°äº† Copy å’Œ Clone traitï¼Œè€ŒåŠ¨æ€å°ºå¯¸ç±»å‹éƒ½æ²¡æœ‰å®ç° Copy traitï¼Œä½†å¤§å¤šéƒ½å®ç°äº†Clone trait
    // å¹¶ä¸”ç¼–è¯‘å™¨æŠ¥é”™ä¹Ÿä¼šå‘Šè¯‰ä½ ï¼Œå“ªäº›ç±»å‹æ²¡æœ‰å®ç° Copy trait

    // å¦‚æœä½ æƒ³åœ¨å †ä¸Šå¤åˆ¶æƒ³åƒä½¿ç”¨å›ºå®šå°ºå¯¸ç±»å‹é‚£æ ·ä¸€æ ·åœ¨å †ä¸Šå¤åˆ¶ä¸€ä»½æ•°æ®ï¼Œä½ å¯ä»¥æ˜¾å¼è°ƒç”¨Clone traitä¸­çš„ cloneæ–¹æ³•æ¥å®ç°è¿™ä¸€ç‚¹

    let v = vec![1, 2, 3, 4, 5];

    let v1 = v.clone();
    let v2 = v.clone();
    let v3 = v1.clone();

    // æ–°å˜é‡çš„åœ°å€å’ŒåŸå˜é‡çš„åœ°å€å„ä¸ç›¸åŒ

    println!("{:p}", v.as_ptr()); // 0x7fccb3705b30
    println!("{:p}", v1.as_ptr()); // 0x7fccb3705b50
    println!("{:p}", v2.as_ptr()); // 0x7fccb3705b70
    println!("{:p}", v3.as_ptr()); // 0x7fccb3705b90

    // 2 traitå®ç°ä¸æ‰€æœ‰æƒ
    // åœ¨è‡ªå®šä¹‰ traitä¸­çš„æ–¹æ³•æ—¶ï¼Œä½ å¯ä»¥æ ¹æ®éœ€è¦é€‰æ‹©è¦è·å–ç±»å‹çš„ä¸å¯å˜å¼•ç”¨ã€å¯å˜å¼•ç”¨æˆ–è€…æ‰€æœ‰æƒ

    trait A {
        // éœ€è¦æ‰‹åŠ¨å®ç°ï¼Œè·å–æ‰€æœ‰æƒ
        fn take_ownership(self);

        // é»˜è®¤å®ç°ï¼Œè·å–ä¸å¯å˜å¼•ç”¨
        fn take_ref(&self) {
            println!("è¿™ä¸ªæ–¹æ³•è·å–äº†ç±»å‹çš„ä¸å¯å˜å¼•ç”¨")
        }

        // é»˜è®¤å®ç°ï¼Œè·å–å¯å˜å¼•ç”¨
        fn take_mut(&mut self) {
            println!("è¿™ä¸ªæ–¹æ³•è·å–äº†ç±»å‹çš„å¯å˜å¼•ç”¨")
        }
    }

    struct X;

    impl A for X {
        fn take_ownership(self) {
            println!("è¿™ä¸ªæ–¹æ³•è·å–äº†ç±»å‹çš„æ‰€æœ‰æƒ")
        }

        // é»˜è®¤å®ç°ä¸ç”¨æ‰‹åŠ¨å®ç°
    }

    let x = X;

    x.take_ownership(); // è¿™ä¸ªæ–¹æ³•è·å–äº†ç±»å‹çš„æ‰€æœ‰æƒ
                        // x.take_ref();// ä¸èƒ½å†ä½¿ç”¨x,å› ä¸ºä¸Šè¿°æ–¹æ³•å·²ç»è·å–äº†æ‰€æœ‰æƒ

    let mut y = X;
    y.take_ref(); // è¿™ä¸ªæ–¹æ³•è·å–äº†ç±»å‹çš„ä¸å¯å˜å¼•ç”¨
    y.take_mut(); // è¿™ä¸ªæ–¹æ³•è·å–äº†ç±»å‹çš„å¯å˜å¼•ç”¨

    // ç‰¹åˆ«è¯´æ˜ï¼šæ‰€æœ‰æƒæœºåˆ¶å’Œtraitæœ¬è´¨ä¸Šæ˜¯Rustä¸­ä¸¤ä¸ªç‹¬ç«‹çš„æ¦‚å¿µï¼Œå³ä½¿æ²¡æœ‰traitï¼Œæ‰€æœ‰æƒæœºåˆ¶ä¹Ÿæ˜¯æˆç«‹çš„ï¼ˆè¿™ä¹Ÿæ˜¯æˆ‘ä»¬åœ¨ä»‹ç»æ‰€æœ‰æƒæœºåˆ¶æ—¶ä¸ºä»€ä¹ˆæ²¡æœ‰æåŠtraitï¼Œå› ä¸ºä¸éœ€è¦ï¼‰
    // ä½†traitç³»ç»Ÿè®©æ‰€æœ‰æƒæœºåˆ¶æ›´åŠ çš„æ˜¾å¼åŒ–äº†ï¼Œæ›´å¥½ç†è§£ï¼Œä¹Ÿæ›´å¥½ä½¿ç”¨
```

### 2.3.5 trait ä¸ç±»å‹è½¬æ¢

trait ä½œä¸ºç±»å‹ä¹‹é—´è½¬æ¢çš„æ¡¥æ¢æ—¶æ˜¯ç”¨çš„æœ€å¤šçš„åœºæ™¯ä¹‹ä¸€ã€‚è¿™äº›ç±»å‹æ—¢åŒ…æ‹¬è‡ªå®šä¹‰ç±»å‹ï¼Œä¹ŸåŒ…æ‹¬ Rust æ ‡å‡†åº“ä¸­çš„ç±»å‹

```rust
 // 1 ç±»å‹è½¬æ¢traitï¼šFromå’ŒInto
    // Into trait ä¼šè‡ªåŠ¨å®ç°

    // 1.1 From i32 to Number

    use std::convert::From;

    #[derive(Debug)]
    struct Number {
        value: i32,
    }

    // ä¸ºè‡ªå®šä¹‰ç±»å‹å®ç°From traitï¼Œæ³¨æ„è¿™é‡ŒTraitå¸¦äº†ä¸€ä¸ªç±»å‹å‚æ•°i32ï¼Œç‰¹æŒ‡å°†i32è½¬æ¢ä¸ºNumber

    impl From<i32> for Number {
        fn from(item: i32) -> Self {
            Number { value: item }
        }
    }

    // ä½¿ç”¨From traitä¸­çš„fromæ–¹æ³•å°†i32è½¬æ¢ä¸ºNumber
    let num = Number::from(30);
    println!("My number is {:?}", num);

    let n: Number = 32.into();

    // 1.2 From Number to i32

    // ä¸ºè‡ªå®šä¹‰ç±»å‹å®ç°Into traitï¼Œæ³¨æ„è¿™é‡ŒTraitå¸¦äº†ä¸€ä¸ªç±»å‹å‚æ•°Numberï¼Œç‰¹æŒ‡å°†Numberè½¬æ¢ä¸ºi32
    impl From<Number> for i32 {
        fn from(item: Number) -> Self {
            item.value
        }
    }

    let num = i32::from(32);
    let x = Number { value: 10 };

    // ä½¿ç”¨Into traitä¸­çš„intoæ–¹æ³•å°†Numberè½¬æ¢ä¸ºi32
    let num: i32 = x.into();
    println!("number is {:?}", num);

    // ä¸æ­¤ç›¸ä¼¼çš„traitè¿˜æœ‰ TryFrom å’Œ TryInto
    // åœ¨å®é™…ä¸­ï¼ŒTryFrom å’Œ TryInto ç”¨çš„æ¯”è¾ƒå¤šï¼Œå› ä¸ºå®ƒä»¬å¯ä»¥å¤„ç†é”™è¯¯ï¼Œä½†æ˜¯å®ç°é€»è¾‘å’Œ From å’Œ Into ä¸€æ ·

    // 2 AsRef å’Œ AsMut

    // é€šè¿‡AsMutè·å–å¯å˜å¼•ç”¨:æ³¨æ„è¿™é‡Œè·å–ç»“æ„ä½“æˆå‘˜çš„å¯å˜å¼•ç”¨
    impl AsMut<i32> for Number {
        fn as_mut(&mut self) -> &mut i32 {
            &mut self.value
        }
    }

    let mut num = Number { value: 30 };

    let ref_num = num.as_mut();

    // é€šè¿‡AsRefè·å–å˜é‡çš„ä¸å¯å˜å¼•ç”¨:æ³¨æ„è¿™é‡Œè·å–ç»“æ„ä½“æˆå‘˜çš„ä¸å¯å˜å¼•ç”¨
    impl AsRef<i32> for Number {
        fn as_ref(&self) -> &i32 {
            &self.value
        }
    }

    let num = Number { value: 40 };

    let ref_num: &i32 = num.as_ref();

    // ç‰¹åˆ«è¯´æ˜ï¼šä»¥ä¸Šä»£ç å±•ç¤ºå¹¶ä¸ä¸€å®šæ˜¯æœ€ä½³å®è·µï¼Œåªæ˜¯ä¸ºäº†ä»‹ç»çŸ¥è¯†ç‚¹è€Œå±•ç¤ºçš„å¯èƒ½æ€§
```

å¦‚ä¸‹æ˜¯ä¸åŒåœºæ™¯ä¸‹ç»å¸¸ä½¿ç”¨çš„ trait

![img](https://github.com/CreatorsDAO/rust-co-learn/blob/main/images/traits_fetures.png)

## 2.4 è¯¾åä¹ é¢˜

1.rust ä¸­ä¸åŒçš„ç±»å‹çš„å˜é‡ï¼Œæ‰€æœ‰æƒæ˜¯å¦‚ä½•ä½“ç°çš„ï¼Ÿ

2.ä½ å¯ä»¥ç¼–å†™ä¸€ä¸ªæ¶‰åŠç”Ÿå‘½å‘¨æœŸå‚æ•°çš„ä»£ç ç¤ºä¾‹å—ï¼Ÿ

3.Rust ä¸­çš„ trait æ€æ ·ç†è§£ï¼Œå®ƒæœ‰å“ªäº›åŠŸèƒ½ï¼Ÿ

# æ¨¡å—ä¸‰ï¼šRust è¿›é˜¶çŸ¥è¯†

## 3.1 trait è¿›é˜¶

trait åœ¨ Rust ä¸­æ¶µç›–çš„å†…å®¹éå¸¸å¤šï¼Œå®ƒä¸å…‰ä¸ºä¸€äº›å¸¸è§çš„ç±»å‹å®šä¹‰äº†å¤§é‡çš„æ–¹æ³•ï¼ŒåŒæ—¶è¿˜ä¸ºä¸€äº›æ¯”è¾ƒç‰¹æ®Šçš„ç±»å‹æä¾›äº†æ”¯æŒ

### 3.1.1 trait ä¸é—­åŒ…

```rust
// 1. å›é¡¾ä¸‰ç§ç±»å‹çš„é—­åŒ…
// å‰é¢æˆ‘ä»¬ä»‹ç»è¿‡ï¼Œé—­åŒ…æœ‰ä¸‰ç§ç±»å‹ï¼šæœªæ•è·ç¯å¢ƒå˜é‡ï¼Œæ•è·ç¯å¢ƒå˜é‡ä¸ä¿®æ”¹ï¼Œæ•è·ç¯å¢ƒå˜é‡å¹¶ä¿®æ”¹

// 1.1 æœªæ•è·ç¯å¢ƒå˜é‡
let c1 = || println!("didn't catch env var");
c1();

// 1.2 æ•è·ä½†ä¸ä¿®æ”¹ç¯å¢ƒå˜é‡
let x = 10;

let c2 = || println!("catch env var but not modify, x = {}", x);

c2();

// 1.3 æ•è·å¹¶ä¿®æ”¹ç¯å¢ƒå˜é‡

let mut x = 10;
let mut c3 = |a: i32| {
    x = 1 + a;
    println!("catch env var and modify, x = {}", x);
};
c3(10);

// 2. é—­åŒ…å®ç°ä¸trait

// åœ¨Rustä¸­ï¼Œé—­åŒ…å®é™…ä¸Šæ˜¯ä¸€ä¸ªè¯­æ³•ç³–ï¼Œå®ƒçš„å®ç°åœ¨æŠ½è±¡æ¦‚å¿µä¸Šå¯ä»¥çœ‹åšæ˜¯ä¸€ä¸ªåŒ¿åç»“æ„ä½“ï¼Œè¿™ä¸ªç»“æ„ä½“ä¼šæŠŠç¯å¢ƒå˜é‡æ•è·æˆä¸ºå…¶æˆå‘˜ï¼Œå¹¶å®ç°Fn/FnMut/FnOnce trait
// Fn/FnMut/FnOnceä¸­å„æœ‰ä¸€ä¸ªæ–¹æ³•åˆ†åˆ«æ˜¯call/call_mut/call_onceï¼Œå¯¹åº”çš„è¯­ä¹‰åˆ†åˆ«æ˜¯è°ƒç”¨ä¸å¯å˜é—­åŒ…ã€è°ƒç”¨å¯å˜é—­åŒ…ã€è°ƒç”¨æ¶ˆè´¹é—­åŒ…
// å¹¶ä¸”Fn/FnMut/FnOnce traitæ˜¯ä»¥æ¬¡ç»§æ‰¿çš„ï¼Œä¹Ÿå°±æ˜¯è¯´å®ç° Fn trait,å¿…é¡»å®ç° FnMut traitï¼Œå®ç° FnMut trait,å¿…é¡»å®ç° FnOnce trait

// å½“å£°æ˜ä¸€ä¸ªé—­åŒ…æ—¶ï¼Œç¼–è¯‘å™¨ä¼šæ ¹æ®é—­åŒ…çš„ç±»å‹ï¼Œè‡ªåŠ¨æ¨å¯¼å‡ºå…¶å®ç°çš„traitï¼Œä¸€èˆ¬æƒ…å†µä¸‹ä¸éœ€è¦æ‰‹åŠ¨å®ç°

// 3. é—­åŒ…ä½œä¸ºå‡½æ•°å‚æ•°ä¼ é€’
// å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œåœ¨å°†é—­åŒ…ä½œä¸ºå‚æ•°åœ¨å‡½æ•°ä¸­ä¼ é€’æ—¶ï¼Œç±»å‹çš„æŒ‡å®šæ˜¯é€šè¿‡traitæ¥å®ç°çš„

fn call_fn<F: Fn()>(f: F) {
    f();
}

fn call_fn_mut<F: FnMut()>(mut f: F) {
    f();
}

fn call_fn_once<F: FnOnce()>(f: F) {
    f();
}

// é—­åŒ…çš„è°ƒç”¨ case 1
// Rustç¼–è¯‘å™¨ä¼šæ ¹æ®ä½ å¦‚ä½•è°ƒç”¨æ¨å¯¼å‡ºé—­åŒ…çš„ç±»å‹ï¼Œä¹Ÿå°±æ˜¯å®ç°å“ªä¸ªtrait

let c = || println!("closure");

call_fn_once(c); // å®ç°äº†FnOnce trait
call_fn(c); // å®ç°äº†Fn traitï¼ŒFnMut trait,FnOnce trait,åé¢ä¸¤ç§traitéƒ½æ˜¯é€šè¿‡ç»§æ‰¿å®ç°çš„
call_fn_mut(c); // å®ç°äº†FnMut trait,FnOnce trait

// é—­åŒ…çš„è°ƒç”¨ case 2

let x = "10";

let c = || println!("get env var {}", x);

call_fn_once(c); // å®ç°äº†FnOnce trait
call_fn(c); // å®ç°äº†Fn traitï¼ŒFnMut trait,FnOnce trait,åé¢ä¸¤ç§traitéƒ½æ˜¯é€šè¿‡ç»§æ‰¿å®ç°çš„
call_fn_mut(c); // å®ç°äº†FnMut trait,FnOnce trait

// é—­åŒ…çš„è°ƒç”¨ case 3

let mut x = String::from("10");

let mut c = || println!("get env var {x:?}", x = String::from("20"));

call_fn_once(c); // å®ç°äº†FnOnce trait
call_fn(c); // å®ç°äº†Fn traitï¼ŒFnMut trait,FnOnce trait,åé¢ä¸¤ç§traitéƒ½æ˜¯é€šè¿‡ç»§æ‰¿å®ç°çš„
call_fn_mut(c); // å®ç°äº†FnMut trait,FnOnce trait

// 4. é—­åŒ…ä½œä¸ºå‡½æ•°è¿”å›

fn return_fn() -> impl Fn() {
    || println!("call_fn")
}

fn return_i32(i: i32) -> i32 {
    32
}

fn return_fn_mut() -> impl FnMut() {
    let x = 10;
    // || println!("call_fn_mut {}", x + 1) // ä¸èƒ½è¿”å›å±€éƒ¨å˜é‡
    move || println!("call_fn_mut {}", x + 1) // å¿…é¡»æŠŠå±€éƒ¨å˜é‡ç§»å…¥é—­åŒ…ï¼Œæ‰èƒ½è¿”å›ï¼ˆè¿™é‡Œå®é™…ä¸Šå‘ç”Ÿäº†æ•°æ®çš„å¤åˆ¶ï¼‰
}

fn return_fn_once() -> impl FnOnce() {
    let s = String::from("hello");
    // || println!("call_fn_once {:?}", s)
    move || println!("call_fn_once {:?}", s) // å¿…é¡»æŠŠå±€éƒ¨å˜é‡ç§»å…¥é—­åŒ…ï¼Œæ‰èƒ½è¿”å›ï¼ˆè¿™é‡Œå®é™…ä¸Šå‘ç”Ÿäº†æ‰€æœ‰æƒè½¬ç§»ï¼‰
}
```

**æ‰©å±•èµ„æ–™**

1.[å®˜æ–¹æ–‡æ¡£ä¸­å…³äºé—­åŒ…çš„ä»‹ç»](https://rustwiki.org/zh-CN/book/ch13-01-closures.html)

### 3.1.2 trait ä¸è¿­ä»£å™¨

Rust æä¾›äº†è¿­ä»£å™¨ trait,å¯ä»¥å®ç°éå†åŠŸèƒ½

```rust
    // 1. for å¾ªç¯ä¸è¿­ä»£å™¨

    // åœ¨rustä¸­ï¼Œforå¾ªç¯å®é™…ä¸Šçš„è¿­ä»£å™¨çš„è¯­æ³•ç³–

    // for å¾ªç¯ä»¥åŠè§£ç³–
    let values = vec![1, 2, 3, 4, 5];
    // ä½¿ç”¨ for å¾ªç¯éå†é›†åˆä¸­ä¸ªæ¯ä¸ªå…ƒç´ 
    for x in values {
        println!("{x}");
    }
    // for å¾ªç¯è§£ç³–åç­‰ä»·å¦‚ä¸‹ï¼š
    let v = vec![1, 2, 3, 4, 5];
    // å…ˆå°†é›†åˆè½¬ä¸ºè¿­ä»£å™¨ç±»å‹
    let mut v_iter = v.into_iter();
    // åœ¨ loop å¾ªç¯ä¸­ä½¿ç”¨nextæ–¹æ³•å¾ªç¯è·å–é›†åˆä¸­ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œå½“é›†åˆä¸­å–ä¸åˆ°å€¼æ—¶ä½¿ç”¨breakç»ˆæ­¢ loopå¾ªç¯
    loop {
        match v_iter.next() {
            Some(x) => println!("{}", x),
            None => break,
        }
    }

    // 2. è¿­ä»£å™¨ trait IntoIterator å’Œ Iterator
    // IntoIterator trait ä¸­çš„ into_iteræ–¹æ³•ä¼šè¿”å›ä¸€ä¸ª å®ç°äº† Iterator trait è¿­ä»£å™¨
    // Iterator trait é€šè¿‡å…¶ nextæ–¹æ³•æ¥è·å–é›†åˆä¸­çš„ä¸‹ä¸€ä¸ªå…ƒç´ 

    use std::collections::HashMap;
    use std::slice::Iter;
    use std::slice::IterMut;
    use std::vec::IntoIter;


    // å¦‚æœç±»å‹å®ç°äº†è¿­ä»£å™¨ traitï¼Œåˆ™å¯ä»¥ä½¿ç”¨è¿­ä»£å™¨ä¸­çš„æ–¹æ³•ï¼Œä¾‹å¦‚ï¼š

    let map = HashMap::from([("rust", 1), ("go", 2), ("python", 3)]);
    let map_iter = map.into_iter();
    let vec: Vec<(&str, i32)> = map_iter.collect();
    println!("{:?}", vec); // [("rust", 1), ("go", 2), ("python", 3)]

    // 3. è¿­ä»£å™¨ã€å€Ÿç”¨å’Œæ‰€æœ‰æƒ
    let mut v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9];
    let iter_mut: IterMut<i32> = v.iter_mut(); // è½¬ä¸º  IterMut ç»“æ„ä½“, å¯å˜å€Ÿç”¨
    let iter: Iter<i32> = v.iter(); // è½¬ä¸º Iter ç»“æ„ä½“ï¼Œ ä¸å¯å˜å€Ÿç”¨
    let iter_into: IntoIter<i32> = v.into_iter(); // è½¬ä¸º IntoIter ç»“æ„ä½“ ï¼Œ è·å–æ‰€æœ‰æƒ

    // 4. è¿­ä»£å™¨é€‚é…å™¨
    let vec = vec![1, 2, 3, 4, 5];
    let doubled: Vec<i32> = vec
        .iter()
        .map(|&x| x * 3)
        .take(3)
        .filter(|x| *x > 6)
        .collect();
    println!("{:?}", doubled); // [9]

    // 5 è¿­ä»£å™¨ä¸è¿­ä»£å™¨é€‚é…å™¨ç‰¹æ€§ï¼šlazyï¼ˆæƒ°æ€§ï¼‰
    let v = vec![1, 2, 3, 4, 5];
    v.iter().for_each(|x| println!("{x}"));
    // or
    for x in &v {
        println!("{x}");
    }
```

**æ‰©å±•èµ„æ–™**

1.[å®˜æ–¹æ–‡æ¡£ä¸­å…³äºè¿­ä»£å™¨çš„ä»‹ç»](https://rustwiki.org/zh-CN/book/ch13-02-iterators.html)

### 3.1.3 trait ä¸æ™ºèƒ½æŒ‡é’ˆ

```rust
    // åœ¨å±•å¼€Rustçš„æ™ºèƒ½æŒ‡é’ˆä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆåŒºåˆ†ä¸€ä¸‹Rustä¸­çš„æ™ºèƒ½æŒ‡é’ˆã€å¼•ç”¨å’Œè£¸æŒ‡é’ˆ

    // 1 æŒ‡é’ˆã€å¼•ç”¨å’Œæ™ºèƒ½æŒ‡é’ˆ

    // 1.1 å¼•ç”¨

    let x = 100;
    let mut y: i64 = 200;
    #[derive(Debug)]
    struct A(i32);
    let a = A(100);

    // ä½¿ç”¨ & è·å–ä¸å˜æˆ–è€…å¯å˜å¼•ç”¨
    let x_pointer = &x;
    let y_pointer = &mut y;
    let a_pointer = &a;

    println!("{:?}", x_pointer); // 100 æ‰“å°æ—¶ä¼šè‡ªåŠ¨â€œè§£å¼•ç”¨â€åˆ°æ•°æ®ï¼Œè€Œä¸æ˜¯åœ°å€
    println!("{:p}", x_pointer); // 0x7ff7b9bae33c å¦‚æœè¦æ‰“å°åœ°å€çš„è¯ï¼Œæ”¹å˜å ä½ç¬¦ï¼Ÿä¸º p

    // let z = &mut y; // å¯å˜å€Ÿç”¨ä¸èƒ½è¶…è¿‡1æ¬¡

    y = *y_pointer + 100; // è§£å¼•ç”¨åä¿®æ”¹

    println!("{:?}", y); //300 æœ¬æ¡ä»£ç ç»“æŸåï¼Œå¯å˜å€Ÿç”¨æ‰é‡Šæ”¾
    println!("{:?}", a_pointer); // A(100)

    // 1.2 è£¸æŒ‡é’ˆ
    let x = 100;
    let mut y: i64 = 200;
    struct B(i32);
    let a = B(100);

    // è£¸æŒ‡é’ˆæ˜¯ä½¿ç”¨ as *const ä»å¼•ç”¨è½¬æ¢è€Œæ¥
    let x_raw_pointer = &x as *const i32;
    let y_raw_pointer = &mut y as *const i64;
    let a_raw_pointer = &a as *const B;

    println!("{:?}", x_raw_pointer); // 0x7ff7b763a46cï¼Œè£¸æŒ‡é’ˆæ‰“å°æ—¶ä¸ä¼šè¢«â€œè§£å¼•ç”¨â€åˆ°æ•°æ®ï¼Œè€Œæ˜¯ä¼šç›´æ¥ä¼šæ‰“å°åœ°å€

    unsafe {
        y = *y_raw_pointer + 300; // è£¸æŒ‡é’ˆè§£å¼•ç”¨éœ€è¦ä½¿ç”¨unsafe è¯­æ³•å—ï¼Œè¿™é‡Œçš„è§£å¼•ç”¨çš„å®‰å…¨çš„

        let z_raw_pointer = &mut y as *const i64; // ç¬¬äºŒæ¬¡ç”Ÿæˆå¯å˜è£¸æŒ‡é’ˆï¼Œunsafe å—ç»•è¿‡äº†å¯å˜å€Ÿç”¨çš„æ¬¡æ•°è§„åˆ™ï¼Œæ˜¯ä¸æ˜¯æ„Ÿè§‰æœ‰ç‚¹å±é™©ï¼Ÿ

        y = *z_raw_pointer + 500; // ç„¶åç»§ç»­æ”¹å˜æ•°æ®

        println!("{:?}", *y_raw_pointer); // 1000
    }
    println!("{:?}", a_raw_pointer); // 0x7ff7b763a47c
    println!("{:?}", y); // 1000

    // 1.3 æ™ºèƒ½æŒ‡é’ˆ

    // Vec å’Œ String ç±»å‹éƒ½æ˜¯æ™ºèƒ½æŒ‡é’ˆ

    let vec = vec![1, 2, 3, 4];
    let s = "rust".to_string();
    let num = Box::new(100);

    let v1 = vec; // å‘ç”Ÿäº†moveè¯­ä¹‰ï¼Œç°åœ¨æ•°æ®çš„æ‰€æœ‰è€…ä¸å†æ˜¯vec è€Œæ˜¯v1ï¼Œæ•°æ®æ²¡å˜ï¼Œæ‹¥æœ‰è€…å˜äº†

    // println!("{:?}", vec); // ä¸èƒ½å†ä½¿ç”¨ vecï¼Œå› ä¸ºå®ƒä¸å†æ‹¥æœ‰æ•°æ®äº†

    let v = [1, 2, 3, 4];
    let v = &v1; // åªæ˜¯å€Ÿç”¨ï¼Œv ä»ç„¶æ‹¥æœ‰æ•°æ®
    println!("{:?}", v); // æ‰€ä»¥å¯ä»¥ä½¿ç”¨ v

    // 2 æ™ºèƒ½æŒ‡é’ˆä¸ç»“æ„ä½“ã€trait
    // Rustä¸­çš„æ™ºèƒ½æŒ‡é’ˆéƒ½æ˜¯ä»¥ç»“æ„ä½“è¿›è¡Œå°è£…ï¼Œç„¶åä¸ºå®ƒå®ç°äº†æŸäº›trait
    // äº‹å®ä¸Šï¼ŒRustä¸­å¾ˆå¤šç‰¹æ®Šçš„ç±»å‹éƒ½æ˜¯åŸºäºç»“æ„ä½“æ¥å®ç°çš„ï¼Œå¹¶ä¸”åœ¨è¿™äº›ç»“æ„ä½“ä¸Šå®ç°äº†å„ç§traitï¼Œè¿™æ˜¯ä¸€ç§é€šç”¨çš„ç±»å‹æ„é€ æ€è·¯

    // æ ‡å‡†åº“ä¸­çš„ä¸€äº›æ™ºèƒ½æŒ‡é’ˆçš„å®šä¹‰
    /*
    pub struct Box<T, A = Global>(_, _)
    where
        A: Allocator,
        T: ?Sized;

    pub struct String {
        vec: Vec<u8>,
    }

    pub struct Vec<T, A: Allocator = Global> {
        buf: RawVec<T, A>,
        len: usize,
    }

    pub struct Rc<T: ?Sized> {
        ptr: NonNull<RcBox<T>>,
        phantom: PhantomData<RcBox<T>>,
    }
    */

    // é‚£ä»€ä¹ˆæ˜¯æ™ºèƒ½æŒ‡é’ˆï¼Ÿæ™ºèƒ½æŒ‡é’ˆæ˜¯å®ç°äº†Deref trait æˆ– Drop trait çš„ç»“æ„ä½“ç±»å‹
    // Derefå…è®¸è‡ªåŠ¨è§£å¼•ç”¨ï¼ŒDropå…è®¸è‡ªåŠ¨é‡Šæ”¾èµ„æº

    // 2. è‡ªå®šä¹‰æ™ºèƒ½æŒ‡é’ˆ

    // 2.1 å®ç° Drop trait

    #[derive(Debug)]
    struct User {
        name: String,
        age: u32,
    }

    impl Drop for User {
        fn drop(&mut self) {
            println!("User has been dropped {:?}:", "rust") // å®ç°ç»†èŠ‚åªæ˜¯åšäº†æ‰“å°
        }
    }

    // 2.2 å®ç° Deref trait
    use std::ops::Deref;

    #[derive(Debug)]
    struct MyBox<T>(T);

    impl<T> Deref for MyBox<T> {
        type Target = T;
        fn deref(&self) -> &T {
            &self.0
        }
    }

    // 2.3 Drop trait å¦‚ä½•èµ·ä½œç”¨çš„ï¼Ÿ
    // å½“ä¸€ä¸ªå€¼ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå®ƒçš„dropæ–¹æ³•ä¼šè¢«è‡ªåŠ¨è¢«ç¼–è¯‘å™¨è°ƒç”¨ï¼Œæ— éœ€æ‰‹åŠ¨è°ƒç”¨ï¼Œå¼ºè¡Œæ‰‹åŠ¨è°ƒç”¨ç¼–è¯‘å™¨ä¼šæŠ¥é”™

    {
        let mut user = User {
            name: "rust".to_string(),
            age: 12,
        };

        // user.drop(); //æ‰‹åŠ¨è°ƒç”¨ä¸è¡Œ å› ä¸ºç¼–è¯‘å™¨ä¼šè‡ªåŠ¨è°ƒç”¨ï¼Œæ˜¾å¼è°ƒç”¨äºŒè€…ä¼šå†²çª

        // ä½ ä¼šåœ¨ç»ˆç«¯å‘ç°æ‰“å°äº† â€œRustâ€ï¼ŒæˆåŠŸéªŒè¯ï¼Œç¼–è¯‘å™¨ç¡®å®è°ƒç”¨äº† drop
    }

    // 2.4 Deref trait å¦‚ä½•èµ·ä½œç”¨çš„ï¼Ÿ

    {
        let m = MyBox("rust");
        let ref_my_box = *m; // å®ç°äº† Deref traitçš„æ™ºèƒ½æŒ‡é’ˆå¯ä»¥ä½¿ç”¨ * ç›´æ¥è§£å¼•ç”¨åˆ°å†…éƒ¨çš„å€¼
                           // ç­‰ä»·äºä¸‹é¢ï¼šderefå‡½æ•°ä¼šè‡ªåŠ¨è°ƒç”¨
        let ref_my_box = *(m.deref());

        // Stringæ˜¯æ™ºèƒ½æŒ‡é’ˆï¼Œå®ƒå®ç°äº†Deref traitï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥è§£å¼•ç”¨

        fn take_ref_string(s: &str) {
            println!("{:?}", s)
        }

        // å°†Stringè§£å¼•ç”¨ä¸ºstr
        // æ³¨æ„ï¼šStringè¿™ä¸ªæ™ºèƒ½æŒ‡é’ˆåŒ…è£¹çš„ç±»å‹æ˜¯ strï¼Œè§£å¼•ç”¨åå¤§å°ç¼–è¯‘å™¨æ— æ³•ç¡®å®šï¼Œæ‰€ä»¥è¦å†åŠ &ï¼ˆå¼•ç”¨ï¼‰
        let s = String::from("Rust");
        // take_ref_string(s);
        take_ref_string(&s);
    }
```

Rust ä¸­æœ‰å¤šä¸ªæ™ºèƒ½æŒ‡é’ˆï¼Œå¯ä»¥å‚è€ƒä¸‹è¡¨ï¼Œè¿™é‡Œæ€»ç»“äº†ä¸€ä¸ªè¡¨ï¼Œæ–¹ä¾¿ä½ é˜…è¯»

![image-20230203001747611](https://github.com/CreatorsDAO/rust-co-learn/blob/main/images/smart_pointers.png)

**æ‰©å±•èµ„æ–™**

1.[å®˜æ–¹æ–‡æ¡£ä¸­å…³äºæ™ºèƒ½æŒ‡é’ˆçš„ä»‹ç»](https://rustwiki.org/zh-CN/book/ch15-00-smart-pointers.html)

## 3.2 ç±»å‹è¿›é˜¶

Rust ä¸­å¯¹äºæä¾›äº†å¾ˆå¤šç±»å‹ï¼Œç”¨äºå¤„ç†ä¸€äº›ç‰¹æ®Šçš„åœºæ™¯

### 3.2.1 Box <T>

Box å¯ä»¥å°†å†…å­˜å¼ºåˆ¶åˆ†é…åˆ°å †ä¸Šï¼Œå¹¶ä¸”å®ƒä¹Ÿæ˜¯æ™ºèƒ½æŒ‡é’ˆï¼Œå¯ä»¥è‡ªåŠ¨è§£å¼•ç”¨å’Œç®¡ç†å †å†…å­˜ã€‚æ‰€ä»¥åœ¨ä½¿ç”¨çš„æ—¶å€™åªéœ€è¦ä½¿ç”¨å®ƒå°†æ•°æ®åˆ†é…åˆ°å †ä¸Šï¼Œå¹¶ä¸éœ€è¦å†è€ƒè™‘å¦‚ä½•é‡Šæ”¾å†…å­˜

```
// 1 Box<T> ä¸æ•°æ®åˆ†é…

    // åœ¨Rustä¸­ï¼Œä½ å¯ä»¥ä½¿ç”¨Boxå°†æ•°æ®å¼ºè¡Œå­˜å‚¨åˆ°å †ä¸Š

    let a = Box::new("rust");
    let b = Box::new(42);

    // å®ƒä¹Ÿæ˜¯å”¯ä¸€å¯ä»¥å°†æ•°æ®æ”¾åˆ°å †ä¸Šçš„é€”å¾„

    // 2 Box<T> æ˜¯ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆ
    // å®ƒå®ç°äº†Derefå’ŒDrop trait

    let s = Box::new("rust");
    let s = *s; // è§£å¼•ç”¨

    // ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œä¼šè‡ªåŠ¨è°ƒç”¨dropæ–¹æ³•ï¼Œé‡Šæ”¾å †ä¸Šçš„æ•°æ®

    // è¿™ä¸ªç±»å‹æ¯”è¾ƒç®€å•ï¼Œå†æ¬¡éœ€è¦å¼ºè°ƒçš„æ˜¯å®ƒæ˜¯ä¼—å¤šçš„RuståŸºäºç»“æ„ä½“æ„å’Œtraité€ çš„ç‰¹æ®Šç±»å‹ä¹‹ä¸€

    // 3 ä¸ºä»€ä¹ˆè¦æŠŠæ•°æ®å­˜æ”¾åœ¨å †ä¸Šï¼Ÿä¸€ä¸ªé“¾è¡¨ä¾‹å­

    // å®šä¹‰é“¾è¡¨èŠ‚ç‚¹æ•°æ®ç»“æ„
    enum ListNode<T> {
        Cons(T, Box<ListNode<T>>),
        Nil,
    }
    // å£°æ˜ä¸‰ä¸ªèŠ‚ç‚¹
    let node3 = ListNode::Cons(3, Box::new(ListNode::Nil));
    let node2 = ListNode::Cons(2, Box::new(node3));
    let list = ListNode::Cons(1, Box::new(node2));

    // let list: ListNode<i32> = Cons(1, Box::new(Cons(2, Box::new(Cons(3, Box::new(Nil))))));

    // ä½¿ç”¨æ¨¡å¼åŒ¹é…è§£æ„èŠ‚ç‚¹å€¼
    match list {
        ListNode::Cons(head, tail) => {
            println!("head: {}", head);
            match *tail {
                ListNode::Cons(head, _) => println!("second item: {}", head),
                ListNode::Nil => println!("there is no second item"),
            }
        }
        ListNode::Nil => println!("list is empty"),
    }
```

### 3.2.2 å¯å˜å®¹å™¨

åœ¨ç¼–è¯‘æœŸï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨ mut æ˜¾å¼å£°æ˜å˜é‡çš„å¯å˜æ€§ã€‚åœ¨è¿è¡Œæ—¶ï¼ŒRust æä¾›äº†å¯å˜å®¹å™¨ Cell å’Œ RefCell å…è®¸ä¿®æ”¹ä¸å¯å˜å˜é‡ï¼ˆè¿™ä¸ªè¿‡ç¨‹å®é™…ä¸Šæ˜¯é€šè¿‡åŸç”ŸæŒ‡é’ˆæ¥å®Œæˆçš„ï¼‰

```rust
// 1.ç¼–è¯‘æœŸï¼šé€šè¿‡ mut æ˜¾å¼å£°æ˜å˜é‡çš„å¯å˜æ€§ï¼Œä¹Ÿå«å¤–éƒ¨å¯å˜æ€§
    use std::cell::Cell;
    let can_not_change = "rust";
    let mut can_change = "go";
    // can_not_change = "cpp"; // ä¸å¯é‡æ–°èµ‹å€¼
    can_change = "c"; // å¯ä»¥æ›´æ”¹

    // 2 ä¸€ä¸ªéœ€è¦æ”¹å˜ä¸å¯å˜å˜é‡çš„ä¾‹å­

    // let var1 = 0;
    // let mut var2 = 0;

    // while var2 <= 10 {
    //     if var2 == 10 {
    //         var1 = 10;
    //     }
    //     var2 += 1;
    // }

    // println!("var1: {}, var2: {}", var1, var2);

    // 3. è¿è¡ŒæœŸï¼šé€šè¿‡Cellå’ŒRefCellå®ç°å¯å˜æ€§ï¼Œä¹Ÿå«å†…éƒ¨å¯å˜æ€§
    // 3.1 Cell<T> çš„ä¿®æ”¹å’Œè¯»å–
    struct Foo {
        x: u32,
        y: Cell<u32>,
        z: Cell<Vec<String>>,
    }

    let foo = Foo {
        x: 1,
        y: Cell::new(3),
        z: Cell::new(Vec::new()),
    };

    // ä¿®æ”¹å®¹å™¨å†…çš„å˜é‡ä½¿ç”¨setæ–¹æ³•
    foo.y.set(100);
    foo.z.set(vec!["rust".to_owned()]);

    // è¯»å–å®¹å™¨å†…çš„å˜é‡æœ‰ä¸¤ç§ï¼šå›ºå®šå¤§å°ç±»å‹å¯ä»¥ä½¿ç”¨ getå’Œinto_inner; åŠ¨æ€å¤§å°ç±»å‹åªèƒ½ä½¿ç”¨into_inner
    assert_eq!(100, foo.y.get());
    assert_eq!(100, foo.y.into_inner());

    // assert_eq!(vec!["rust".to_owned()], foo.z.get()); ä¸èƒ½ä½¿ç”¨getæ–¹æ³•
    assert_eq!(vec!["rust".to_owned()], foo.z.into_inner());

    // 3.2 RefCell<T> çš„ä¿®æ”¹å’Œè¯»å–
    // é€šè¿‡borrow_mutå®ç°å¯å˜æ€§
    // ä¸»è¦æ˜¯åº”ç”¨äºä¸€äº›åŠ¨æ€å¤§å°ç±»å‹ï¼Œé€šè¿‡borrowè·å–å€¼ï¼Œæœ‰è¿è¡Œæ—¶å¼€é”€

    use std::cell::RefCell;
    let vec = vec![1, 2, 3, 4];

    let ref_vec = RefCell::new(vec);

    println!("{:?}", ref_vec.borrow()); // ä¸å¯å˜å€Ÿç”¨ ä½¿ç”¨borrow
    ref_vec.borrow_mut().push(5); // å¯å˜å€Ÿç”¨æ”¹å˜ï¼Œä½¿ç”¨borrow_mut
    println!("{:?}", ref_vec.borrow());
```

### 3.2.3 å…±äº«å®¹å™¨

å…±äº«å®¹å™¨ Rc<T>å’Œ Arc<T>ä¹‹å‰åœ¨æ‰€æœ‰æƒå…±äº«ä¸­ä»‹ç»è¿‡ã€‚é€šè¿‡å…±äº«å®¹å™¨æˆ‘ä»¬å¯ä»¥ä½¿å¤šä¸ªå˜é‡æ‹¥æœ‰æ‰€æœ‰æƒï¼ˆæœ¬è´¨ä¸Šæ˜¯é€šè¿‡å¼•ç”¨è®¡æ•°å®ç°çš„ï¼‰ï¼Œä»è€Œå¯¹èµ„æºè¿›è¡Œæ“ä½œã€‚å…·ä½“ç¤ºä¾‹ç»†èŠ‚ä½ å¯ä»¥å‚è€ƒä¹‹å‰çš„ä»£ç 

### 3.2.4 ç‰¹æ®Šç±»å‹

**`PhantomData<T>`** ï¼Œå®ƒé€šå¸¸ç”¨äºåœ¨æ³›å‹ä»£ç ä¸­æ ‡è®°ä¸€äº›ç±»å‹å‚æ•°ï¼Œä½†ä¸å®é™…ä½¿ç”¨å®ƒä»¬ï¼Œä»è€Œå‘ Rust ç¼–è¯‘å™¨ä¼ è¾¾æœ‰å…³ä»£ç ä¸­ç±»å‹å…³ç³»çš„ä¿¡æ¯ã€‚å®ƒè¢«ç§°ä¸º â€œå¹½çµæ•°æ®â€ï¼Œå› ä¸ºå®ƒä¸å ç”¨ä»»ä½•å®é™…å†…å­˜ç©ºé—´ï¼Œåªåœ¨ç¼–è¯‘æ—¶èµ·ä½œç”¨

ä¸€èˆ¬å®ƒèµ·ä¸¤ä¸ªä½œç”¨ï¼š

1 ç”¨äºåœ¨ç±»å‹ç­¾åä¸­ä¼ é€’ç±»å‹ä¿¡æ¯ï¼Œè¡¨ç¤ºä¸€ç§å‡è±¡â€œæ‹¥æœ‰å…³ç³»â€

2 ä½œä¸ºä¸€ä¸ªç±»å‹å‚æ•°çš„æ ‡è®°ï¼Œç”¨äºå‘Šè¯‰ Rust ç¼–è¯‘å™¨æŸäº›é‡è¦ä¿¡æ¯ï¼Œä¾‹å¦‚ï¼Œå½“éœ€è¦å®ç° `Drop` trait æ—¶ï¼Œä½†æ˜¯ç±»å‹ä¸å®é™…åŒ…å«ä»»ä½•éœ€è¦é‡Šæ”¾çš„èµ„æºï¼Œå¯ä»¥ä½¿ç”¨ `PhantomData` æ¥å æ®ä¸€ä¸ªè™šæ‹Ÿçš„ä½ç½®ï¼Œè¿™æ ·ä»¥ç¡®ä¿ç¼–è¯‘å™¨ä¸ä¼šä¼˜åŒ–æ‰çš„ `Drop` å®ç°

```rust
    use std::marker::PhantomData;
    use std::ops::Deref;

    struct MyType<T> {
        data: *const T,
        _marker: PhantomData<T>,
    }

    impl<T> MyType<T> {
        fn new(t: T) -> MyType<T> {
            MyType {
                data: &t,
                _marker: PhantomData,
            }
        }
    }

    impl<T> Deref for MyType<T> {
        type Target = T;

        fn deref(&self) -> &Self::Target {
            unsafe { &*self.data }
        }
    }

    impl<T> Drop for MyType<T> {
        fn drop(&mut self) {
            println!("Dropping MyType instance!");
        }
    }

    let resource: MyType<bool> = MyType::new(true);
    let another_resource: MyType<i32> = MyType::new(32);

    print!("{:?}", unsafe { *(resource.data) });
    print!("   {:?}", unsafe { *(another_resource.data) });

    let my_instance: MyType<i32> = MyType::new(33);
    // æ‰§è¡Œåˆ°è¿™é‡Œæ—¶ï¼Œmy_instance å°†ä¼šç¦»å¼€ä½œç”¨åŸŸå¹¶è¢«é”€æ¯ï¼Œè°ƒç”¨æˆ‘ä»¬è‡ªå®šä¹‰çš„ drop æ–¹æ³•ã€‚
```

**`Pin<T>`**: é€šå¸¸ç”¨äºè§£å†³ Rust å¼•ç”¨ç±»å‹çš„å®‰å…¨æ€§é—®é¢˜ï¼Œå°¤å…¶æ˜¯ä¸å¼‚æ­¥ç¼–ç¨‹å’Œå†…å­˜ç®¡ç†ç›¸å…³çš„é—®é¢˜ã€‚`Pin<T>` ç±»å‹å¯ä»¥ç¡®ä¿è¢«å¼•ç”¨çš„å€¼ä¸ä¼šè¢«ç§»åŠ¨æˆ–é‡Šæ”¾

ä¸€èˆ¬æƒ…å†µä¸‹ï¼šRust ä¼šç¡®ä¿å¼•ç”¨æ€»æ˜¯æœ‰æ•ˆçš„ï¼Œä½†æ˜¯ä¹Ÿæœ‰ä¾‹å¤–æƒ…å†µï¼š

1. å½“å¼‚æ­¥ä»£ç åœ¨è¿è¡Œæ—¶å¯èƒ½ä¼šç§»åŠ¨æˆ–é‡Šæ”¾è¢«å¼•ç”¨çš„å€¼æ—¶ï¼Œæ¯”å¦‚ Future æˆ– async é—­åŒ…ï¼ˆè¿™ä¸ªæˆ‘ä»¬åé¢å†è®²ï¼‰
2. å½“ä½¿ç”¨ `unsafe` ä»£ç æ—¶ï¼Œå¯èƒ½ä¼šé€šè¿‡è£¸æŒ‡é’ˆå°†å¼•ç”¨ç±»å‹è½¬æ¢ä¸ºå¯å˜å¼•ç”¨ç±»å‹ï¼Œä»è€Œç ´åç¼–è¯‘å™¨å¯¹å¼•ç”¨ç±»å‹çš„ä¿æŠ¤

```rust
// 2 ç‰¹æ®Šç±»å‹ï¼šPin<T>

  use std::marker::PhantomPinned;
    use std::pin::Pin;

    // å®šä¹‰ä¸€ä¸ªè‡ªå¼•ç”¨çš„ç»“æ„ä½“ã€‚å› ä¸ºå®ƒå«æœ‰æŒ‡å‘è‡ªèº«çš„æŒ‡é’ˆï¼Œæ‰€ä»¥å®ƒåœ¨å†…å­˜ä¸­ä¸èƒ½è¢«ç§»åŠ¨ã€‚
    struct SelfReferential {
        i: i32,
        p: *const i32,       // è£¸æŒ‡é’ˆï¼Œå°†ä¼šæŒ‡å‘ä¸Šè¿°çš„ i
        _pin: PhantomPinned, // ä¹Ÿæ˜¯ä¸€ä¸ªé›¶å¤§å°çš„æ ‡è®°ç±»å‹ï¼Œé˜»æ­¢ Rust è‡ªåŠ¨ä¸ºæˆ‘ä»¬çš„ç±»å‹å®ç° Unpin trait
    }

    // æ³¨æ„æ­¤æ—¶ p æ˜¯ä¸€ä¸ªç©ºæŒ‡é’ˆï¼Œæˆ‘ä»¬è¿˜æ²¡æœ‰ä¸ºå®ƒåˆ†é…æŒ‡å‘çš„åœ°å€
    let mut test = SelfReferential {
        i: 123,
        p: std::ptr::null(),
        _pin: PhantomPinned,
    };

    // ä½¿ç”¨ Pin åŒ…è£…æˆ‘ä»¬çš„ç»“æ„ä½“å®ä¾‹ã€‚è¿™æ ·å°±èƒ½ä¿è¯ test çš„å†…å­˜åœ°å€ä¸ä¼šåœ¨å…¶ç”Ÿå‘½å‘¨æœŸä¸­æ”¹å˜ã€‚
    // æ³¨æ„ï¼šè¿™é‡Œä½¿ç”¨äº† unsafeï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦ä¿è¯åœ¨ test è¢«åŒ…è£…ä¸º Pin åï¼Œå…¶åœ°å€ä¸ä¼šè¢«æ”¹å˜
    let mut test = unsafe { Pin::new_unchecked(&mut test) };

    // åˆ›å»ºä¸€ä¸ªè£¸æŒ‡é’ˆï¼ŒæŒ‡å‘ test çš„ i å­—æ®µã€‚æ³¨æ„æˆ‘ä»¬ä½¿ç”¨äº† test çš„å¼•ç”¨ç‰ˆæœ¬ä»¥ä¿è¯å®‰å…¨ã€‚
    let self_ptr: *const i32 = &test.as_ref().get_ref().i;

    // å°†è£¸æŒ‡é’ˆå­˜å‚¨åˆ° test çš„ p å­—æ®µã€‚æ³¨æ„æˆ‘ä»¬ä½¿ç”¨äº† unsafeï¼Œå› ä¸ºæˆ‘ä»¬æ­£åœ¨ç›´æ¥ä¿®æ”¹å†…å­˜ã€‚

    unsafe {
        let mut_ref = Pin::as_mut(&mut test);
        mut_ref.get_unchecked_mut().p = self_ptr;
    }

    // æ‰“å° test çš„ p å­—æ®µæ‰€æŒ‡å‘çš„å†…å®¹ã€‚æ³¨æ„æˆ‘ä»¬ä½¿ç”¨äº† unsafeï¼Œå› ä¸ºæˆ‘ä»¬æ­£åœ¨è§£å¼•ç”¨è£¸æŒ‡é’ˆã€‚
    let val = unsafe { *(test.as_ref().get_ref().p) };
    println!("val: {}", val); // è¾“å‡º "val: 123"
```

## 3.4 è¯¾åä¹ é¢˜

1. é—­åŒ…çš„æœ¬è´¨æ˜¯ä»€ä¹ˆ
2. rust ä¸­çš„è¿­ä»£å™¨æ˜¯å¦‚ä½•å®ç°çš„ï¼Œæœ‰å“ªäº›ä¸»è¦çš„æ–¹æ³•ï¼Œä½ èƒ½ç¼–å†™å‡ ä¸ªä½¿ç”¨æ¡ˆä¾‹å—
3. æ™ºèƒ½æŒ‡é’ˆâ€œæ™ºèƒ½â€åœ¨å“ªé‡Œï¼ŸRust ä¸­å¸¸è§çš„æ™ºèƒ½æŒ‡é’ˆæœ‰å“ªäº›ï¼Ÿ
4. Rust ä¸­æœ‰å“ªäº›å®¹å™¨ç±»å‹ï¼Œé€‚ç”¨äºå“ªäº›åœºæ™¯ï¼Ÿ
5. ä½ èƒ½ä»æ ‡å‡†åº“ä¸­å‘ç°å…¶ä»–æ¯”è¾ƒç‰¹æ®Šçš„ç±»å‹å—ï¼Ÿ

# æ¨¡å—å››ï¼šRust é¡¹ç›®åŸºç¡€

## 4.1 é”™è¯¯å¤„ç†

Rust æ•´ä½“çš„é”™è¯¯å¤„ç†æœºåˆ¶æœ‰ä¸€ä¸ªå±‚çº§ï¼Œéšç€é”™è¯¯çš„`ä¸¥é‡ç¨‹åº¦`å¯ä»¥é€‰æ‹©ä¸åŒçš„å¤„ç†æ–¹æ¡ˆï¼ˆå…¶å®æ¯ä¸€ç§é”™è¯¯éƒ½æŒºä¸¥é‡çš„ï¼‰

1. ç±»å‹ç³»ç»Ÿä¿è¯å‡½æ•°å¥‘çº¦ï¼ˆRust ä¸¥æ ¼çš„ç±»å‹ç³»ç»Ÿå·²ç»å¸®æˆ‘ä»¬æ¶ˆé™¤äº†è¿™éƒ¨åˆ†çš„é”™è¯¯ï¼Œå¦‚æœç±»å‹ä¸æ­£ç¡®ï¼Œæ˜¯ä¸ä¼šé€šè¿‡ç¼–è¯‘çš„ï¼‰
2. Option<T>æ¶ˆé™¤ç©ºæŒ‡é’ˆå¤±è´¥ (å¤„ç†æœ‰å€¼æˆ–è€…æ— å€¼çš„æƒ…å†µ)
3. Result<T,E> ä¼ æ’­é”™è¯¯ ï¼ˆå¤„ç†æˆåŠŸæˆ–è€…å¤±è´¥çš„æƒ…å†µï¼Œå¤±è´¥æ—¶å¯ä»¥æŠ›å‡ºé”™è¯¯ï¼‰
4. æ–­è¨€ç”¨äºé˜²å¾¡
5. Panic ææ…Œ

```rust
 // 1 ç±»å‹ç³»ç»Ÿä¿è¯å‡½æ•°å¥‘çº¦
    fn sum(a: i32, b: i32) -> i32 {
        a + b
    }

    // sum(1u32, 2u32) è¿åå‡½æ•°å¥‘çº¦

    // 2 ä½¿ç”¨Optionå¤„ç†æœ‰å€¼æˆ–æ— å€¼çš„æƒ…å†µ
    // å½“æŸä¸ªå€¼å¯èƒ½ä¸ºæ— å€¼æ—¶ï¼Œåº”è¯¥ä½¿ç”¨Option<T>æ¥åŒ…è£¹ï¼Œä»¥æ­£ç¡®å¤„ç†æ— å€¼çš„æƒ…å†µ
    fn log(val: f64) -> Option<f64> {
        match val.log2() {
            x if x.is_normal() => Some(x), // æœ‰å€¼æƒ…å†µ
            _ => None,                     // æ— å€¼æƒ…å†µ
        }
    }

    // å½“ä¸€ä¸ªå€¼ä¸ºOption<T>æ—¶ï¼Œç»å¸¸ä½¿ç”¨mapå’Œand_thenç­‰æ–¹æ³•æ¥é“¾å¼å¤„ç†

    fn double(val: f64) -> f64 {
        val * 2.
    }

    fn square(val: f64) -> f64 {
        val.powi(2 as i32)
    }

    fn inverse(val: f64) -> f64 {
        val * -1.
    }

    fn sqrt(val: f64) -> Option<f64> {
        match val.sqrt() {
            x if x.is_normal() => Some(x),
            _ => None,
        }
    }

    let number = 20.;
    let result = Option::from(number)
        .map(inverse)
        .map(double)
        .map(inverse)
        .and_then(log)
        .map(square)
        .and_then(sqrt);
    match result {
        Some(x) => println!("x was {:?}", x),
        None => println!("this failed"),
    }

    // 3 Result ç”¨äºå¤„ç†æˆåŠŸæˆ–å¤±è´¥çš„æƒ…å†µ

    use std::fs::File;
    use std::io::prelude::*;
    use std::io::Error;

    fn read_file_contents(file_path: &str) -> Result<String, std::io::Error> {
        let mut file = File::open(file_path)?;
        let mut contents = String::new();
        file.read_to_string(&mut contents)?;
        Ok(contents)
    }

    let file_path = "example.txt";
    match read_file_contents(file_path) {
        Ok(contents) => println!("File contents: {}", contents), // æˆåŠŸæƒ…å†µ
        Err(error) => println!("Error reading file: {}", error), // å¤±è´¥æƒ…å†µï¼ŒæŠ›å‡ºé”™è¯¯
    }

    // 4 æ–­è¨€
    // å½“ä½ ç¡®å®šæŸä¸ªå€¼ä¸€å®šä¼šå‡ºç°æŸç§æƒ…å†µæ—¶ï¼Œå¯ä»¥ä½¿ç”¨æ–­è¨€æ¥ç»ˆæ­¢ç¨‹åº

    fn extend_vec(v: &mut Vec<i32>, i: i32) {
        assert!(v.len() == 3); // æ–­è¨€
        v.push(i)
    }

    let mut vec = vec![1, 2, 3];
    extend_vec(&mut vec, 4);

    assert_eq!(4, vec[3]); // æ–­è¨€

    // 5 ææ…Œ
    // å½“ä½ ç¡®å®šæŸä¸ªå€¼ä¸€å®šä¸ä¼šå‡ºç°æŸç§æƒ…å†µæ—¶ï¼Œå¯ä»¥ä½¿ç”¨ææ…Œæ¥ç»ˆæ­¢ç¨‹åº
    //

    fn factorial(n: u32) -> u32 {
        if n == 0 {
            1
        } else {
            n * factorial(n - 1)
        }
    }

    let result = factorial(10);
    println!("Result: {}", result);
    if result < 1000 {
        panic!("Result too large!"); // ä½¿ç”¨panic!ææ…Œ
    }

    // æ€»ç»“ï¼šä½¿ç”¨Optionå’ŒResultæ¥å¤„ç†å€¼æˆ–è€…é”™è¯¯ï¼Œä½¿ç”¨ææ…Œå’Œæ–­è¨€æ¥ç»ˆæ­¢ç¨‹åº
```

ä¸€ä¸ªä½¿ç”¨ç¬¬ä¸‰æ–¹åº“è‡ªå®šä¹‰é”™è¯¯çš„å°ä¾‹å­ï¼Œä½¿ç”¨thiserrorï¼Œè¯·å…ˆä½¿ç”¨`cargo add thiserror` å®‰è£…ä¾èµ–

```
// æ‰©å±•:ä½¿ç”¨ç¬¬ä¸‰æ–¹åº“thiserroræ¥è‡ªå®šä¹‰é”™è¯¯

    use std::io;
    use thiserror::Error;

   

    #[derive(Error, Debug)]
    pub enum DataStoreError {
        #[error("data store disconnected")]
        Disconnect(#[from] io::Error),
        #[error("the data for key `{0}` is not available")]
        Redaction(String),
        #[error("invalid header (expected {expected:?}, found {found:?})")]
        InvalidHeader { expected: String, found: String },
        #[error("unknown data store error")]
        Unknown,
    }

    fn read_data(key: &str) -> Result<(), DataStoreError> {
        if key == "invalid_key" {
            return Err(DataStoreError::Redaction(format!(
                "The data for key `{}` is not available",
                key
            )));
        }

        // è¯»å–æ•°æ®çš„é€»è¾‘...

        Ok(())
    }

    match read_data("valid_key") {
        Ok(()) => println!("read success"),
        Err(err) => println!("error: {:?}", err),
    }

```

## 4.2 é¡¹ç›®ç®¡ç†

Rust å·¥ç¨‹ç®¡ç†éå¸¸å‹å¥½ï¼Œå¯ä»¥è½»æ¾ç®¡ç†å¤æ‚åºå¤§çš„å·¥ç¨‹é¡¹ç›®

### 4.2.1 crate

åœ¨ Rust ä¸­ï¼Œæœ‰ä¸¤ç§ç±»å‹çš„ crateï¼Œä¹Ÿå« packageï¼ˆç±»ä¼¼äºå…¶ä»–è¯­è¨€çš„`åŒ…`ï¼‰: binary application package å’Œ library package .å‰è€…ä¸»è¦åº”ç”¨ç¨‹åºå…¥å£ï¼Œåè€…æ›´å¤šçš„æ˜¯ä¸ºå‰è€…æä¾›å„ç§å„æ ·çš„åŠŸèƒ½æ”¯æŒ

å¯ä»¥ä½¿ç”¨`Cargo`æ¥åˆ›å»º

```bash
 cargo new c1 --lib // åˆ›å»ºlib package
 cargo new c2 --bin // åˆ›å»ºbinary packageï¼Œé»˜è®¤åˆ›å»ºbinary package
```

ä¸¤ç§ crate çš„åŒºåˆ«å¹¶ä¸å¤§ï¼Œä½† binary application package å¯ä»¥ç›´æ¥ä½¿ç”¨ cargo run è¿è¡Œï¼Œè€Œ library package éœ€è¦é…ç½®æ‰å¯ä»¥ã€‚ä½ å¯å‚è€ƒä¸‹é¢é“¾æ¥äº†è§£å¦‚ä½•é…ç½®

[å¦‚ä½•åœ¨ lib crate ä¸­è¿è¡Œç¨‹åº](https://zhuanlan.zhihu.com/p/614506900)

### 4.2.2 å·¥ä½œç©ºé—´

å·¥ä½œç©ºé—´ç”¨äºç»„ç»‡å¤šä¸ª crateï¼Œæœ¬æ–‡æ¡£çš„ä»£ç ç»„ç»‡ç»“æ„å°±æ˜¯ä½¿ç”¨ workspace ç»„ç»‡äº†å¤šä¸ª lib crate

```bash
[workspace]
members = ['module-one','module-two','module-three','module-four','module-five','module-six']
```

ä½ å¯å‚è€ƒä¸‹é¢é“¾æ¥äº†è§£å¦‚ä½•ä¸ºé¡¹ç›®é…ç½®å·¥ä½œç©ºé—´

[å¦‚ä½•é…ç½® workspace](https://zhuanlan.zhihu.com/p/614506900)

## 4.3 æµ‹è¯•

æµ‹è¯•å¯¹äºä»»ä½•è¯­è¨€æ¥è¯´éƒ½éå¸¸é‡è¦ï¼Œåœ¨ Rust ä¸­ï¼Œä½ å¯ä»¥éå¸¸è½»æ¾çš„æ„å»ºæµ‹è¯•ã€‚æµ‹è¯•éœ€è¦æ”¾åœ¨æµ‹è¯•æ¨¡å—ä¸­ï¼Œä½ å¯ä»¥åœ¨ä»£ç ç¼–å†™å®Œæˆåç›´æ¥åœ¨å½“å‰æ–‡ä»¶ä¸­ç¼–å†™æµ‹è¯•ï¼Œä¹Ÿå¯ä»¥æ–°å»ºä¸€ä¸ªæµ‹è¯•æ–‡æ¡£ä¸“é—¨ç¼–å†™

### 4.3.1 å•å…ƒæµ‹è¯•

å•å…ƒæµ‹è¯•ä¸»è¦å¯¹å±€éƒ¨æ¨¡å—å†…çš„ä»£ç è¿›è¡Œæµ‹è¯•ã€‚æµ‹è¯•ä»£ç æ”¾åœ¨æµ‹è¯•æ¨¡å—ä¸­

```rust
use std::fs::File;
use std::io::Error;

fn read_file(path: &str) -> Result<File, Error> {
    // 2.1 è¯»å–æ–‡ä»¶
    let file = File::open(path);

    // 2.2 åˆ¤æ–­æ–‡ä»¶æ˜¯å¦å­˜åœ¨
    match file {
        Ok(file) => Ok(file),
        Err(error) => Err(error),
    }
}

#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

pub fn add_two(a: i32) -> i32 {
    a + 2
}

pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }

        Guess { value }
    }
}

// æµ‹è¯•æ¨¡å—

#[cfg(test)]
mod tests {
    use super::*;

    // 1 ä½¿ç”¨ assert! å®æ–­è¨€ç»“æœæ˜¯æŠ–ä¸º true

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&smaller)); // å¯ä»¥ç›´æ¥æ–­è¨€ï¼Œä¹Ÿå¯ä»¥å¸¦ä¸Šæç¤ºä¿¡æ¯
        assert!(
            larger.can_hold(&smaller),
            "larger is {:?}, smaller is {:?}",
            larger,
            smaller
        );
    }

    // 2 ä½¿ç”¨ assert_eq! å®æ–­è¨€ä¸¤ä¸ªå€¼ç›¸ç­‰

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }

    // 3 ä½¿ç”¨ assert_ne! å®æ–­è¨€ä¸¤ä¸ªå€¼ä¸ç›¸ç­‰
    #[test]
    fn it_adds_two() {
        assert_ne!(3, add_two(2));
    }

    // 4 ä½¿ç”¨ should_panic å®æ–­è¨€å‡½æ•°ä¼š panic

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }

    // 5 ä½¿ç”¨Result<T, E>ç±»å‹çš„æ–­è¨€

    #[test]
    fn read_file_should_works() -> Result<(), String> {
        match read_file("rust.txt") {
            Ok(_) => Ok(()),
            Err(_) => Err(String::from("file did not exit")),
        }
    }
}
```

### 4.3.2 æ–‡æ¡£æµ‹è¯•

æ–‡æ¡£æµ‹è¯•ä¹Ÿæ˜¯å•å…ƒæµ‹è¯•ï¼Œåªä¸è¿‡ä¸æŠŠæµ‹è¯•ä»£ç å†™åœ¨æµ‹è¯•æ¨¡å—ä¸­è€Œæ˜¯å†™åœ¨æ–‡æ¡£å¤‡æ³¨ä¸­

````rust
/// ```
/// fn add(a: i32, b: i32) -> i32 {
/// a + b
/// }
/// let result = add(2, 3);
/// assert_eq!(result, 5);

/// ```
fn add() {}
````

æœ¬æ–‡æ¡£çš„æ‰€æœ‰ä»£ç éƒ½ä»¥æ–‡æ¡£æµ‹è¯•å½¢å¼ç¼–å†™ï¼Œä½ å¯ä»¥ç›´æ¥è¿è¡Œ

### 4.3.3 é›†æˆæµ‹è¯•

é›†æˆæµ‹è¯•å¯¹äºæ•´ä¸ª lib crate æ¥è¯´æ˜¯å¤–éƒ¨çš„ï¼Œç›®çš„åœ¨äºæµ‹è¯•å„ä¸ªæ¨¡å—æ˜¯å¦èƒ½å¤Ÿä¸€èµ·æ­£ç¡®çš„å·¥ä½œï¼Œåˆ›å»ºé›†æˆæµ‹è¯•éœ€è¦åˆ›å»ºäº src åŒçº§çš„ tests ç›®å½•æ‰§è¡Œ

åœ¨ lib.rs ä¸‹åˆ›å»ºä¸€ä¸ªæ¨¡å—ï¼Œå¹¶å¯¼å‡ºå®šä¹‰çš„å‡½æ•°

```rust
pub use my_add::*;
mod my_add {

    pub fn add() -> i32 {
        2 + 2
    }
}
```

æ–°å»º src åŒçº§ç›®å½• testsï¼Œå¹¶åˆ›å»ºæ–‡ä»¶ add_test.rs,å¹¶åœ¨å…¶ä¸­å…ˆå¼•å…¥å‡½æ•°ï¼Œå†ç¼–å†™æµ‹è¯•

```rust
use module_four::add;

#[test]
fn it_adds_two() {
    assert_eq!(4, add());
}
```

ç„¶ååœ¨é¡¹ç›®ä¸‹è¿è¡Œ`cargo test`å°±å¯ä»¥æµ‹è¯•äº†

## 4.4 è¯¾åä¹ é¢˜

1. ä½ è®¤ä¸ºçš„é”™è¯¯å¤„ç†é€»è¾‘åº”è¯¥æ˜¯æ€æ ·çš„ï¼Ÿ
2. ä»¥ä¸€ä¸ªå·¥ä½œç©ºé—´çš„å½¢å¼åˆ›å»ºä¸€ä¸ªé¡¹ç›®ï¼Œå¹¶åœ¨å…¶ä¸‹åˆ›å»ºå¤šä¸ªæ¨¡å—ï¼Œå¹¶æŠŠå®ƒä»¬å…³è”èµ·æ¥ï¼Œä½¿ä¹‹èƒ½å¤Ÿæ­£å¸¸ç¼–è¯‘è¿è¡Œ
3. å°è¯•ç¼–å†™å•å…ƒæµ‹è¯•å’Œé›†æˆæµ‹è¯•

# æ¨¡å—äº”ï¼šå¹¶å‘ç¼–ç¨‹å’Œå¼‚æ­¥ç¼–ç¨‹

## 5.1 å¹¶å‘ç¼–ç¨‹

### 5.1.1 åŸç†ä»‹ç»

åœ¨å®é™…çš„ä¸šåŠ¡åœºæ™¯ä¸­ï¼Œæˆ‘ä»¬å¯èƒ½ä¼šå¹¶å‘æˆ–è€…å¼‚æ­¥å¤„ç†å„ç§å„æ ·çš„è¯·æ±‚ï¼Œç”šè‡³æ˜¯äºŒè€…ç›¸ç»“åˆï¼Œä»¥æé«˜è¯·æ±‚å¤„ç†æ•ˆç‡ã€‚åœ¨æ­¤ä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆåŒºåˆ«ä¸¤ä¸ªæ¦‚å¿µï¼šå¹¶å‘å’Œå¹¶è¡Œï¼šå¹¶å‘å’Œå¹¶è¡Œéƒ½æ˜¯å¯¹â€œå¤šä»»åŠ¡â€å¤„ç†çš„æè¿°ï¼Œå…¶ä¸­å¹¶å‘æ˜¯è½®æµå¤„ç†ï¼Œè€Œå¹¶è¡Œæ˜¯åŒæ—¶å¤„ç†

ç°ä»£ä¸ªäººè®¡ç®—æœºé€šå¸¸æ‹¥æœ‰å¤šæ ¸å¿ƒï¼Œé€šè¿‡å°†ä»»åŠ¡åˆ†æˆå¤šä¸ªé˜Ÿåˆ—å¹¶äº¤ç»™ä¸åŒæ ¸å¿ƒå¤„ç†å¹¶è¡Œæ‰§è¡Œï¼Œå¯ä»¥æå¤§æé«˜å¤„ç†æ•ˆç‡å’Œé€Ÿåº¦

åœ¨æ“ä½œç³»ç»Ÿå±‚é¢ï¼Œå¤šçº¿ç¨‹ç®¡ç†ä»»åŠ¡é˜Ÿåˆ—ï¼Œæ¯ä¸ªçº¿ç¨‹ç®¡ç†ä¸€ä¸ªä»»åŠ¡é˜Ÿåˆ—ï¼Œå¹¶å¯æ ¹æ®ç©ºé—²ç¨‹åº¦è¿›è¡Œä»»åŠ¡è°ƒåº¦ã€‚ç¨‹åºåªä¸æ“ä½œç³»ç»Ÿçº¿ç¨‹äº¤äº’ï¼Œè€Œä¸å…³å¿ƒ CPU æ ¸å¿ƒæ•°é‡ï¼Œå½“çº¿ç¨‹å°†ä»»åŠ¡åˆ†é…ç»™ CPU æ ¸å¿ƒæ‰§è¡Œæ—¶ï¼Œè‹¥åªæœ‰ä¸€ä¸ªæ ¸å¿ƒï¼Œåˆ™åªèƒ½åŒæ—¶å¤„ç†ä¸€ä¸ªä»»åŠ¡ã€‚æ­¤æ—¶å¾®è§‚ä¸Š CPU å¿«é€Ÿè½®æ¢å¤„ç†ä¸åŒçš„ä»»åŠ¡ï¼Œå¸¦æ¥äº†å®è§‚ä¸Šçš„åŒæ—¶è¿è¡Œå‡è±¡ã€‚è‹¥æœ‰ N ä¸ªæ ¸å¿ƒæ—¶ï¼Œå°±èƒ½å¤Ÿå®ç°åŒæ—¶å¤„ç† N ä¸ªä»»åŠ¡

å½“æ“ä½œç³»ç»Ÿçš„çº¿ç¨‹ä¸º M,CPU æ ¸å¿ƒæ•°é‡ä¸º N æ—¶ï¼Œåœ¨ M ä¸ªçº¿ç¨‹ä¸­çš„ä»»åŠ¡ä¼šè¢«åˆ†é…ç»™ N ä¸ª CPU æ ¸å¿ƒå¤„ç†ï¼Œæ­¤æ—¶å°±å®ç°äº† M:N å¤„ç†æ¨¡å‹ã€‚æ­¤æ—¶å¹¶å‘å’Œå¹¶è¡ŒåŒæ—¶å‘ç”Ÿ

æ“ä½œç³»ç»Ÿä¸ºç¼–ç¨‹è¯­è¨€æä¾›äº†åˆ›å»ºçº¿ç¨‹çš„ APIï¼Œæ­¤æ—¶ç¨‹åºå†…åˆ›å»ºçš„çº¿ç¨‹æ•°é‡ä¼šå’Œè¯¥ç¨‹åºå ç”¨æ“ä½œç³»ç»Ÿä¸­çš„çº¿ç¨‹æ•°é‡ç›¸ç­‰ï¼Œå³ 1:1 æ¨¡å‹ã€‚Rust å°±æ˜¯è¿™ç§æ¨¡å‹ï¼Œå½“ä½ åœ¨ç¨‹åºä¸­åˆ›å»ºäº†ä¸€ä¸ªçº¿ç¨‹æ—¶ï¼Œè¿™æ„å‘³ç€ä½ åˆ›å»ºäº†ä¸€ä¸ªæ“ä½œç³»ç»Ÿçº¿ç¨‹

æœ‰äº›ç¼–ç¨‹è¯­è¨€å®ç°äº†è‡ªå·±çš„çº¿ç¨‹æ¨¡å‹ï¼ˆä¾‹å¦‚ç»¿è‰²çº¿ç¨‹å’Œåç¨‹ï¼‰ï¼Œç¨‹åºå†…çš„ M ä¸ªçº¿ç¨‹ä¼šæ˜ å°„åˆ° N ä¸ªæ“ä½œç³»ç»Ÿçº¿ç¨‹ä¸Šè¿è¡Œï¼Œè¿™è¢«ç§°ä¸º M:N çº¿ç¨‹æ¨¡å‹ï¼Œå…¶ä¸­ M å’Œ N æ²¡æœ‰ç‰¹å®šçš„é™åˆ¶å…³ç³»ã€‚Go è¯­è¨€æ˜¯ä¸€ä¸ªå…¸å‹çš„ä¾‹å­ã€‚å…¶ä»–è¯­è¨€åˆ™ä½¿ç”¨ Actor æ¨¡å‹ï¼ŒåŸºäºæ¶ˆæ¯ä¼ é€’å®ç°å¹¶å‘ï¼Œä¾‹å¦‚ Erlang è¯­è¨€

### 5.1.2 å¹¶å‘å®æˆ˜

**åœ¨ç¨‹åºä¸­åˆ›å»ºå¤šä¸ªçº¿ç¨‹**

å°½ç®¡å¹¶å‘ç¼–ç¨‹æ¶‰åŠè®¡ç®—æœºçš„ç‰©ç†åŸºç¡€å’Œä¸€äº›æ“ä½œç³»ç»ŸçŸ¥è¯†ï¼Œæ¯”è¾ƒè´¹è§£ã€‚ä½†æ˜¯åœ¨åˆ›å»ºä¸Šéå¸¸ç®€å•ï¼Œä½ åªéœ€è¦å€ŸåŠ©ç¼–ç¨‹è¯­è¨€æä¾›å¥½çš„æ¥å£ç›´æ¥åˆ›å»ºå³å¯

```rust
// mainå‡½æ•°æ˜¯ä¸»çº¿ç¨‹
fn main() {
    // åˆ›å»ºçº¿ç¨‹

    use std::thread;

    let mut threads = vec![];

    // åˆ›å»º5ä¸ªçº¿ç¨‹ï¼Œå®ƒä»¬å’Œmainå‡½æ•°çš„çº¿ç¨‹æ˜¯å¹¶è¡Œçš„ï¼Œå¹¶ä¸”æ‰§è¡Œç»“æŸçš„æ—¶é—´ä¸ä¸€å®š
    for i in 0..5 {
        // let x = move || {
        //     println!("Hello from thread {}", i);
        // };

        // let handle = thread::spawn(x);

        let handle = thread::spawn(move || {
            println!("Hello from thread {}", i);
        });

        threads.push(handle);
    }

    // ç­‰å¾…çº¿ç¨‹æ‰§è¡Œç»“æŸ
    for thread in threads {
        thread.join().unwrap();
    }
}
```

**åœ¨å¤šä¸ªçº¿ç¨‹é—´å…±äº«èµ„æº**

å¹¶å‘ç¼–ç¨‹é™¤äº†åœ¨åŸç†ç†è§£ä¸Šæ¯”è¾ƒéš¾ä¹‹å¤–ï¼Œå¦ä¸€ä¸ªéš¾ç‚¹æ˜¯å¼‚æ­¥é—´å…±äº«æ•°æ®ã€‚ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œçº¿ç¨‹é—´å…±äº«æ•°æ®ä¸»è¦æœ‰ä¸¤ç§æ–¹å¼ï¼Œå…±äº«å†…å­˜å’Œæ¶ˆæ¯ä¼ é€’ï¼Œå…¶ä¸­å…±äº«å†…å­˜è¿˜å¯ä»¥åˆ†ä¸ºæ— é”å…±äº«å’Œæœ‰é”å…±äº«ã€‚åœ¨ Rust ä¸­ï¼Œä½ å¯ä»¥é€šè¿‡é€šé“ï¼ˆchannelï¼‰åœ¨çº¿ç¨‹é—´å‘é€æ•°æ®ï¼Œè¿˜å¯ä»¥é€šè¿‡é”æ¥ç‹¬å è®¿é—®æ•°æ®ï¼Œä¹Ÿå¯ä»¥é€šè¿‡ç›´æ¥æ“ä½œåŸå­ç±»å‹ï¼Œå®ç°æ— é”å…±äº«ï¼Œä¸‹é¢æ˜¯å‡ ä¸ªä¾‹å­

```rust
// mainå‡½æ•°æ˜¯ä¸»çº¿ç¨‹
fn main() {
    // 1 é€šè¿‡ channel å…±äº«æ•°æ®

    use std::sync::mpsc;
    use std::thread;

    // åˆ›å»ºé€šé“ï¼ˆä¿¡æ¯æ¥æ”¶è€…å’Œä¿¡æ¯å‘é€è€…ï¼‰

    let (tx, rx) = mpsc::channel();

    thread::spawn(move || {
        let tx1 = tx.clone();
        let tx2 = tx.clone();

        // åœ¨çº¿ç¨‹ä¸­åˆ›å»ºå˜é‡
        let val1 = String::from("hi");
        let val2 = String::from("hello");

        // å°†å˜é‡å‘é€ç»™åˆ«çš„çº¿ç¨‹
        tx1.send(val1).unwrap();
        tx2.send(val2).unwrap();
        // println!("{:?}", val); // ä¸èƒ½å†ä½¿ç”¨
    });

    // æ¥æ”¶æ•°æ®
    for received in rx {
        println!("Got: {}", received);
    }

    // 2 ä½¿ç”¨é”å…±äº«æ•°æ®

    use std::sync::{Arc, Mutex};

    // åœ¨ä½¿ç”¨çº¿ç¨‹æ—¶ï¼Œæˆ‘ä»¬éœ€è¦å°†æ•°æ®ç§»å…¥çº¿ç¨‹å†…ï¼Œä½†æ˜¯ä¸€æ—¦ç§»å…¥ï¼Œæ•°æ®å°±ä¸å¯ç”¨äº†ï¼Œæ‰€ä»¥ä½¿ç”¨å¼•ç”¨è®¡æ•°å®¹å™¨Arcå…±äº«æ‰€æœ‰æƒ
    // åŒæ—¶é€šè¿‡Mutexæ¥ä¿è¯ç‹¬å è®¿é—®

    let counter = Arc::new(Mutex::new(0));
    let mut handles = vec![];

    for _ in 0..10 {
        let counter = Arc::clone(&counter);

        let handle = thread::spawn(move || {
            // æ‹¿åˆ°é”
            let mut num = counter.lock().unwrap();
            // ä¿®æ”¹æ•°æ®
            *num += 1;

            // é”é‡Šæ”¾
            // lock è°ƒç”¨ä¼šä¸€ä¸ªå«åš MutexGuard çš„æ™ºèƒ½æŒ‡é’ˆ
            // è¿™ä¸ªæ™ºèƒ½æŒ‡é’ˆå®ç°äº† Deref å’Œ Drop trait
            // å¯ä»¥è‡ªåŠ¨è§£å¼•ç”¨ä»¥åŠä¸¢å¼ƒå€¼
            // æ­¤å¤„è‡ªåŠ¨è°ƒç”¨äº† drop()
        });

        handles.push(handle);
    }

    // ç­‰å¾…æ‰€æœ‰çº¿ç¨‹å®Œæˆ
    for handle in handles {
        handle.join().unwrap();
    }
    println!("Result: {}", *counter.lock().unwrap());

    // 3 ä½¿ç”¨åŸå­ç±»å‹å…±äº«æ•°æ®

    use std::sync::atomic::{compiler_fence, AtomicBool};

    // åˆ›å»ºä¸€ä¸ªAtomicBoolå‹çš„è‡ªæ—‹é”ï¼Œé€šè¿‡ArcåŒ…è£¹ä»¥åœ¨å¤šçº¿ç¨‹ä¹‹é—´å…±äº«
    let spin_lock = Arc::new(AtomicBool::new(false));

    // åˆ›å»ºä¸¤ä¸ªå¼•ç”¨åˆ°åŒä¸€ä¸ªè‡ªæ—‹é”çš„å…‹éš†
    let spin_lock_clone = Arc::clone(&spin_lock);
    let sc = Arc::clone(&spin_lock);

    let thread = thread::spawn(move || {
        // ç”¨SeqCstå†…å­˜é¡ºåºå°†é”çŠ¶æ€è®¾ä¸ºtrueï¼Œè¡¨ç¤ºè¯¥é”è¢«å ç”¨ã€‚SeqCstå¯ä»¥ç¡®ä¿æ­¤æ“ä½œå¯¹æ‰€æœ‰çº¿ç¨‹ç«‹å³å¯è§ï¼Œ
        // å³æ— è®ºå…¶ä»–çº¿ç¨‹åœ¨ä½•å¤„ï¼Œä»–ä»¬éƒ½èƒ½çœ‹åˆ°è¿™ä¸ªæ”¹å˜
        spin_lock_clone.store(true, std::sync::atomic::Ordering::SeqCst);
        println!("spin_lock status a {:?}", sc);

        // ä¼‘çœ 2ç§’
        let time = std::time::Duration::from_secs(2);
        std::thread::sleep(time);

        // è®¾ç½®ä¸€ä¸ªç¼–è¯‘å™¨æ …æ ï¼Œå†…å­˜é¡ºåºæ˜¯Releaseã€‚è¿™æ„å‘³ç€è¿™ä¸ªæ …æ ä¹‹å‰çš„æ‰€æœ‰æ“ä½œï¼ˆåŒ…æ‹¬ä¸Šé¢çš„println!å’Œsleepï¼‰éƒ½ä¼šåœ¨è¿™ä¸ªæ …æ ä¹‹å‰å®Œæˆã€‚
        // Releaseè¯­ä¹‰ï¼šä¿è¯æ‰€æœ‰åœ¨æ­¤ä¹‹å‰çš„æ“ä½œéƒ½å…ˆæ‰§è¡Œå®Œæ¯•ï¼Œç¡®ä¿åœ¨ä½ æ›´æ”¹å…±äº«æ•°æ®ä¹‹å‰ï¼Œæ‰€æœ‰å…¶ä»–çº¿ç¨‹å¯¹è¿™ä¸ªæ•°æ®çš„å¼•ç”¨éƒ½å·²ç»å®Œæˆ
        compiler_fence(std::sync::atomic::Ordering::Release);

        // ä½¿ç”¨SeqCstå†…å­˜é¡ºåºå°†é”çŠ¶æ€è®¾ä¸ºfalseï¼Œè¡¨ç¤ºé”å·²ç»é‡Šæ”¾ã€‚SeqCstå¯ä»¥ä¿è¯è¿™ä¸ªæ“ä½œå¯¹æ‰€æœ‰çº¿ç¨‹ç«‹å³å¯è§
        spin_lock_clone.store(false, std::sync::atomic::Ordering::SeqCst);
        println!("spin_lock status b {:?}", sc);
    });

    // ä¸»çº¿ç¨‹åœ¨è¿™é‡Œä¼šæŒç»­æ£€æŸ¥è‡ªæ—‹é”çš„çŠ¶æ€ï¼Œåªè¦é”çš„å€¼ä¸ºtrueï¼ˆè¢«å ç”¨ï¼‰ï¼Œå°±ä¼šç­‰å¾…ã€‚
    // è¿™é‡Œä¹Ÿä½¿ç”¨SeqCstå†…å­˜é¡ºåºæ¥ä¿è¯é”çŠ¶æ€çš„è¯»å–èƒ½åœ¨å¤šçº¿ç¨‹ä¸­åŒæ­¥
    while spin_lock.load(std::sync::atomic::Ordering::SeqCst) == true {
        println!("spin_lock status c {:?}", spin_lock)
    }

    println!("spin_lock status d {:?}", spin_lock);

    if let Err(e) = thread.join() {
        println!("Thread had an error {:?}", e);
    }
}
```

## 5.2 å¼‚æ­¥ç¼–ç¨‹

æˆ‘ä»¬å†åŒºåˆ«ä¸€ä¸‹åŒæ­¥å’Œå¼‚æ­¥ï¼Œä»è°ƒç”¨è€…å¾—è§†è§’çœ‹åŒæ­¥æŒ‡è°ƒç”¨ç›´åˆ°è·å¾—ç»“æœæ—¶æ‰è¿”å›ï¼Œè€Œå¼‚æ­¥æŒ‡åœ¨æœªè·å¾—ç»“æœæ—¶å…ˆè¿”å›ã€‚

1. åŒæ­¥ IO æ¨¡å‹ä¸‹ï¼Œç¨‹åºæ‰§è¡Œæ—¶ï¼Œæ•°æ®ä»å¤–éƒ¨åˆ°ç¨‹åºå†…éƒ¨çš„æ•´ä¸ªè¿‡ç¨‹å¯ä»¥åˆ†ä¸ºä¸¤æ®µï¼šæ•°æ®å‡†å¤‡å’Œæ•°æ®æ‹·è´é˜¶æ®µï¼ˆä»æ“ä½œç³»ç»Ÿå†…æ ¸ç¼“å†²åŒºå¤åˆ¶åˆ°è¿›ç¨‹ç¼“å†²åŒºï¼‰ã€‚ç¨‹åºåœ¨ä½¿ç”¨æ•°æ®æ—¶éœ€è¦é€šè¿‡ç³»ç»Ÿè°ƒç”¨æ¥è¯·æ±‚æ•°æ®

æ•°æ®å‡†å¤‡é˜¶æ®µï¼šå¯ä»¥æ˜¯é˜»å¡çš„ï¼ˆé˜»å¡çº¿ç¨‹ï¼Œç›´åˆ°æ•°æ®å‡†å¤‡å¥½ï¼‰å’Œéé˜»å¡çš„ï¼ˆç«‹å³è¿”å›é”™è¯¯ï¼Œç„¶åé€šè¿‡è½®è¯¢æ•°æ®ï¼Œç›´åˆ°æ•°æ®å‡†å¤‡å°±ç»ªï¼‰

æ•°æ®æ‹·è´é˜¶æ®µï¼šæŠŠæ•°æ®ä»å†…æ ¸ç¼“å†²åŒºæ‹·è´è‡³åº”ç”¨ç¨‹åºç¼“å†²åŒºï¼ˆç”¨æˆ·æ€ç¼“å†²åŒºï¼‰ï¼ŒåŒæ­¥ I/O ä¸‹æ°¸è¿œé˜»å¡

2. å¼‚æ­¥ I/O å¯ä»¥æŠŠæ•°æ®çš„å‡†å¤‡å’Œå¤åˆ¶è¿‡ç¨‹çœ‹ä½œæ˜¯ä¸€ä¸ªæ“ä½œï¼Œå‡ç”±æ“ä½œç³»ç»Ÿå®Œæˆ

### 5.2.1 å¼‚æ­¥åŸç†

Rust ä¸­çš„å¼‚æ­¥ç¼–ç¨‹é€šè¿‡äº‹ä»¶å¾ªç¯æˆ–å¼‚æ­¥è¿è¡Œæ—¶æ¥å®ç°ï¼Œå®ƒé¿å…äº†çº¿ç¨‹ä¸Šä¸‹æ–‡åˆ‡æ¢çš„å¼€é”€å’Œå†…å­˜å ç”¨ã€‚å¼‚æ­¥ä»»åŠ¡åœ¨ç­‰å¾… I/O æ“ä½œå®Œæˆæ—¶å¯ä»¥æŒ‚èµ·ï¼Œè€Œä¸éœ€è¦å ç”¨çº¿ç¨‹ã€‚å½“ I/O æ“ä½œå®Œæˆæ—¶ï¼Œå¼‚æ­¥ä»»åŠ¡å¯ä»¥ç»§ç»­æ‰§è¡Œï¼Œä»è€Œå‡å°‘äº†çº¿ç¨‹åˆ‡æ¢çš„å¼€é”€ã€‚å› æ­¤ï¼Œå¼‚æ­¥ç¼–ç¨‹å¯ä»¥æ›´é«˜æ•ˆåœ°åˆ©ç”¨ç³»ç»Ÿèµ„æºï¼Œæé«˜åº”ç”¨ç¨‹åºçš„æ€§èƒ½å’Œå¯é æ€§

å¦å¤–ï¼Œæ³¨æ„ Rust ä¸­çš„å¼‚æ­¥ IO ç¼–ç¨‹æ¨¡å‹åŒ…å«äº†æ“ä½œç³»ç»Ÿçš„åŒæ­¥ IO å’Œå¼‚æ­¥ IO

### 5.2.2 å¼‚æ­¥è¿è¡Œæ—¶

Rust åªæä¾›äº†é›¶æˆæœ¬çš„å¼‚æ­¥ç¼–ç¨‹æŠ½è±¡è€Œä¸å†…ç½®è¿è¡Œæ—¶ï¼Œè¿™æ„å‘³ç€ä½ å¯ä»¥æ ¹æ®å®é™…ä¸šåŠ¡éœ€æ±‚æ›¿æ¢è¿è¡Œæ—¶ï¼Œå¦‚ tokioï¼Œasync-stdï¼Œno_std å’Œ smol ç­‰

### **5.2.3 async å’Œ await**

Rust ä¸­æä¾›äº†ä¸€ä¸ª Future traitï¼Œå¹¶åœ¨ future çš„åŸºç¡€ä¸Šæä¾› async/await è¯­æ³•ç³–ï¼Œå®ƒçš„æœ¬è´¨æ˜¯ä¸€ä¸ªçŠ¶æ€æœºï¼Œä¹Ÿå«æ— æ ˆåç¨‹

é›¶æˆæœ¬æŠ½è±¡ï¼šasync/await è¯­æ³•ç³–åœ¨ç¼–è¯‘æœŸå°±ä¼šå±•å¼€æˆä¸ºå›ºå®šç±»å‹

è¿™é‡Œçš„ async/await è¯­æ³•å¾ˆå½¢è±¡ï¼Œæ¯”è¾ƒå¥½ç†è§£ï¼Œæ—©æœŸ Rust ä¸­çš„å¼‚æ­¥å†™æ³•æ˜¯ä¸€ä¸²ä¸²é“¾å¼è°ƒç”¨ï¼Œä¸€ä¸ªä¸»è¦çš„é—®é¢˜æ˜¯ä¼šäº§ç”Ÿå¾ˆå¤šå†…åµŒä»£ç 

ï¼Œä¸å¥½å¤„ç†ã€‚è€Œä½¿ç”¨ async/await è¯­æ³•å…è®¸ä½ åƒå†™åŒæ­¥ä»£ç ä¸€æ ·å†™ä¸€æ­¥ä»£ç 

å¼‚æ­¥ä»»åŠ¡å¯ä»¥çœ‹ä½œæ˜¯ä¸€ç§ç»¿è‰²çº¿ç¨‹ï¼Œåœ¨çº¿ç¨‹å†…æ‰§è¡Œï¼Œå®ƒä»¬çš„åŒºåˆ«åœ¨ç”¨æˆ·æ€ï¼Œæ²¡æœ‰çº¿ç¨‹ä¸Šä¸‹æ–‡åˆ‡æ¢å¼€é”€

### 5.2.4 å¼‚æ­¥å®æˆ˜

å°½ç®¡ Rust å¼‚æ­¥ç¼–ç¨‹åŸç†ç†è§£æ¯”è¾ƒå›°éš¾ï¼Œä½†æ˜¯åœ¨å®é™…ä½¿ç”¨ä¸­å®ƒéå¸¸ç®€å•ï¼Œä¸‹é¢æ˜¯ä¸€ä¸ªæ¡ˆä¾‹

Cargo.toml

```
[dependencies]
reqwest = { version = "0.11", features = ["blocking", "json"] }
tokio = { version = "1", features = ["full"] }
serde = { version = "1.0", features = ["derive"] }
```

```rust
use reqwest::{blocking::Client, Error};
use serde::Deserialize;
use std::vec::Vec;
use tokio;

#[derive(Deserialize, Debug)]
struct Post {
    userId: u32,
    id: u32,
    title: String,
    body: String,
}

async fn fetch_post_async(url: &str) -> Result<Post, Error> {
    let response = reqwest::get(url).await?;
    let response = response.error_for_status()?;
    let post: Post = response.json().await?;
    Ok(post)
}

fn fetch_post_sync(url: &str) -> Result<Post, Error> {
    let client = Client::new();
    let response = client.get(url).send()?;
    let response = response.error_for_status()?;
    let post: Post = response.json()?;
    Ok(post)
}

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    let urls = vec![
        "https://jsonplaceholder.typicode.com/posts/1",
        "https://jsonplaceholder.typicode.com/posts/2",
        "https://jsonplaceholder.typicode.com/posts/3",
    ];

    let urls_clone = urls.clone();

    println!("åŒæ­¥è¯·æ±‚ï¼š");

    let sync_start = std::time::Instant::now();
    let sync_thread = std::thread::spawn(move || {
        for url in &urls_clone {
            match fetch_post_sync(url) {
                Ok(post) => println!("Postä¿¡æ¯: {:?}", post),
                Err(err) => eprintln!("è¯·æ±‚å¤±è´¥: {:?}", err),
            }
        }
    });
    sync_thread.join().unwrap();
    let sync_duration = sync_start.elapsed().as_millis();
    println!("åŒæ­¥è¯·æ±‚æ€»è€—æ—¶ï¼š{} ms", sync_duration);

    println!("å¼‚æ­¥è¯·æ±‚ï¼š");
    let async_start = std::time::Instant::now();
    let mut tasks = Vec::new();
    for url in urls {
        let task = tokio::spawn(async move {
            match fetch_post_async(&url).await {
                Ok(post) => println!("Postä¿¡æ¯: {:?}", post),
                Err(err) => eprintln!("è¯·æ±‚å¤±è´¥: {:?}", err),
            }
        });
        tasks.push(task);
    }

    for task in tasks {
        task.await?;
    }
    let async_duration = async_start.elapsed().as_millis();
    println!("å¼‚æ­¥è¯·æ±‚æ€»è€—æ—¶ï¼š{} ms", async_duration);

    let ratio = sync_duration as f64 / async_duration as f64;
    println!("åŒæ­¥è¯·æ±‚è€—æ—¶æ˜¯å¼‚æ­¥è¯·æ±‚è€—æ—¶çš„ {:.2} å€", ratio);

    Ok(())
}
```

## 5.3 è¯¾åä¹ é¢˜

1. å¦‚ä½•ç†è§£ Rust ä¸­çš„å¹¶å‘ç¼–ç¨‹å’Œå¼‚æ­¥ç¼–ç¨‹ï¼Ÿ
2. å°è¯•ç¼–å†™ä¸€ä¸ªå¹¶å‘ç¨‹åº
3. ä½¿ç”¨ç¤¾åŒºä¸­ä½ å–œæ¬¢çš„å¼‚æ­¥è¿è¡Œæ—¶ç¼–å†™ä¸€ä¸ªå°ç¨‹åº

# æ¨¡å—å…­ï¼šRust å†…å®¹æ‰©å±•ï¼ˆé€‰å­¦ï¼‰

## 6.1 å®ç¼–ç¨‹

### 6.1.1 å®ä»‹ç»

å®ï¼ˆmacroï¼‰æ˜¯ä¸€ç§ç¼–ç¨‹æŠ€æœ¯ï¼Œå…è®¸ç¨‹åºå‘˜ç¼–å†™å¯åœ¨ç¼–è¯‘æ—¶æˆ–é¢„å¤„ç†æ—¶å±•å¼€çš„ä»£ç ç‰‡æ®µã€‚è®¸å¤šé«˜çº§ç¼–ç¨‹è¯­è¨€æ”¯æŒå®æˆ–ç±»ä¼¼çš„åŠŸèƒ½ã€‚Rust æ”¯æŒä¸¤ç§ç±»å‹çš„å®ï¼šå£°æ˜å¼å®ï¼ˆDeclarative Macrosï¼‰å’Œè¿‡ç¨‹å®ï¼ˆProcedural Macrosï¼‰

### 6.1.2 å£°æ˜å®

å£°æ˜å¼å®ç±»ä¼¼äº C å’Œ C++ ä¸­çš„é¢„å¤„ç†å™¨å®ï¼Œä½†æ›´å¼ºå¤§å’Œå®‰å…¨ã€‚å£°æ˜å¼å®ä½¿ç”¨ `macro_rules!` å…³é”®å­—å®šä¹‰ï¼Œå¹¶é€šè¿‡æ¨¡å¼åŒ¹é…å’Œä»£ç ç”Ÿæˆæ¥å·¥ä½œã€‚å®ƒä»¬å¯ä»¥ç”¨æ¥å‡å°‘ä»£ç é‡å¤ã€åˆ›å»ºç®€æ´çš„ DSLï¼ˆé¢†åŸŸç‰¹å®šè¯­è¨€ï¼‰ç­‰

å¦‚ä¸‹æ˜¯ä¸€ä¸ªå£°æ˜å®çš„å£°æ˜å’Œä½¿ç”¨æ¡ˆä¾‹

```rust
// å¯¼å…¥ HashMapï¼Œç”¨äºå­˜å‚¨é”®å€¼å¯¹ã€‚
use std::collections::HashMap;
// å¯¼å…¥ lazy_static å®ï¼Œç”¨äºåˆ›å»ºé™æ€å˜é‡ã€‚
use lazy_static::lazy_static;

// å®šä¹‰ä¸€ä¸ªåä¸º `create_map` çš„å®ï¼Œå®ƒæ¥å—ä¸€ç³»åˆ—é”®å€¼å¯¹ï¼Œå¹¶åœ¨å±•å¼€æ—¶åˆ›å»ºä¸€ä¸ªåŒ…å«è¿™äº›é”®å€¼å¯¹çš„ HashMapã€‚
// å®ä½¿ç”¨äº†åŒ¹é…è¡¨è¾¾å¼ (`$key:expr => $value:expr`) æ¥æ•è·é”®å€¼å¯¹ï¼Œå¹¶ä½¿ç”¨é‡å¤æ¨¡å¼ (`$()*`) æ¥æ’å…¥æ¯ä¸ªé”®å€¼å¯¹åˆ° HashMapã€‚
macro_rules! create_map {
    // æ¥å—ä¸€ç³»åˆ—é”®å€¼å¯¹ï¼Œæ¯ä¸ªé”®å€¼å¯¹ä»¥ `$key:expr => $value:expr` çš„å½¢å¼ç»™å‡ºã€‚
    // æœ€åä¸€ä¸ªé”®å€¼å¯¹åé¢å¯ä»¥æœ‰ä¸€ä¸ªå¯é€‰çš„é€—å·ã€‚
    ( $($key:expr => $value:expr),* $(,)? ) => {{
        // åˆ›å»ºä¸€ä¸ªæ–°çš„ HashMapã€‚
        let mut map = HashMap::new();
        // ä½¿ç”¨é‡å¤æ¨¡å¼ï¼Œå¯¹æ¯ä¸€ä¸ªé”®å€¼å¯¹æ‰§è¡Œä»¥ä¸‹ä»£ç ã€‚
        $(
            // å°†æ¯ä¸ªé”®å€¼å¯¹æ’å…¥åˆ° HashMap ä¸­ã€‚
            map.insert($key, $value);
        )*
        // è¿”å›å¡«å……å¥½çš„ HashMapã€‚
        map
    }};
}

fn main() {
    // ä½¿ç”¨ lazy_static å®åˆ›å»ºä¸€ä¸ªåä¸º `FRUITS` çš„é™æ€ HashMapã€‚
    // è¿™é‡Œæˆ‘ä»¬ä½¿ç”¨ `create_map!` å®æ¥åˆå§‹åŒ– HashMapã€‚
    lazy_static! {
        static ref FRUITS: HashMap<&'static str, u32> = create_map! {
            "apple" => 1,
            "banana" => 2,
            "orange" => 3,
            "peach" => 4,
        };
    }

    // æ‰“å° FRUITS çš„å†…å®¹ã€‚æ³¨æ„ï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨ *FRUITS æ¥è§£å¼•ç”¨ FRUITSã€‚
    println!("{:?}", *FRUITS);
}
```

å£°æ˜å®çš„ä¸€å¤§ç‰¹å¾æ˜¯ Token çš„åŒ¹é…ï¼ŒToken æœ‰å¤šç§ï¼Œå¦‚ä¸‹ï¼Œç›¸å½“äºå®çš„å…³é”®å­—ï¼Œåœ¨å®é™…ä»£ç ä¸­ï¼Œå°¤å…¶æ¶‰åŠåˆ°é‡å¤æ¨¡å¼æ—¶ï¼Œå¯ä»¥è€ƒè™‘ç”¨å£°æ˜å®æ¥æ¶ˆé™¤æ ·æ¿ä»£ç 

```bash
$name:identï¼šæ ‡è¯†ç¬¦ï¼ˆidentifierï¼‰ï¼Œå¦‚å˜é‡åã€å‡½æ•°åç­‰ã€‚ä¾‹å¦‚ï¼š$func_name:identã€‚
$e:exprï¼šè¡¨è¾¾å¼ï¼ˆexpressionï¼‰ï¼Œå¦‚ 1 + 2ã€my_var ç­‰ã€‚ä¾‹å¦‚ï¼š$my_expression:exprã€‚
$t:tyï¼šç±»å‹ï¼ˆtypeï¼‰ï¼Œå¦‚ i32ã€Stringã€Vec<T> ç­‰ã€‚ä¾‹å¦‚ï¼š$my_type:tyã€‚
$p:patï¼šæ¨¡å¼ï¼ˆpatternï¼‰ï¼Œå¦‚ç”¨äºåŒ¹é…çš„å­—é¢é‡ã€å˜é‡ã€é€šé…ç¬¦ç­‰ã€‚ä¾‹å¦‚ï¼š$my_pattern:patã€‚
$s:stmtï¼šè¯­å¥ï¼ˆstatementï¼‰ï¼Œå¦‚èµ‹å€¼è¯­å¥ã€å‡½æ•°è°ƒç”¨ç­‰ã€‚ä¾‹å¦‚ï¼š$my_statement:stmtã€‚
$b:blockï¼šä»£ç å—ï¼ˆblockï¼‰ï¼Œç”±ä¸€å¯¹å¤§æ‹¬å·åŒ…å›´çš„ä¸€ç³»åˆ—è¯­å¥ã€‚ä¾‹å¦‚ï¼š$my_block:blockã€‚
$m:metaï¼šå…ƒæ•°æ®ï¼ˆmetadataï¼‰ï¼Œå¦‚å±æ€§ï¼ˆattributeï¼‰ä¸­çš„å…ƒæ•°æ®ã€‚ä¾‹å¦‚ï¼š$my_metadata:metaã€‚
$i:itemï¼šé¡¹ï¼ˆitemï¼‰ï¼Œå¦‚å‡½æ•°ã€ç»“æ„ä½“ã€æšä¸¾ç­‰é¡¶çº§å®šä¹‰ã€‚ä¾‹å¦‚ï¼š$my_item:itemã€‚
$v:visï¼šå¯è§æ€§ï¼ˆvisibilityï¼‰ï¼Œå¦‚ pub å…³é”®å­—ã€‚ä¾‹å¦‚ï¼š$my_visibility:visã€‚
$l:lifetimeï¼šç”Ÿå‘½å‘¨æœŸï¼ˆlifetimeï¼‰ï¼Œå¦‚ç”Ÿå‘½å‘¨æœŸå‚æ•° 'aã€‚ä¾‹å¦‚ï¼š$my_lifetime:lifetimeã€‚
$tt:ttï¼šå•ä¸ªè¯­æ³•æ ‘ï¼ˆtoken treeï¼‰ï¼Œå¯ä»¥åŒ¹é…ä»»ä½•å•ä¸ª tokenã€‚ä¾‹å¦‚ï¼š$my_token_tree:ttã€‚
```

### 6.1.3 è¿‡ç¨‹å®

è¿‡ç¨‹å®å¯ä»¥åˆ†ä¸ºä¸‰ç§ç±»å‹ï¼šè‡ªå®šä¹‰æ´¾ç”Ÿï¼ˆcustom deriveï¼‰ã€å±æ€§å®ï¼ˆattribute macrosï¼‰å’Œå‡½æ•°å®ï¼ˆfunction-like macrosï¼‰ã€‚å®ƒä»¬çš„åŸç†å¦‚ä¸‹ï¼š

1. è‡ªå®šä¹‰æ´¾ç”Ÿï¼ˆCustom Deriveï¼‰ï¼š

è‡ªå®šä¹‰æ´¾ç”Ÿå…è®¸ä½ ä¸ºè‡ªå®šä¹‰æ•°æ®ç±»å‹è‡ªåŠ¨å®ç°æŸä¸ª traitã€‚å½“ä½ åœ¨æ•°æ®ç±»å‹ä¸Šä½¿ç”¨ `#[derive(MyTrait)]` æ—¶ï¼Œç¼–è¯‘å™¨ä¼šè°ƒç”¨å®ç°äº† `MyTrait` è‡ªå®šä¹‰æ´¾ç”Ÿçš„è¿‡ç¨‹å®ã€‚è¯¥è¿‡ç¨‹å®å°†æ¥æ”¶è¾“å…¥ç±»å‹çš„å®šä¹‰ï¼Œç„¶åç”Ÿæˆè¯¥ç±»å‹æ‰€éœ€çš„ trait å®ç°ã€‚

è‡ªå®šä¹‰æ´¾ç”Ÿå®éœ€è¦ä½¿ç”¨ `#[proc_macro_derive]` å±æ€§è¿›è¡Œæ ‡è®°ï¼Œå®ƒä»¬çš„è¾“å…¥æ˜¯ `syn::DeriveInput` ç±»å‹ï¼Œè¾“å‡ºæ˜¯ `proc_macro::TokenStream` ç±»å‹ã€‚

å£°æ˜å®ä¸€èˆ¬å®šä¹‰åœ¨é¡¹ç›®çš„æŸä¸ªæ–‡ä»¶ä¸­ï¼Œä½†æ˜¯æ´¾ç”Ÿå®ä¸€èˆ¬éƒ½æ˜¯å®šä¹‰åœ¨ä¸€ä¸ªç‹¬ç«‹çš„åŒ…ä¸­ï¼Œç„¶åå¼•å…¥ä½¿ç”¨

```
cargo new derive-macro --lib # åˆ›å»ºä¸€ä¸ªç‹¬ç«‹çš„package
```

```bash
# åœ¨Cargo.tomlä¸­å†™å…¥å¿…å¤‡çš„ä¾èµ–
[dependencies]
syn = "1.0"
quote = "1.0"
proc-macro2 = "1.0"

[lib]
proc-macro = true
```

```rust
// åœ¨lib.rsä¸­ç¼–å†™å®ä»£ç 

// å¯¼å…¥æ‰€éœ€åº“
extern crate proc_macro;
use proc_macro::TokenStream;
use quote::quote;
use syn::{parse_macro_input, DeriveInput};

// ä½¿ç”¨ proc_macro_derive å±æ€§æ ‡è®°è‡ªå®šä¹‰æ´¾ç”Ÿå®ï¼Œå¹¶å°†å®å‘½åä¸º simple_debug_deriveã€‚
#[proc_macro_derive(SimpleDebug)]
pub fn simple_debug_derive(input: TokenStream) -> TokenStream {
    // å°†è¾“å…¥çš„ TokenStream è§£æä¸º DeriveInput ç»“æ„ä½“ã€‚
    let input_ast = parse_macro_input!(input as DeriveInput);
    // ä» DeriveInput ç»“æ„ä½“ä¸­æå–ç±»å‹çš„åç§°ã€‚
    let name = &input_ast.ident;

    // ä½¿ç”¨ quote å®æ„é€ å®ç° SimpleDebug çš„ä»£ç ã€‚
    let expanded = quote! {
        // ä¸ºæŒ‡å®šç±»å‹å®ç° std::fmt::Debug traitã€‚
        impl std::fmt::Debug for #name {
            // å®ç° fmt æ–¹æ³•ã€‚
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                // ä½¿ç”¨ write! å®å°†ç±»å‹åç§°å†™å…¥ Formatterã€‚
                write!(f, "Instance of {}", stringify!(#name))
            }
        }
    };

    // å°†ç”Ÿæˆçš„ä»£ç è½¬æ¢ä¸º TokenStream å¹¶è¿”å›ã€‚
    expanded.into()
}
```

```bash
# åœ¨å…¶å®ƒåŒ…ä¸­å¼•å¦‚å®šä¹‰å¥½çš„åŒ…
[dependencies]
derive-macro = { path = "../derive-macro" }
```

```rust
// æ­£å¸¸ä½¿ç”¨å³å¯
use derive_macro::SimpleDebug;

// é€šè¿‡ #[derive(SimpleDebug)] è¯­æ³•åº”ç”¨è‡ªå®šä¹‰æ´¾ç”Ÿå®
#[derive(SimpleDebug)]
struct TestStruct;

fn main() {
    let test_instance = TestStruct;
    // è°ƒç”¨ Debug trait çš„å®ç°
    println!("{:?}", test_instance);
}
```

2. å±æ€§å®ï¼ˆAttribute Macrosï¼‰ï¼š

å±æ€§å®ç±»ä¼¼äºç¼–è¯‘å™¨æ³¨è§£ï¼Œå¯ä»¥åº”ç”¨äºé¡¹ï¼ˆå¦‚å‡½æ•°ã€ç»“æ„ä½“ã€æ¨¡å—ç­‰ï¼‰ã€‚å±æ€§å®æ¥æ”¶è¢«æ³¨è§£çš„é¡¹çš„å®šä¹‰ï¼Œç„¶åå¯ä»¥æ ¹æ®éœ€è¦ä¿®æ”¹æˆ–æ‰©å±•è¿™äº›é¡¹çš„è¡Œä¸ºã€‚å±æ€§å®ä½¿ç”¨ `#[proc_macro_attribute]` å±æ€§è¿›è¡Œæ ‡è®°ï¼Œè¾“å…¥ä¸º `proc_macro::TokenStream`ï¼ˆè¡¨ç¤ºå±æ€§å‚æ•°ï¼‰å’Œ `syn::Item`ï¼ˆè¡¨ç¤ºè¢«æ³¨è§£çš„é¡¹ï¼‰ï¼Œè¾“å‡ºä¹Ÿæ˜¯ `proc_macro::TokenStream` ç±»å‹ã€‚

3. å‡½æ•°å®ï¼ˆFunction-like Macrosï¼‰ï¼š

å‡½æ•°å®çœ‹èµ·æ¥åƒå‡½æ•°è°ƒç”¨ï¼Œä½†åœ¨ç¼–è¯‘æ—¶å±•å¼€ã€‚è¿™ç±»å®å¯ä»¥ç”¨äºç”Ÿæˆä»£ç ã€å®ç°ç¼–è¯‘æ—¶è®¡ç®—ç­‰ã€‚å‡½æ•°å®ä½¿ç”¨ `#[proc_macro]` å±æ€§è¿›è¡Œæ ‡è®°ï¼Œè¾“å…¥å’Œè¾“å‡ºéƒ½æ˜¯ `proc_macro::TokenStream` ç±»å‹ã€‚

ä¸ºäº†ç¼–å†™è¿‡ç¨‹å®ï¼Œé€šå¸¸éœ€è¦ä½¿ç”¨ `proc_macro`ã€`syn` å’Œ `quote` è¿™ä¸‰ä¸ªåº“ã€‚`proc_macro` æ˜¯ Rust æ ‡å‡†åº“çš„ä¸€éƒ¨åˆ†ï¼Œç”¨äºå¤„ç†è¿‡ç¨‹å®çš„è¾“å…¥å’Œè¾“å‡ºï¼›`syn` åº“ç”¨äºè§£æ Rust ä»£ç ï¼›`quote` åº“ç”¨äºç”Ÿæˆ Rust ä»£ç 

## 6.2 Unsafe Rust

### 6.2.1 Unsafe Rust ä»‹ç»

Rust çš„è®¾è®¡åˆè¡·æ˜¯æä¾›å†…å­˜å®‰å…¨æ€§å’Œçº¿ç¨‹å®‰å…¨æ€§ï¼Œå› æ­¤å…¶ç¼–è¯‘å™¨ä¼šåœ¨ç¼–è¯‘æ—¶æ£€æŸ¥å¾ˆå¤šæ½œåœ¨çš„å†…å­˜å’Œçº¿ç¨‹å®‰å…¨é—®é¢˜ã€‚ç„¶è€Œï¼Œåœ¨æŸäº›æƒ…å†µä¸‹ï¼Œç¼–ç¨‹è€…éœ€è¦æ‰§è¡Œç¼–è¯‘å™¨é»˜è®¤ä¸å…è®¸çš„æ“ä½œï¼Œå¦‚ç›´æ¥æ“ä½œå†…å­˜æˆ–è°ƒç”¨ä¸å®‰å…¨çš„å¤–éƒ¨å‡½æ•°ã€‚åœ¨è¿™ç§æƒ…å†µä¸‹ï¼ŒUnsafe Rust æä¾›äº†ä¸€ç§é€”å¾„ï¼Œè®©ç¨‹åºå‘˜èƒ½å¤Ÿæ˜ç¡®åœ°æ‰§è¡Œè¿™äº›æ“ä½œ

è¦ä½¿ç”¨ Unsafe Rustï¼Œéœ€è¦åœ¨ä»£ç å—ä¸­ä½¿ç”¨ `unsafe` å…³é”®å­—ã€‚åœ¨è¿™ä¸ª `unsafe` ä»£ç å—å†…ï¼Œä½ å¯ä»¥æ‰§è¡Œä»¥ä¸‹æ“ä½œï¼š

1. è§£å¼•ç”¨è£¸æŒ‡é’ˆï¼ˆraw pointersï¼‰ï¼šè£¸æŒ‡é’ˆæ˜¯ä¸€ç§æ²¡æœ‰ Rust ç¼–è¯‘å™¨æ£€æŸ¥çš„æŒ‡é’ˆï¼Œç±»ä¼¼äº C è¯­è¨€ä¸­çš„æŒ‡é’ˆã€‚è£¸æŒ‡é’ˆåˆ†ä¸ºä¸¤ç±»ï¼šä¸å¯å˜çš„ `*const T` å’Œå¯å˜çš„ `*mut T`ã€‚
2. è°ƒç”¨ä¸å®‰å…¨çš„å‡½æ•°æˆ–æ–¹æ³•ï¼šè¿™äº›å‡½æ•°æˆ–æ–¹æ³•éœ€è¦åœ¨å…¶ç­¾åä¸­ä½¿ç”¨ `unsafe` å…³é”®å­—ã€‚é€šå¸¸ï¼Œä¸å®‰å…¨çš„å‡½æ•°æˆ–æ–¹æ³•æ‰§è¡Œäº†ç¼–è¯‘å™¨æ— æ³•éªŒè¯çš„æ“ä½œï¼Œå¦‚è°ƒç”¨åº•å±‚ç³»ç»Ÿ API æˆ–ç›´æ¥ä¿®æ”¹å†…å­˜ã€‚
3. è®¿é—®æˆ–ä¿®æ”¹å¯å˜é™æ€å˜é‡ï¼šRust ä¸­çš„é™æ€å˜é‡å…·æœ‰å›ºå®šçš„å†…å­˜åœ°å€ï¼Œå®ƒä»¬åœ¨æ•´ä¸ªç¨‹åºæ‰§è¡ŒæœŸé—´éƒ½æ˜¯æœ‰æ•ˆçš„ã€‚å¯å˜é™æ€å˜é‡å¯èƒ½å¯¼è‡´æ•°æ®ç«äº‰ï¼Œå› æ­¤è®¿é—®æˆ–ä¿®æ”¹å®ƒä»¬éœ€è¦åœ¨ `unsafe` ä»£ç å—ä¸­è¿›è¡Œã€‚
4. å®ç°ä¸å®‰å…¨çš„ traitï¼šè¿™äº› trait éœ€è¦åœ¨å…¶å®šä¹‰ä¸­ä½¿ç”¨ `unsafe` å…³é”®å­—ã€‚å®ç°ä¸å®‰å…¨çš„ trait é€šå¸¸è¡¨ç¤ºå®ƒä»¬éœ€è¦æ»¡è¶³æŸäº›ç¼–è¯‘å™¨æ— æ³•éªŒè¯çš„çº¦æŸã€‚

ä½¿ç”¨ Unsafe Rust æ—¶éœ€è¦ç‰¹åˆ«å°å¿ƒï¼Œå› ä¸ºå®ƒå¯èƒ½å¯¼è‡´å†…å­˜å®‰å…¨é—®é¢˜å’Œæœªå®šä¹‰è¡Œä¸ºã€‚åœ¨ç¼–å†™ Unsafe Rust ä»£ç æ—¶ï¼Œç¨‹åºå‘˜éœ€è¦ç¡®ä¿ä»£ç ç¬¦åˆ Rust çš„å®‰å…¨æ€§çº¦æŸã€‚å°½é‡å°†ä¸å®‰å…¨çš„ä»£ç å°è£…åœ¨å®‰å…¨çš„æŠ½è±¡ä¸­ï¼Œä»¥ä¾¿åœ¨ç¨‹åºçš„å…¶ä»–éƒ¨åˆ†ä½¿ç”¨å®‰å…¨çš„æ¥å£

### 6.2.2 Unsafe Rust ç¼–ç¨‹

ä¸‹é¢æ˜¯ Unsafe Rust ä¸­æ¯ç§æƒ…å†µçš„ä»£ç ç¤ºä¾‹ï¼š

1. è§£å¼•ç”¨è£¸æŒ‡é’ˆ

```rust

fn main() {
    let x = 10;
    let y = &x as *const i32;
    let z = 0x12345678 as *const i32; // å‡è®¾è¿™æ˜¯ä¸€ä¸ªæ— æ•ˆçš„å†…å­˜åœ°å€

    unsafe {
        println!("Value of x: {}", *y); // è¾“å‡º "Value of x: 10"
        // println!("Value at address 0x12345678: {}", *z); // ä¸å®‰å…¨ï¼å¯èƒ½å¯¼è‡´æœªå®šä¹‰è¡Œä¸º
    }
}
```

2. è°ƒç”¨ä¸å®‰å…¨çš„å‡½æ•°æˆ–æ–¹æ³•ï¼š

```rust

unsafe fn unsafe_function() {
    // æ‰§è¡Œä¸å®‰å…¨çš„æ“ä½œï¼Œå¦‚ç›´æ¥æ“ä½œå†…å­˜æˆ–è°ƒç”¨åº•å±‚ç³»ç»Ÿ API
}

fn main() {
    unsafe {
        unsafe_function(); // è°ƒç”¨ä¸å®‰å…¨å‡½æ•°
    }
}
```

3. è®¿é—®æˆ–ä¿®æ”¹å¯å˜é™æ€å˜é‡ï¼š

```rust

static mut COUNTER: i32 = 0;

fn increment_counter() {
    unsafe {
        COUNTER += 1;
    }
}

fn main() {
    increment_counter();
    unsafe {
        println!("Counter value: {}", COUNTER); // è¾“å‡º "Counter value: 1"
    }
}
```

4. å®ç°ä¸å®‰å…¨çš„ traitï¼š

```rust

unsafe trait UnsafeTrait {
    unsafe fn unsafe_method(&self);
}

struct MyStruct {
    value: i32,
}

unsafe impl UnsafeTrait for MyStruct {
    unsafe fn unsafe_method(&self) {
        let mut raw_ptr = self as *const Self as *mut Self;
        (*raw_ptr).value = 42;
    }
}

fn main() {
    let my_struct = MyStruct { value: 10 };

    unsafe {
        my_struct.unsafe_method();
    }
}
```

## 6.3 è¯¾åä¹ é¢˜

1. å°è¯•ç¼–å†™ä¸€ä¸ªå£°æ˜å®å’Œä¸€ä¸ªè¿‡ç¨‹å®ï¼Œä½“éªŒå®ƒä»¬çš„å¼‚åŒ
2. ç»“åˆä½ è¿‡å»çš„ç¼–ç ç»éªŒï¼Œä½ æ˜¯æ€ä¹ˆç†è§£ Rust ä¸­çš„ä¸å®‰å…¨é—®é¢˜çš„ï¼Œå®‰å…¨é—®é¢˜æœ‰è¢«æ‰©å¤§å—ï¼Ÿ
