# 	æ–‡æ¡£è¯´æ˜

æœ¬æ–‡æ¡£çš„è¡Œæ–‡é€»è¾‘ï¼šå…ˆä»‹ç»ä¸€äº›åŸºç¡€çŸ¥è¯†ï¼Œç„¶åå†å±‚å±‚é€’è¿›ã€‚ åŸåˆ™æ˜¯å°½é‡ä¸åœ¨å‰é¢å†…å®¹ä¸­å¼•å…¥æ¯”è¾ƒé«˜é˜¶çš„çŸ¥è¯†ç‚¹ã€‚ä½†è¿™æ ·æœ‰ä¸€ä¸ªåå¤„å°±æ˜¯ä¸€ä¸ªçŸ¥è¯†ç‚¹ä¸èƒ½ä¸€æ¬¡æ€§è®²é€ï¼Œæ¯”å¦‚å‡½æ•°ï¼Œåœ¨æ¨¡å—ä¸€åªä»‹ç»äº†å®ƒçš„å£°æ˜å’Œæ ·å¼ï¼Œåœ¨æ¨¡å—äºŒæ‰ä»‹ç»å‚æ•°å‚æ•°çš„ç”Ÿå‘½å‘¨æœŸã€è¿”å›å€¼ç±»å‹å’Œtraitï¼Œåœ¨æ¨¡å—ä¸‰è¿˜åœ¨ä»‹ç»å®ƒå’Œé—­åŒ…çš„å…³ç³»ç­‰ç­‰ã€‚è¿™æ ·çš„å–èˆæ˜¯ä¸ºäº†ä¸å†å‰é¢å°±å¼•å…¥åé¢çš„å†…å®¹ï¼Œå¢åŠ ç†è§£éš¾åº¦ï¼Œä½†æ˜¯æœ¬è´¨ä¸ŠRustè¯­è¨€çš„å„ç§ç‰¹æ€§éƒ½æ˜¯æ·±åº¦åµŒåˆåœ¨ä¸€èµ·çš„ã€‚åœ¨å­¦ä¹ æ—¶è¯»è€…å¯ä»¥æ ¹æ®è‡ªå·±çš„ä¸ªäººå’Œä¹ æƒ¯å­¦ä¹ ï¼Œä½ å¯ä»¥ä¸€æ¬¡ææ¸…æ¥šæŸä¸ªçŸ¥è¯†ç‚¹çš„æ‰€æœ‰æƒ…å†µï¼Œä¹Ÿå¯ä»¥å…ˆææ˜ç™½ä¸€ç‚¹ï¼Œåé¢å†ä¸æ–­è¡¥å……å’Œå®Œå–„

æœ¬æ–‡æ¡£çš„çŸ¥è¯†æ·±åº¦ï¼šæ€»ä½“è€Œè¨€ï¼Œæœ¬æ–‡æ¡£ä¸»è¦æ˜¯ä»åº”ç”¨å‡ºå‘ä»‹ç»Rustçš„å„ä¸ªçŸ¥è¯†ç‚¹ï¼Œå¯¹æ ¸å¿ƒåŸç†æ²¡æœ‰åšè¿‡å¤šçš„æ·±å…¥ä»‹ç»ï¼Œå¸Œæœ›æ·±å…¥çš„æœ‹å‹å¯ä»¥å‚é˜…å…¶ä»–èµ„æ–™

æœ¬æ–‡æ¡£çš„æ‰©å±•èµ„æ–™ï¼šä¸ºäº†ç…§é¡¾åˆ°éƒ¨åˆ†æœ‹å‹è§‰å¾—å‰æœŸå¤ªå°‘æˆ–è€…ä¸å¤Ÿæ·±å…¥ï¼Œæ‰€ä»¥åˆ—å‡ºäº†æ‰©å±•èµ„æ–™ï¼Œæœ‰å…´è¶£çš„æœ‹å‹å¯ä»¥æ·±å…¥é˜…è¯»

# æ¨¡å—ä¸€ï¼šåˆè¯†Rust

## 1 .1 å®‰è£…Rust

#### 1.1.1 å®‰è£…Rust

`rustup`æ˜¯ä¸€ä¸ªç®¡ç†Rustç‰ˆæœ¬ä»¥åŠç›¸å…³å·¥å…·çš„å‘½ä»¤è¡Œå·¥å…·ï¼Œä½ å¯ä»¥é€šè¿‡å®ƒæ¥å®‰è£…Rustå¼€å‘ç¯å¢ƒ

[åœ¨ Linux æˆ– macOS ä¸Šå®‰è£… `rustup`](https://rustwiki.org/zh-CN/book/ch01-01-installation.html#åœ¨-linux-æˆ–-macos-ä¸Šå®‰è£…-rustup)

[åœ¨ Windows ä¸Šå®‰è£… `rustup`](https://rustwiki.org/zh-CN/book/ch01-01-installation.html#åœ¨-windows-ä¸Šå®‰è£…-rustup)

#### 1.1.2 æ›´æ–°å’Œå¸è½½

```
rustup update # æ›´æ–°
```

```
rustup self uninstall # å¸è½½
```

#### 1.1.3 rustc

rustc æ˜¯Rustçš„ç¼–è¯‘å™¨ï¼Œå¦‚ä¸‹æ˜¯ä¸€äº›ä½¿ç”¨æ¡ˆä¾‹ï¼š

**æŸ¥çœ‹Rustç‰ˆæœ¬**

```
rustc --version # æŸ¥çœ‹å·²å®‰è£…çš„Rustçš„ç‰ˆæœ¬
```

**ç¼–è¯‘Rustä»£ç **

ä½¿ç”¨rustcæ¥ç›´æ¥ç¼–è¯‘ä»£ç ä¸ºäºŒè¿›åˆ¶ç¨‹åºï¼Œç„¶åè¿è¡Œï¼Œä¾‹å¦‚ï¼š

```
mkdir module-one # éšä¾¿åˆ›å»ºä¸€ä¸ªæ–‡ä»¶å¤¹
cd module-one 
touch main.rs # éšä¾¿åˆ›å»ºä¸€ä¸ª.rsç»“å°¾çš„æ–‡ä»¶
```

rust-co-learn/module-one/main.rs

```
// å†™ä¸€ä¸ªç®€å•çš„mainå‡½æ•°
fn main() {
    println!("Hello Rust")
}
```

**ç¼–è¯‘å’Œè¿è¡Œ**

```
rustc main.rs
ls
main    main.rs # `main`ä¸ºç¼–è¯‘åçš„å¯æ‰§è¡Œç¨‹åº
./main # ä½¿ç”¨ `./filename` ç›´æ¥è¿è¡Œç¨‹åº
Hello Rust # è¾“å‡ºç»“æœ
```

**æ‰©å±•èµ„æ–™**

1. [å®˜æ–¹æ–‡æ¡£å…³äºrustcçš„ä»‹ç»](https://rustwiki.org/zh-CN/book/ch01-02-hello-world.html)

## 1.2 ä½¿ç”¨Cargo

`Cargo`æ˜¯ Rust çš„æ„å»ºç³»ç»Ÿå’ŒåŒ…ç®¡ç†å™¨,éå¸¸å¼ºå¤§ï¼Œç±»ä¼¼äºpythonçš„åŒ…ç®¡ç†å™¨pipã€‚å¯ä»¥ç”¨å®ƒæ¥åˆ›å»ºã€ç¼–è¯‘å’Œè¿è¡ŒRusté¡¹ç›®ã€‚ä»¥ä¸‹æ˜¯ä¸€ä¸ªä¾‹å­ï¼š

```
âœ  module-one git:(main) âœ— cargo new hello_rust --lib # åˆ›å»ºä¸€ä¸ª library crate
     Created library `hello_rust` package
âœ  module-one git:(main) âœ— cargo new hello_cargo --bin # åˆ›å»ºä¸€ä¸ª binary crate
     Created binary (application) `hello_cargo` package
âœ  module-one git:(main) âœ— ls
hello_cargo hello_rust
âœ  module-one git:(main) âœ— cd hello_cargo
âœ  hello_cargo git:(main) âœ— ls
Cargo.toml src
âœ  hello_cargo git:(main) âœ— cargo build --release # ç¼–è¯‘ï¼Œè¿™é‡Œä¸å†ä½¿ç”¨ rustc äº†
âœ  hello_cargo git:(main) âœ— cargo run # ç¼–è¯‘+è¿è¡Œ
Hello, world!
```

**æ‰©å±•èµ„æ–™**

1. [å®˜æ–¹æ–‡æ¡£ä¸­ä½¿ç”¨Cargoæ„å»ºé¡¹ç›®çš„è¯¦ç»†ä»‹ç»](https://rustwiki.org/zh-CN/book/ch01-03-hello-cargo.html)
2. [Cargo Bookï¼šCargoä½¿ç”¨å¤§å…¨](https://doc.rust-lang.org/cargo/)
3. [Rustä¸­çš„crateä¸é¡¹ç›®ç®¡ç†](https://zhuanlan.zhihu.com/p/614506900)

## 1.3 RuståŸºç¡€çŸ¥è¯†

### 1.3.1 å˜é‡å’Œå¯å˜æ€§

```
 // 1 å¸¸é‡
    // ä½¿ç”¨ const å£°æ˜; å¸¸é‡åç§°ä½¿ç”¨å¤§å†™å­—æ¯; æ˜¾å¼æ ‡æ³¨ç±»å‹

    const RUST: &str = "rust";
    const WEIGHT: u64 = 100;

    println!("{},{}",RUST,WEIGHT);

    // 2 å˜é‡
    // ä½¿ç”¨let å£°æ˜,å¤§å¤šæ•°æƒ…å†µä¸‹ï¼Œç¼–è¯‘å™¨å¯ä»¥æ ¹æ®ä¸Šä¸‹æ–‡æ¨æ–­å˜é‡ç±»å‹

    let name = "rust";
    let age: u32 = 13;

    println!("{},{}",name,age);

    // 3 ä¸å˜æ€§
    // Rustä¸­å˜é‡é»˜è®¤ä¸å¯å˜ï¼Œè‹¥éœ€ä¿®æ”¹å˜é‡ï¼Œéœ€è¦ä½¿ç”¨mutå…³é”®å­—å£°æ˜å˜é‡å…·æœ‰å¯å˜æ€§

    let _language = "go";
    // _language = "rust"; æ— æ³•ä¿®æ”¹

    // 4 å¯å˜æ€§
    // é€šè¿‡ mut å£°æ˜å˜é‡

    let mut language = "go";
    language = "rust";

    println!("{}", language);
```

**æ‰©å±•èµ„æ–™**

1. [å®˜æ–¹æ–‡æ¡£å…³äºå˜é‡é®è”½çš„ä»‹ç»](https://rustwiki.org/zh-CN/book/ch03-01-variables-and-mutability.html)
2. [é€šè¿‡å¯å˜å®¹å™¨è®©å˜é‡è·å¾—å¯å˜æ€§](https://zhuanlan.zhihu.com/p/611487702)

### 1.3.2 åŸºç¡€æ•°æ®ç±»å‹

Rustæ˜¯å¼ºç±»å‹è¯­è¨€ï¼Œæ¯ä¸ªå€¼éƒ½æœ‰ç¡®åˆ‡çš„ç±»å‹

#### æ ‡é‡ç±»å‹

```
 // 1 æ•´æ•°ç±»å‹

    // Rust ä¸­æ•´æ•°ç±»å‹åˆ†ä¸ºæœ‰ç¬¦å·å’Œæ— ç¬¦å·ç±»å‹ï¼›é•¿åº¦åˆ†ä¸º8ä½ï¼Œ16ä½ï¼Œ32ä½ï¼Œ64ä½ï¼Œ128ä½
    // ç‰¹æ®Šçš„æ•´æ•°ç±»å‹: usize å’Œ isizeï¼Œä¸ç³»ç»Ÿæ¶æ„ç›¸å…³ï¼Œ32ä½çš„ç³»ç»Ÿåˆ™ä¸º32ä½ï¼Œ64ä½çš„ç³»ç»Ÿä¸º64ä½

    let integer: i32 = 42;
    let s: usize = 100;

    // 2 æµ®ç‚¹ç±»å‹
    // Rust çš„æµ®ç‚¹å‹æ˜¯ f32 å’Œ f64ï¼Œå¤§å°åˆ†åˆ«ä¸º 32 ä½å’Œ 64 ä½ã€‚é»˜è®¤æµ®ç‚¹ç±»å‹æ˜¯ f64
    // æµ®ç‚¹å‹éƒ½æ˜¯æœ‰ç¬¦å·çš„

    let x = 2.0; // f64
    let y: f32 = 3.0; // f32

    // 3 å¸ƒå°”ç±»å‹

    let t = true;
    let f: bool = false;

    // 4 å­—ç¬¦ç±»å‹ char
    // Rust çš„å­—ç¬¦ç±»å‹å¤§å°ä¸º 4 ä¸ªå­—èŠ‚ï¼Œè¡¨ç¤ºçš„æ˜¯ä¸€ä¸ª Unicode æ ‡é‡å€¼

    let c = 'z';
    let z = 'â„¤';
    let heart_eyed_cat = 'ğŸ˜»';
```

**æ‰©å±•èµ„æ–™**

1. [Rustå®˜æ–¹æ–‡æ¡£å…³äºåŸºç¡€ç±»å‹çš„è¯¦ç»†ä»‹ç»](https://rustwiki.org/zh-CN/book/ch03-02-data-types.html)

#### å¤åˆç±»å‹

Rustä¸­çš„å¤åˆç±»å‹ä¸»è¦æœ‰å…ƒç»„å’Œæ•°ç»„

```
 // 1 å…ƒç»„
    // Rustä¸­çš„å…ƒç»„å¯ä»¥å°†å„ç§ç±»å‹ç»„åˆèµ·æ¥
    let types = (42, "Rust", true);

    // å¯ä»¥é€šè¿‡ä¸‹æ ‡ç´¢å¼•è®¿é—®
    println!("num is {}", types.0);

    // å•å…ƒç±»å‹ ï¼ˆï¼‰
    // å•å…ƒç±»å‹åœ¨Rustä¸­æ˜¯éå¸¸é‡è¦çš„ç±»å‹ï¼Œå¦‚æœè¡¨è¾¾å¼ä¸è¿”å›ä»»ä½•å…¶ä»–å€¼ï¼Œå°±éšå¼åœ°è¿”å›å•å…ƒå€¼ï¼Œ
    // å¦‚æ²¡æœ‰è¿”å›å€¼çš„å‡½æ•°æˆ–è€…ä½œç”¨åŸŸ

    let a: () = {};
    fn return_tuple() {}
    let func: () = return_tuple();
    assert_eq!(a, func);

    // 2 æ•°ç»„
    // é€šè¿‡ç´¢å¼•æ¥è®¿é—®æˆ–è€…ä¿®æ”¹æ•°ç»„ä¸­çš„å…ƒç´ 

    let arr = [1, 2, 3, 4, 5];

    let mut arr1 = [0, 0, 0, 0, 0];
    arr1[0] = 100;
    println!("{:?}", arr1); // [100, 0, 0, 0, 0]
```

**æ‰©å±•èµ„æ–™**

1. [å®˜æ–¹æ–‡æ¡£ä¸­å…³äºå¤åˆç±»å‹çš„ä»‹ç»](https://rustwiki.org/zh-CN/book/ch03-02-data-types.html)
2. [å…³äºRustä¸­ç±»å‹ä¸è¡¨è¾¾å¼çš„è¯¦ç»†ä»‹ç»ï¼Œæ­¤è¯¾ç¨‹ä¸ºä»˜è´¹è¯¾ç¨‹ï¼Œä½†æ˜¯å¼ºçƒˆæ¨è](https://time.geekbang.org/course/detail/100060601-289993)

### 1.3.3 è¿›é˜¶æ•°æ®ç±»å‹

#### å­—ç¬¦ä¸²

Rustä¸­çš„å­—ç¬¦ä¸²æ¯”è¾ƒå¤æ‚ï¼Œæœ‰å¤šç§å½¢å¼ï¼Œé€‚ç”¨äºä¸åŒçš„åœºæ™¯ã€‚æ ¸å¿ƒæ˜¯éœ€è¦æŒæ¡&strå’ŒString

Ruståœ¨ç¼–è¯‘ä»£ç æ—¶éœ€è¦åœ¨ç¼–è¯‘æœŸå°±èƒ½å¤Ÿç¡®å®šç±»å‹çš„å¤§å°ï¼Œè€Œå­—ç¬¦ä¸²stræœ¬èº«æ˜¯åŠ¨æ€å¤§å°çš„ï¼Œå› è€Œæ—¥å¸¸ä¸­æˆ‘ä»¬æ›´å¤šä½¿ç”¨çš„æ˜¯å­—ç¬¦ä¸²çš„å¼•ç”¨&strå’ŒString

```
   // 1 &str
    // å­—ç¬¦ä¸²å­—é¢é‡å®é™…ä¸Šå­˜æ”¾åœ¨ç¨‹åºçš„åªè¯»æ•°æ®æ®µä¸­ï¼Œåœ¨ç¨‹åºè¿è¡Œæ—¶ä¼šè¢«åŠ è½½åˆ°å†…å­˜ä¸­è¯»å–
    let s = "Hello Rust";
    let mut s1 = "Hello Go";

    s1 = "Hello Rust";
    println!("{}", s1);

    // 2 String
    // String é€šè¿‡æŒ‡é’ˆæŒ‡å‘å­˜æ”¾åœ¨å †ä¸Šçš„å­—ç¬¦ä¸²

    let s2 = String::from("Hello Rust");

    // String æœ‰ä¸‰ä¸ªwordï¼šptrã€lenã€cap,å¯ä»¥ç›´æ¥é€šè¿‡æ–¹æ³•è®¿é—®

    let cap = s2.capacity();
    let len = s2.len();
    let ptr = s2.as_ptr();

    println!("len {}", len);
    println!("cap {}", cap);
    println!("pointer {:?}", ptr);

    // 3 å­—ç¬¦ä¸²åˆ‡ç‰‡
    // å­—ç¬¦ä¸²æœ¬è´¨ä¸Šä¸€ä¸ªu8åºåˆ—ï¼Œæ”¯æŒåˆ‡ç‰‡æ“ä½œ

    let s1 = String::from("Hello Rust");
    let s2 = "Hello Rust";

    let slice1 = &s1[0..5];
    let slice2 = &s2[6..10];

    println!("slice1: {}", slice1); // Hello
    println!("slice2: {}", slice2); // Rust
```

**æ‰©å±•èµ„æ–™**

1. [å®˜æ–¹æ–‡æ¡£ä¸­å…³äºå­—ç¬¦ä¸²çš„æ›´å¤šè§£é‡Š](https://rustwiki.org/zh-CN/book/ch08-02-strings.html)
2. [ä¸€äº›å­—ç¬¦ä¸²ç»ƒä¹ çš„å°ä¾‹å­](https://github.com/rust-lang-cn/rustlings-cn/tree/main/exercises/strings)
3. [å®˜æ–¹æ–‡æ¡£ä¸­å…³äºåˆ‡ç‰‡çš„æ›´å¤šå†…å®¹](https://rustwiki.org/zh-CN/book/ch04-03-slices.html)

#### å¼•ç”¨

Rustä¸­çš„å¼•ç”¨ç±»å‹æ˜¯ä¸€ç­‰å…¬æ°‘ï¼Œä»å¯å˜æ€§ä¸Šå¯ä»¥åˆ†ä¸ºå¯å˜å¼•ç”¨å’Œä¸å¯å˜å¼•ç”¨

```
// 1 ä¸å¯å˜å€Ÿç”¨
    let num = 42;
    let immutable_s = &num;

    // 2 ä¸å¯å˜å€Ÿç”¨
    let mut num = 42;
    let mutable_s = &mut num;

    // å½“ç±»å‹å ç”¨ç©ºé—´æ¯”è¾ƒå¤§æ—¶ï¼Œå¯ä»¥é€šè¿‡å¼•ç”¨æ¥è®¿é—®æˆ–è€…ä¿®æ”¹æ•°æ®,å°¤å…¶æ˜¯åœ¨ä¼ é€’æ•°æ®çš„åœºæ™¯ä¸‹

    let person_tuple = ("Rust", 13, true);

    let ptr = &person_tuple;
    println!("{}", ptr.0);

    let mut arr = ["Rust", "Go", "C++"];

    let arr_ptr = &mut arr;

    arr_ptr[2] = "Java";

    println!("{:?}", arr_ptr) // ["Rust", "Go", "Java"]
```

**æ‰©å±•èµ„æ–™**

1.[Rustä¸­å¼•ç”¨å’ŒæŒ‡é’ˆçš„åŒºåˆ«](https://zhuanlan.zhihu.com/p/614970269)

2.[å®˜æ–¹æ–‡æ¡£ä¸­å¯¹å¼•ç”¨çš„æ›´å¤šä»‹ç»](https://rustwiki.org/zh-CN/book/ch04-02-references-and-borrowing.html)

#### é›†åˆ

ä¸¤ä¸ªé‡è¦çš„é›†åˆVecå’ŒHashMapï¼Œè¿™é‡Œçš„é›†åˆæŒ‡çš„æ˜¯å®ƒä»¬éƒ½èšé›†äº†å¤šä¸ªåŒç±»å‹çš„å…ƒç´ 

```
 // 1 Vec
    // Vecæ˜¯åŠ¨æ€å¤§å°ï¼Œç›¸æ¯”èµ·æ•°ç»„æ¥è¯´ï¼Œå®ƒæ›´åŠ å¸¸ç”¨
    // Vecä¸­çš„å…ƒç´ å¿…é¡»ç›¸åŒ

    let mut vec1 = Vec::new();
    let mut vec2 = vec![];

    // vec æ”¯æŒä¸€ç³»åˆ—çš„æ“ä½œ

    // æ·»åŠ å…ƒç´ 
    vec1.push("Rust");
    vec2.push("Go");

    // å½“ä½œæ ˆ
    vec1.pop();

    // ä¿®æ”¹æ•°æ®
    vec2[0] = "Rust";

    // Vec å’Œ Stringä¸€æ ·ï¼Œæ•°æ®å­˜æ”¾åœ¨å †ä¸Š
    // æœ‰ä¸‰ä¸ªword

    println!("{}", vec2.len()); // 1
    println!("{}", vec2.capacity()); // 4
    println!("{:?}", vec2.as_ptr()); // 0x7fafc9f05b70

    // 2 HashMap

    // HashMapå¹¶ä¸æ˜¯é¢„å¯¼å…¥çš„ï¼Œéœ€è¦æ‰‹åŠ¨å¼•å…¥å½“å‰ä½œç”¨åŸŸ
    use std::collections::HashMap;

    // ä½¿ç”¨newæ–¹æ³•åˆ›å»º
    let mut scores = HashMap::new();

    // æ’å…¥æ•°æ®
    scores.insert(String::from("Blue"), 10);
    scores.insert(String::from("Yellow"), 50);

    // ä¿®æ”¹æ•°æ®,ä¿®æ”¹å’Œæ’å…¥æ•°æ®æ˜¯åŒä¸€ä¸ªapi
    scores.insert(String::from("Blue"), 100);

    // è®¿é—®æ•°æ®,æ³¨æ„è®¿é—®çš„keyä¼ é€’çš„æ˜¯å¼•ç”¨
    let key = String::from("Blue");
    println!("{:?}", scores[&key])
```

**æ‰©å±•èµ„æ–™**

1. [å®˜æ–¹æ–‡æ¡£ä¸­å¯¹é›†åˆçš„æ›´å¤šä»‹ç»](https://rustwiki.org/zh-CN/book/ch08-00-common-collections.html)

#### ç»“æ„ä½“

```
// 1 ç»“æ„ä½“
    // Rustä¸­çš„ç»“æ„ä½“æœ‰ä¸‰ç§

    // 1.1 å¸¸è§„ç»“æ„ä½“
    struct Language {
        name: String,
        birth: u32,
        is_popular: bool,
    }
    // 1.2 å…ƒç»„ç»“æ„ä½“
    struct Rust(String);
    // 1.3 å•å…ƒç»“æ„ä½“
    struct Go;

    // ä¸ºç»“æ„ä½“å®ç°æ–¹æ³•
    impl Rust {
        // Self ä»£è¡¨ç»“æ„ä½“æœ¬èº«
        fn new() -> Self {
            Rust(String::from("Rust"))
        }

        fn print() {
            let rust = Rust::new();
            println!("{:?}", rust.0)
        }
    }

    // æ–¹æ³•è°ƒç”¨
    let r = Rust::new();

    Rust::print();

    // è®¿é—®ç»“æ„ä½“æˆå‘˜
    println!("{:?}", r.0)
```

**æ‰©å±•èµ„æ–™**

1. [å®˜æ–¹æ–‡æ¡£å¯¹äºç»“æ„ä½“çš„ä»‹ç»](https://rustwiki.org/zh-CN/book/ch05-00-structs.html)

#### æšä¸¾

```
// æšä¸¾åœ¨å½¢å¼ä¸Šå’Œç»“æ„ä½“è¾ƒä¸ºç›¸ä¼¼
    enum Subject {
        Math,
        Chinese,
        English(String),
    }

    // åˆå§‹åŒ–
    let subject = Subject::English(String::from("English"));

    //æ ‡å‡†åº“ä¸­ä¸¤ä¸ªæ¯”è¾ƒé‡è¦çš„æšä¸¾ Optionå’Œ Result

    // Result ç”¨äºä¸€äº›å¤„æ“ä½œå¯èƒ½é‡åˆ°é”™è¯¯çš„åœºæ™¯ï¼Œæ¯”å¦‚æ‰“å¼€æ–‡ä»¶æ—¶ï¼Œå¦‚æœæˆåŠŸï¼Œè¿”å›æ–‡ä»¶ï¼Œé‡åˆ°é”™è¯¯æ—¶è¿”å›ä¸€ä¸ªError
    use std::fs::File;

    let file: Result<File, std::io::Error> = File::open("tmp.txt");

    // Option ç”¨äºä¸€äº›å€¼å¯èƒ½ä¸ºç©ºçš„æƒ…å†µ
    // å¦‚å°è¯•è·å–å“ˆå¸Œè¡¨ä¸­æŸä¸ªkeyæ‰€å¯¹åº”çš„valueï¼Œå½“å€¼å­˜åœ¨æ—¶ï¼Œè¿”å›å€¼ï¼Œå½“ä¸å­˜åœ¨æ—¶è¿”å›None

    use std::collections::HashMap;

    let map: HashMap<&str, u32> = HashMap::new();
    let v: Option<&u32> = map.get("rust");
```

**æ‰©å±•èµ„æ–™**

1. [å®˜æ–¹æ–‡æ¡£ä¸­å¯¹äºæšä¸¾çš„ä»‹ç»](https://rustwiki.org/zh-CN/book/ch06-01-defining-an-enum.html)

#### å‡½æ•°

```
 // 1 å‡½æ•°å®šä¹‰

    // æ²¡æœ‰å‚æ•°å’Œè¿”å›å€¼
    fn foo() {
        println!("foo")
    }

    // æœ‰å‚æ•°å’Œè¿”å›å€¼

    fn bar(s: &str) -> String {
        String::from(s)
    }

    // å‚æ•°ç±»å‹å¿…é¡»æ˜¾å¼å£°æ˜ï¼Œæ¯”å¦‚å¼•ç”¨æˆ–è€…å¯å˜æ€§

    fn foobar(mut s: &str) -> &str {
        s = "rust";
        s
    }

    // 2 å‡½æ•°è°ƒç”¨

    foo();
    bar("Rust");
    foobar("go");

    // 3 å‡½æ•°ä½œä¸ºå‚æ•°

    fn a(f: fn() -> u32) -> u32 {
        let value = f();

        value
    }

    fn b() -> u32 {
        42
    }

    // æŠŠå‡½æ•°ä½œä¸ºå‚ä¼ ç»™å¦ä¸€ä¸ªå‡½æ•°

    a(b);
```

**æ‰©å±•èµ„æ–™**

1.[å®˜æ–¹æ–‡æ¡£ä¸­å…³äºå‡½æ•°çš„ä»‹ç»](https://rustwiki.org/zh-CN/book/ch03-03-how-functions-work.html)

#### é—­åŒ…

```
// 1 é—­åŒ…å®šä¹‰

    // é—­åŒ…å¯ä»¥æ•è·ç¯å¢ƒå˜é‡,å¹¶ä¸”æ ¹æ®å…¶å¯¹ç¯å¢ƒå˜é‡çš„æ“ä½œå¯ä»¥åˆ†ä¸ºä»¥ä¸‹ä¸‰ç±»

    let c1 = || print!("æœªæ•è·ç¯å¢ƒå˜é‡");

    let v = "rust";
    let c2 = || print!("æ•è·ç¯å¢ƒå˜é‡ä½†ä¸ä¿®æ”¹ {}", v);

    let mut s0 = String::from("hello");

    // é—­åŒ…çš„å‚æ•°å†™åœ¨ ï½œï½œ ä¸­

    let mut c3 = |s: String| {
        s0 = s + v;
        println!("æ•è·å¹¶ä¿®æ”¹ç¯å¢ƒå˜é‡ {:?}", s0)
    };

    // 2 é—­åŒ…çš„è°ƒç”¨

    // é—­åŒ…çš„è°ƒç”¨åŒå‡½æ•°ä¸€æ ·

    c1();
    c2();
    c3(String::from("rust"));
```

**æ‰©å±•èµ„æ–™**

1.[å®˜æ–¹æ–‡æ¡£ä¸­å…³äºé—­åŒ…çš„ä»‹ç»](https://rustwiki.org/zh-CN/book/ch13-01-closures.html)

#### æ³›å‹

Rustè¯­è¨€æ”¯æŒæ³›å‹ç¼–ç¨‹ï¼Œåœ¨å®é™…æ“ä½œä¸­ä¼šå¤§é‡æ¶‰åŠåˆ°æ³›å‹ã€‚æ³›å‹æä¾›äº†æŠ½è±¡èƒ½åŠ›ï¼Œè®©ä»£ç å¤ç”¨æ€§æ›´å¼ºã€‚æ³›å‹ä¸€èˆ¬å’Œå…¶å®ƒæ•°æ®ç»“æ„ç»“åˆä½¿ç”¨

```
    // 1 æ³›å‹å‚æ•°çš„è¡¨ç¤º

    // æ³›å‹å‚æ•°ä¸€èˆ¬ç”¨å¤§å†™å­—æ¯`T`è¡¨ç¤º,å¤šä¸ªæ³›å‹å‚æ•°å¯ä»¥ä½¿ç”¨å¤šä¸ªå¤§å†™å­—æ¯

    // å¯ä»¥æŠŠæ³›å‹å½“ä½œè‡ªå®šä¹‰ç±»å‹ï¼Œå¿…é¡»å…ˆå£°æ˜æ‰èƒ½ä½¿ç”¨

    // 2 æ³›å‹å¦‚ä½•ä½¿ç”¨

    // 2.1 é›†åˆ Vec<T>
    // é›†åˆvectorå°±æ˜¯ç”±æ³›å‹æä¾›æ”¯æŒçš„,å®ƒå…è®¸æˆ‘ä»¬ä½¿ç”¨æŸä¸ªå…·ä½“ç±»å‹æ—¶å†æŒ‡å®š

    let v1: Vec<u8> = Vec::new();
    let v2: Vec<String> = Vec::new();
    let v3: Vec<bool> = Vec::new();

    // 2.2 æ³›å‹ç»“æ„ä½“

    // å¯ä»¥å£°æ˜ä¸€ä¸ªæ³›å‹ç»“æ„ä½“ï¼Œç„¶åå†ä½¿ç”¨çš„æ—¶å€™åœ¨æŒ‡å®šæˆå‘˜çš„å…·ä½“ç±»å‹
    // æ³¨æ„ï¼šå¿…é¡»å…ˆåœ¨` <> `ä¸­å£°æ˜æ³›å‹å‚æ•°ï¼Œç„¶åæ‰èƒ½ä½¿ç”¨

    struct Type<T>(T);
    struct Point<A, B> {
        a: A,
        b: B,
    }

    let t1 = Type(42);
    let t2 = Type("rust");

    let p1 = Point { a: 42, b: 42 };
    let p2 = Point { a: 42.1, b: 42.1 };

    // ä¸ºæ³›å‹ç»“æ„ä½“å®ç°æ–¹æ³•
    // æ³¨æ„ï¼šä¸ºæ³›å‹ç»“æ„ä½“å®ç°æ–¹æ³•æ—¶ï¼Œimplå’Œç»“æ„ä½“åé¢çš„æ³›å‹å£°æ˜è¦ä¿æŒä¸€è‡´
    impl<A, B> Point<A, B> {
        fn new(a: A, b: B) -> Self {
            Point { a, b }
        }
    }

    // 2.3 æ³›å‹æšä¸¾

    // åŒæ ·ï¼Œå¯ä»¥å®šä¹‰æ³›å‹æšä¸¾

    enum Area<A, B, C> {
        Rectangle(A),
        Square(B),
        Circle(C),
    }

    let a1: Area<f64, u32, &str> = Area::Rectangle(42f64);
    let a2: Area<f32, u64, &str> = Area::Square(42u64);
    let a3: Area<f64, u32, &str> = Area::Circle("100 cm^2");

    // 2.4 æ³›å‹å‡½æ•°

    // å‡½æ•°å‚æ•°ä¹Ÿå¯ä»¥æ˜¯æ³›å‹, å½“ç„¶æ³›å‹ä¹Ÿéœ€è¦åœ¨ `<>` ä¸­å…ˆå£°æ˜

    fn generics<T, B>(a: T, b: B) -> T {
        a
    }
    generics(32, "rust");
    generics("rust", 32);
```

**æ‰©å±•èµ„æ–™**

1.[å®˜æ–¹æ–‡æ¡£ä¸­å…³äºæ³›å‹çš„ä»‹ç»](https://rustwiki.org/zh-CN/book/ch10-00-generics.html)

### 1.3.4 æ§åˆ¶æµ

Rustç¨‹åºåœ¨ä¹¦å†™ä¸Šå¹¶æ²¡æœ‰å¤ªå¤æ‚çš„ç»“æ„ï¼Œå¾ªç¯å’Œæ¨¡å¼åŒ¹é…åŸºæœ¬èƒ½å¤Ÿæ»¡è¶³ç»å¤§å¤šæ•°åœºæ™¯éœ€æ±‚

#### å¾ªç¯

Rustæœ‰ä¸‰ç§å¾ªç¯ç»“æ„forå¾ªç¯ï¼Œloopå’Œwhile

```
 // 1 ä½¿ç”¨forå¾ªç¯éå†é›†åˆ
    // æ³¨æ„ï¼šRustä¸­çš„forå¾ªç¯æœ¬è´¨ä¸Šæ˜¯è¿­ä»£å™¨çš„è¯­æ³•ç³–
    // è¿­ä»£å™¨æ¶‰åŠåˆ°æ›´å¤æ‚çš„çŸ¥è¯†ç‚¹ï¼Œåç»­ä¼šä»‹ç»

    let v = vec![1, 2, 3, 4, 5];

    for num in v {
        println!("{}", num);
    }

    let mut map = std::collections::HashMap::new();
    map.insert("a", 2);
    map.insert("b", 2);
    map.insert("c", 2);

    for kv_pair in map {
        println!("{:?}", kv_pair);
    }

    // 2 ä½¿ç”¨ loop æ‰§è¡Œæ— é™å¾ªç¯ï¼Œå¹¶ä½¿ç”¨breakç»ˆæ­¢

    let mut x = 0;

    loop {
        println!("{:?}", x);

        if x == 10 {
            break;
        } else {
            x = x + 1;
        }
    }

    // 3 ä½¿ç”¨ while æ‰§è¡Œæ¡ä»¶å¾ªç¯

    let mut x = 0;
    while x < 5 {
        println!("x is {}", x);
        x += 1;
    }
```

#### æ¨¡å¼åŒ¹é…

Rustä¸­çš„æ¨¡å¼åŒ¹é…æŒ‡çš„æ˜¯ç»“æ„ä¸Šçš„åŒ¹é…ï¼Œæœ€å¸¸ç”¨æœ‰matchã€while let ã€let ã€if let 

```
// 1 match
    // match æ˜¯æœ€é•¿ç”¨çš„æ¨¡å¼åŒ¹é…ï¼Œä¸»è¦å’Œæšä¸¾æ­é…ä½¿ç”¨ï¼Œä»¥åŒ¹é…ä¸åŒçš„æšä¸¾æˆå‘˜

    match std::fs::File::open("rust.txtr") {
        Ok(file) => println!("{:?}", file),
        Err(err) => panic!("{}", err),
    }

    // 2 if let
    // if let å¯ä»¥è®©æˆ‘ä»¬åªå…³æ³¨æˆ‘ä»¬æƒ³è¦çš„ç»“æœ

    if let Ok(file) = std::fs::File::open("rust.txtr") {
        println!("{:?}", file);
    }

    // 3 while let
    // å’Œ if let ç±»ä¼¼ï¼Œåªå¤„ç†æ­£ç¡®çš„ç»“æœ

    while let Ok(file) = std::fs::File::open("rust.txt") {
        println!("{:?}", file);
    }

    // 4 let
    // let æœ¬èº«ä¹Ÿæ˜¯ä¸€ç§æ¨¡å¼åŒ¹é…
    // ä½¿ç”¨ let åŒ¹é…å…ƒç»„ä¸­çš„å…ƒç´ 

    let tuple = (42, true, "rust");

    let (x, y, z) = tuple;

    println!("{:?}", x);
    println!("{:?}", y);
    println!("{:?}", z);
```

### 1.3.5 æ³¨é‡Š

Rustä¸­çš„æ³¨é‡Šä¸»è¦åŒ…æ‹¬æ–‡æ¡£æ³¨é‡Šï¼Œå¤šè¡Œæ³¨é‡Šå’Œå•è¡Œæ³¨é‡Š

```
/// 1. æ–‡æ¡£æ³¨é‡Š,ä¸€èˆ¬å†™åœ¨å½“å‰æ–‡ä»¶çš„æœ€é¡¶ç«¯

fn main() {
    /*
       2. å¤šè¡Œæ³¨é‡Š
       Point ç»“æ„ä½“ä»£è¡¨äºŒç»´åæ ‡ç³»ä¸‹çš„ä¸€ä¸ªç‚¹ï¼Œé€šè¿‡åæ ‡å¯ä»¥æ±‚çš„ä»»æ„ä¸€ç‚¹åˆ°åŸç‚¹çš„è·ç¦»
    */
    struct Point(u32, u32);

    // 3. å•è¡Œæ³¨é‡Š
    // æ±‚æŸä¸€ç‚¹åˆ°åŸç‚¹è·ç¦»çš„å¹³æ–¹

    fn distance_square(p: Point) -> u32 {
        p.0 * p.0 + p.1 * p.1
    }

    let p = Point(3, 4);
    distance_square(p);
}
```

**æ‰©å±•èµ„æ–™**

1.[å®˜æ–¹æ–‡æ¡£ä¸­å…³äºæ³¨é‡Šçš„ä»‹ç»](https://rustwiki.org/zh-CN/book/ch03-04-comments.html)

## 1.4 ç»ƒä¹ 

# æ¨¡å—äºŒï¼šRustæ ¸å¿ƒçŸ¥è¯†

Rustæ˜¯æ— GCï¼ˆgarbage collectionï¼‰çš„è¯­è¨€ï¼Œå¯¹äºå †å†…å­˜çš„ç®¡ç†ä¸»è¦é€šè¿‡æ ˆæ¥å®ç°ã€‚å…·ä½“è€Œè¨€å°±æ˜¯é€šè¿‡å€Ÿç”¨æ£€æŸ¥å’Œæ‰€æœ‰æƒæœºåˆ¶æ¥å®ç°ã€‚æ ¸å¿ƒè§„åˆ™å¦‚ä¸‹

**æ‰€æœ‰æƒè§„åˆ™ï¼š**

1. æ¯ä¸ªå€¼éƒ½æœ‰ä¸€ä¸ªæ‰€æœ‰è€…ï¼ˆownerï¼‰
2. æ¯ä¸ªå€¼åœ¨ä»»ä¸€æ—¶åˆ»åªæœ‰ä¸€ä¸ªæ‰€æœ‰è€…
3. å½“æ‰€æœ‰è€…ï¼ˆå˜é‡ï¼‰ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå®ƒæ‰€æ‹¥æœ‰çš„å€¼å°†è¢«ä¸¢å¼ƒ

**Rust çš„å€Ÿç”¨è§„åˆ™ï¼š**

1. åŒä¸€ä¸ªä½œç”¨åŸŸä¸­ï¼Œä¸€ä¸ªèµ„æºåªæœ‰ä¸€ä¸ªå¯å˜**å€Ÿç”¨**ï¼ˆ&mut Tï¼‰ï¼Œä½†æ‹¥æœ‰å¯å˜**å€Ÿç”¨**ï¼ˆ&mut Tï¼‰åå°±ä¸èƒ½æœ‰ä¸å¯å˜**å€Ÿç”¨**ï¼ˆ&Tï¼‰

2. åŒä¸€ä¸ªä½œç”¨åŸŸä¸­ï¼Œä¸€ä¸ªèµ„æºå¯ä»¥æœ‰å¤šä¸ªä¸å¯å˜**å€Ÿç”¨**ï¼ˆ&Tï¼‰ï¼Œä½†æ‹¥æœ‰ä¸å¯å˜**å€Ÿç”¨**ï¼ˆ&Tï¼‰åå°±ä¸èƒ½æœ‰å¯å˜**å€Ÿç”¨**ï¼ˆ&mut Tï¼‰
3. **å€Ÿç”¨**åœ¨ç¦»å¼€ä½œç”¨åŸŸåé‡Šæ”¾ã€‚

## 2.1 æ‰€æœ‰æƒæœºåˆ¶

### 2.1.1 å›ºå®šå°ºå¯¸ç±»å‹

å›ºå®šå°ºå¯¸ç±»å‹æ˜¯æŒ‡é‚£äº›åœ¨ç¼–è¯‘æœŸå°±å¯ä»¥ç¡®å®šå¤§å°çš„ç±»å‹ã€‚Rustä¸­ä¸»è¦çš„å›ºå®šå°ºå¯¸ç±»å‹å¦‚ä¸‹ï¼š

| ç±»å‹     | æè¿°                             |
| -------- | -------------------------------- |
| åŸºæœ¬ç±»å‹ | æ•´æ•°ã€æµ®ç‚¹æ•°ã€å¸ƒå°”å€¼å’Œå­—ç¬¦ç±»å‹ç­‰ |
| å¤åˆç±»å‹ | æ•°ç»„ã€å…ƒç»„ç­‰                     |
| æŒ‡é’ˆç±»å‹ | å¼•ç”¨å’Œè£¸æŒ‡é’ˆã€å‡½æ•°æŒ‡é’ˆç­‰         |
| ...      | ...                              |

```
// 1 æ‰€æœ‰æƒä¸åŸºæœ¬ç±»å‹

    // ä¸‹é¢çš„æ¯ä¸ªå€¼éƒ½åªæœ‰ä¸€ä¸ªæ‰€æœ‰è€…

    let owner1 = 42;

    let owner11 = owner1; // owneræ˜¯ä¸€ä¸ªæ–°çš„æ‰€æœ‰è€…ï¼Œå®ƒçš„å€¼æ˜¯ owner1å€¼çš„å¤åˆ¶å“ï¼Œowner1ä»ç„¶æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„æ‰€æœ‰è€…
    println!("{}", owner1); // 42,å¯ä»¥é€šè¿‡ owner1 ä½¿ç”¨å€¼

    // ç°åœ¨æœ‰ä¸¤ä¸ªå€¼å’Œå¯¹åº”çš„ä¸¤ä¸ªæœ‰æ•ˆçš„æ‰€æœ‰è€…ï¼Œowner1 å’Œ owner11

    println!("owner1 addr {}", owner1);
    println!("owner11 addr {}", owner11);

    // å¯ä»¥çœ‹åˆ°å€¼çš„åœ°å€ä¹Ÿæ˜¯ä¸ç›¸åŒï¼ˆä½è¯owner11å’Œowner1å„æ‹¥æœ‰ä¸€ä¸ªå€¼ï¼‰
    // å¯¹äºå€¼42æ¥è¯´ï¼Œå®ƒåªæœ‰ä¸€ä¸ªæ‰€æœ‰è€…ï¼Œå› æ­¤ç°åœ¨æœ‰ä¸¤ä¸ª42çš„å€¼ï¼Œå¹¶ä¸”å®ƒä»¬çš„åœ°å€æ˜¯ä¸åŒçš„

    println!("owner1 addr {:p}", &owner1); // 0x7ff7b404dd90
    println!("owner11 addr {:p}", &owner11); // 0x7ff7b404dd94

    let owner2 = 42.0;
    let owner3 = true;

    {
        let owner4 = '4'; // â€˜4â€™ è¿™ä¸ªå€¼çš„æ‰€æœ‰è€… `owner4` åœ¨ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå€¼ä¼šè¢«ä¸¢å¼ƒ
    }

    // println!("{}", owner4) // æ— æ³•å†ä½¿ç”¨ owner4,å› ä¸ºå®ƒå·²ç»è¢«ä¸¢å¼ƒ

    // 2 æ‰€æœ‰æƒä¸å¤åˆç±»å‹

    let arr_owner: [i32; 3] = [1, 2, 3];
    let tuple_owner = (32, true, 42.0);

    // 3 æ‰€æœ‰æƒä¸æŒ‡é’ˆç±»å‹

    // è¿™é‡Œæ‰€è¯´çš„æŒ‡é’ˆæ˜¯æŒ‡æŒ‡å‘æŸä¸ªå†…å­˜åœ°å€çš„å˜é‡ç±»å‹ï¼ŒåŒ…æ‹¬å¼•ç”¨ã€è£¸æŒ‡é’ˆä»¥åŠå‡½æ•°æŒ‡é’ˆ

    // 3.1 å­—ç¬¦ä¸²çš„å¼•ç”¨

    let ptr_owner = "rust";
    let num = 42;

    // æ³¨æ„: ptr_owner æ˜¯å­—ç¬¦ä¸²å¼•ç”¨çš„æ‰€æœ‰è€…ï¼Œè€Œä¸æ˜¯å­—ç¬¦ä¸²çš„æ‰€æœ‰è€…ï¼Œè¿™é‡Œçš„`å€¼`å°±æ˜¯å¼•ç”¨æœ¬èº«

    let ptr_copy = ptr_owner; // æ­¤å¤„æ‰€æœ‰è€… ptr_copy çš„å€¼æ˜¯ ptr_owner çš„å€¼çš„å¤åˆ¶å“ï¼Œptr_owner ä»ç„¶æ˜¯ä¸€ä¸ªæœ‰æ•ˆçš„æ‰€æœ‰è€…

    // ç”±äº ptr_owner å’Œ ptr_copy çš„å€¼éƒ½æ˜¯æŒ‡å‘ç›¸åŒå€¼çš„å¼•ç”¨ï¼Œæ‰€ä»¥å®ƒä»¬æŒ‡å‘çš„å†…å­˜åœ°å€æ˜¯ç›¸åŒçš„
    println!("{:p}", ptr_owner); // 0x10ac12004
    println!("{:p}", ptr_copy); // 0x10ac12004

    // 3.2 åŸºæœ¬ç±»å‹çš„è£¸æŒ‡é’ˆ
    // åœ¨rustä¸­ä½¿ç”¨ `as *const T` å¯ä»¥å°†å¼•ç”¨è½¬ä¸ºè£¸æŒ‡é’ˆ

    let ptr_owner2 = &num as *const i32;

    // 3.3 å‡½æ•°æŒ‡é’ˆ

    fn func() -> i32 {
        0
    }
    let func_ptr = func;
```

### 2.1.2 åŠ¨æ€å°ºå¯¸ç±»å‹

Rustæ˜¯ä¸€é—¨é™æ€ç±»å‹è¯­è¨€ï¼Œè¿™æ„å‘³ç€æ‰€æœ‰å˜é‡åœ¨ç¼–è¯‘æœŸå¿…é¡»æ˜¯å¤§å°ç¡®å®šçš„ï¼Œä½†æ˜¯åœ¨å®é™…åœºæ™¯ä¸­ï¼Œæ¯”å¦‚å­—ç¬¦ä¸²å’Œåˆ‡ç‰‡ç±»å‹çš„å¤§å°å–å†³äºè¿è¡Œæ—¶çš„å…·ä½“æƒ…å†µã€‚Rustå¯¹è¿™ç±»æ•°æ®çš„å¤„ç†æ–¹æ³•æ˜¯ä½¿ç”¨å®ƒä»¬çš„æŒ‡é’ˆï¼ˆå¼•ç”¨ï¼‰ï¼Œè€Œä¸æ˜¯æ•°æ®æœ¬èº«ï¼Œä¼—æ‰€å‘¨çŸ¥ï¼Œä¸€ä¸ªç±»å‹ä¸ç®¡å¤šå¤§ï¼Œå¯¹åº”çš„æŒ‡é’ˆï¼ˆå¼•ç”¨ï¼‰å¤§å°æ˜¯ç¡®å®šçš„

| ç±»å‹         | æè¿°                                                         |
| ------------ | ------------------------------------------------------------ |
| å­—ç¬¦ä¸²ç±»å‹   | str, æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªu8ç±»å‹çš„æ•°æ®åºåˆ—ï¼Œå®é™…ä¸­ç»å¸¸ä½¿ç”¨çš„å½¢å¼ï¼š&str å’Œ String |
| åˆ‡ç‰‡ç±»å‹     | [T], å®ƒä»£è¡¨ç±»å‹ä¸º `T` çš„å…ƒç´ ç»„æˆçš„æ•°æ®åºåˆ—ï¼šå®é™…ä¸­ç»å¸¸ä½¿ç”¨çš„å½¢å¼ï¼š Vec<T> |
| trait object | trait object çš„å¤§å°åªæœ‰åœ¨è¿è¡Œæ—¶æ‰èƒ½ç¡®å®šï¼ˆå¯ä»¥å…ˆä¸ç”¨äº†è§£ï¼Œå…³äºtraitçš„å†…å®¹åé¢ä¼šç»§ç»­è®²è§£ï¼‰ |
| ...          | ...                                                          |

```
// 1 æ‰€æœ‰æƒä¸å­—ç¬¦ä¸²
    // æˆ‘ä»¬åœ¨å‰é¢ä»‹ç»è¿‡ï¼Œå­—ç¬¦ä¸²å¯ä»¥å­˜æ”¾åœ¨ç¨‹åºçš„åªè¯»æ•°æ®æ®µä¸­æˆ–è€…å †ä¸Š
    // ä¸€èˆ¬æƒ…å†µä¸‹ï¼Œå­—ç¬¦ä¸²å­—é¢é‡å­˜æ”¾åœ¨åªè¯»æ•°æ®æ®µä¸­çš„ï¼Œå£°æ˜ä¹‹åå¾ˆå°‘å»ä¿®æ”¹å®ƒ
    // è€Œéœ€è¦åŠ¨æ€å˜åŒ–çš„å­—ç¬¦ä¸²æˆ‘ä»¬ä¼šæŠŠå®ƒå­˜æ”¾åˆ°å †ä¸Šï¼Œå¹¶ä¸”é€šè¿‡æ ˆå†…å­˜æ¥ç®¡ç†å †å†…å­˜

    let ptr_owner = "Rust"; // å­˜æ”¾åœ¨åªè¯»æ•°æ®æ®µä¸­
    let heap_ptr_owner = String::from("Rust"); //å­˜æ”¾åœ¨å †ä¸Š

    // 1.1 å¯¹äºå­˜æ”¾åœ¨åªè¯»æ•°æ®æ®µä¸­çš„å­—ç¬¦ä¸²å­—é¢é‡ï¼Œå®ƒçš„æ‰€æœ‰æƒè§„åˆ™å’Œå…¶ä»–åŸºæœ¬ç±»å‹ä¸€æ ·,è¿™é‡Œä¸å†èµ˜è¿°

    let ptr_copy = ptr_owner;

    // ç”±äº ptr_owner å’Œ ptr_copy çš„å€¼éƒ½æ˜¯æŒ‡å‘ç›¸åŒå€¼çš„å¼•ç”¨ï¼Œæ‰€ä»¥å®ƒä»¬æŒ‡å‘çš„å†…å­˜åœ°å€æ˜¯ç›¸åŒçš„
    println!("{:p}", ptr_owner); // 0x10ac12004
    println!("{:p}", ptr_copy); // 0x10ac12004

    // 1.2 å¯¹äºå­˜æ”¾åœ¨å †ä¸Šçš„å­—ç¬¦ä¸²ï¼Œå¦‚æœæŠŠå®ƒçš„æ‰€æœ‰è€…èµ‹å€¼ç»™å¦ä¸€ä¸ªå˜é‡ï¼Œæ„å‘³ç€æŠŠå †ä¸Šæ‰€æœ‰æƒå°±ä¼šè½¬ç§»ç»™æ–°çš„æ‰€æœ‰è€…
    let heap_ptr_old = String::from("Rust"); //å­˜æ”¾åœ¨å †ä¸Š

    let heap_ptr_new = heap_ptr_old;

    // println!("old owner{:?}", heap_ptr_old); // æ— æ³•å†é€šè¿‡ heap_ptr_old ä½¿ç”¨å€¼ï¼Œå› ä¸ºå®ƒå·²ç»æŠŠæ•°æ®æ‰€æœ‰æƒç§»äº¤ç»™äº†æ–°çš„æ‰€æœ‰è€… heap_ptr_new
    println!("old owner{:?}", heap_ptr_new); // heap_ptr_new å¯ä»¥æ­£å¸¸è®¿é—®åˆ°å †ä¸Šçš„æ•°æ®ï¼Œå¹¶ä¸”å®ƒæ˜¯å”¯ä¸€çš„æ‰€æœ‰è€…ï¼Œå½“å®ƒç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå †ä¸Šçš„æ•°æ®ä¹Ÿä¼šè¢«ä¸¢å¼ƒ

    {
        let owner_old = String::from("rust");
        let owner_new = owner_old;

        // åœ¨æ­¤å¤„ç¦»å¼€ä½œç”¨åŸŸ
    }

    // println!("{:?}", owner_new); æ— æ³•å†é€šè¿‡ owner_new ä½¿ç”¨å€¼ï¼Œå› ä¸ºå®ƒå·²ç»è¢«ä¸¢å¼ƒ

    // 2 æ‰€æœ‰æƒä¸slice

    // ä¸Šé¢çš„å­—ç¬¦ä¸²str å®é™…ä¸Šæ˜¯ä¸€ä¸ªç‰¹æ®Šçš„ slice, å®ƒä»…ä»£è¡¨æœ‰æ•ˆçš„utf-8åºåˆ—
    // è€Œåˆ‡ç‰‡ä¸­å¯ä»¥åŒ…å«ä»»ä½•ç±»å‹çš„å…ƒç´ ï¼Œå¦‚å…¶ä»–åŸºç¡€ç±»å‹ã€è‡ªå®šä¹‰ç±»å‹ç­‰, æ­£å¦‚ä¸ç›´æ¥ä½¿ç”¨ strä¸€æ ·ï¼Œæˆ‘ä»¬ä¹Ÿä¸ç›´æ¥ä½¿ç”¨[T],è€Œæ˜¯ä½¿ç”¨å®ƒçš„æŒ‡é’ˆï¼ˆå¼•ç”¨ï¼‰ç±»å‹ï¼ŒVec<T>
    // sliceä¸­çš„æ•°æ®ä¹Ÿå­˜æ”¾åœ¨å †ä¸Šï¼ŒRustä¸­sliceå†…å­˜ç®¡ç†é€»è¾‘åŒå­˜æ”¾åœ¨å †ä¸Šçš„str

    // vec æœ‰ä¸¤ç§åˆ›å»ºæ–¹å¼ï¼šä½¿ç”¨å®æˆ–è€…æ–¹æ³•
    let str_slice = vec!["rust", "go", "cpp"];
    let u32_slice: Vec<u32> = Vec::new();

    let new_owner1 = str_slice;
    let new_owner2 = u32_slice;

    // println!("{:?}", str_slice); // æ— æ³•å†é€šè¿‡ str_slice ä½¿ç”¨å€¼ï¼Œå› ä¸ºå®ƒå·²ç»è¢«ä¸¢å¼ƒ
    // println!("{:?}", u32_slice); // æ— æ³•å†é€šè¿‡ u32_slice ä½¿ç”¨å€¼ï¼Œå› ä¸ºå®ƒå·²ç»è¢«ä¸¢å¼ƒ

    println!("{:?}", new_owner1); // å¯ä»¥é€šè¿‡æ–°çš„æ‰€æœ‰è€…è®¿é—®åˆ°åŸæ¥çš„å€¼
    println!("{:?}", new_owner2); // å¯ä»¥é€šè¿‡æ–°çš„æ‰€æœ‰è€…è®¿é—®åˆ°åŸæ¥çš„å€¼

    // 3 æ€»ç»“
    // å½“æ•°æ®å­˜æ”¾åœ¨å †ä¸Šæ—¶ï¼ŒæŠŠæ‰€æœ‰æƒèµ‹å€¼ç»™å¦ä¸€ä¸ªå˜é‡ï¼Œæ„å‘³ç€æŠŠå †ä¸Šæ‰€æœ‰æƒå°±ä¼šè½¬ç§»ç»™æ–°çš„æ‰€æœ‰è€…ï¼Œå †ä¸Šçš„æ•°æ®æœ¬èº«æ²¡æœ‰è¢«å¤åˆ¶ï¼ŒåŸæ¥çš„æ‰€æœ‰è€…ä¸å†æ‹¥æœ‰æ•°æ®
    // å½“æ•°æ®å­˜æ”¾åœ¨æ ˆä¸Šæ—¶ï¼ŒæŠŠæ‰€æœ‰æƒèµ‹å€¼ç»™å¦ä¸€ä¸ªå˜é‡ï¼Œæ„å‘³ç€æŠŠæ ˆä¸Šçš„æ•°æ®å¤åˆ¶äº†ä¸€ä»½ç»™æ–°çš„æ‰€æœ‰è€…ï¼ŒåŸæ¥çš„æ‰€æœ‰è€…ä»ç„¶æ‹¥æœ‰åŸæ¥çš„æ•°æ®
```

### 2.1.3 æ‰€æœ‰æƒå…±äº«

æ‰€æœ‰æƒè§„åˆ™æ›´åƒæ˜¯å¯¹èµ„æºçš„ç‹¬å ï¼Œåœ¨å®é™…åœºæ™¯ä¸­ï¼Œä½ å¯èƒ½å¸Œæœ›å¤šä¸ªè§’è‰²å…±äº«è®¿é—®æŸä¸ªåŠ¨æ€èµ„æºã€‚Rustæä¾›äº†ä¸¤ä¸ªå®¹å™¨ç±»å‹Rc<T>å’ŒArc<T>ï¼Œå¯ä»¥è®©ä½ åŒæ—¶è®©å¤šä¸ªå˜é‡æ‹¥æœ‰åŠ¨æ€æ•°æ®çš„æ‰€æœ‰æƒ

```
 // 1 ç‹¬å è®¿é—®èµ„æº

    let mut dynamic_source = String::from("content");

    let role1 = dynamic_source;
    // let role2 = dynamic_source; // èµ„æºè¢« role1 æ‰€æœ‰ï¼Œæ­¤æ—¶role1ç‹¬å è®¿é—®
    let role2 = role1; // åªæœ‰role1 æŠŠæ‰€æœ‰æƒç§»äº¤ç»™ role2ï¼Œ role2 æ‰å¯ä»¥è®¿é—®

    // è¿™æ ·åšçš„å¥½å¤„æ˜¯ï¼Œå¯ä»¥é¿å…èµ„æºè¢«å¤šä¸ªå˜é‡åŒæ—¶è®¿é—®ï¼Œå¯¼è‡´èµ„æºè¢«ä¿®æ”¹
    // åå¤„æ˜¯ï¼Œèµ„æºåªèƒ½è¢«ä¸€ä¸ªå˜é‡è®¿é—®ï¼Œä½æ•ˆ

    use std::rc::Rc;
    use std::sync::Arc;

    // 2 æ‰€æœ‰æƒä¸å…±äº«å®¹å™¨ Rc<T>,å®ƒé€‚ç”¨äºå•çº¿ç¨‹

    // ä½¿ç”¨å…±äº«å®¹å™¨åŒ…è£¹åŠ¨æ€èµ„æº

    let dynamic_source = vec![1, 2];

    let container = Rc::new(dynamic_source);

    let role1 = container.clone(); // è¿™é‡Œcloneæ–¹æ³•å…¶å®æ˜¯å¤åˆ¶äº†å¯¹èµ„æºè®¿é—®çš„æ‰€æœ‰æƒï¼Œè€Œä¸æ˜¯èµ„æºæœ¬èº«
    let role2 = container.clone();

    // é€šè¿‡å…±äº«å®¹å™¨è®¿é—®èµ„æº,æ­¤æ—¶èµ„å…±äº«èµ„æºæœ‰ä¸‰ä¸ªæ‰€æœ‰è€…ï¼Œå¯ä»¥åŒæ—¶è®¿é—®
    println!("{:?}", container); // [1,2]
    println!("{:?}", role1); // [1,2]
    println!("{:?}", role2); // [1,2]

    // 3 æ‰€æœ‰æƒå…±äº«å®¹å™¨ Arc<T>ï¼Œå®ƒé€‚ç”¨äºå¤šçº¿ç¨‹

    let dynamic_source = String::from("rust");

    let container = Arc::new(dynamic_source);

    let role1 = container.clone(); // è¿™é‡Œcloneæ–¹æ³•å…¶å®æ˜¯å¤åˆ¶äº†å¯¹èµ„æºè®¿é—®çš„æ‰€æœ‰æƒï¼Œè€Œä¸æ˜¯èµ„æºæœ¬èº«
    let role2 = container.clone();

    // é€šè¿‡å…±äº«å®¹å™¨è®¿é—®èµ„æº,æ­¤æ—¶èµ„å…±äº«èµ„æºæœ‰ä¸‰ä¸ªæ‰€æœ‰è€…ï¼Œå¯ä»¥åŒæ—¶è®¿é—®
    println!("{:?}", container); // rust
    println!("{:?}", role1); // rust
    println!("{:?}", role2); // rust

    // 4 å…±äº«å®¹å™¨ä¸å†…å­˜ç®¡ç†
    // æ³¨æ„ï¼šRc<T>å’ŒArc<T>å®é™…ä¸Šæ˜¯ä¸€ç§å¼•ç”¨è®¡æ•°ï¼Œæ¯ä½¿ç”¨cloneæ–¹æ³•ä¸€æ¬¡ï¼Œå¼•ç”¨è®¡æ•°å°±ä¼š+1ï¼Œå½“å˜é‡ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå¼•ç”¨è®¡æ•°ä¼š-1ï¼Œå½“å¼•ç”¨è®¡æ•°ä¸º0æ—¶ï¼Œå †å†…å­˜ä¼šè¢«é‡Šæ”¾
    // æ•´ä¸ªè¿‡ç¨‹åœ¨ç¼–è¯‘å™¨çœ‹æ¥ï¼Œæ¯ä¸ªå˜é‡éƒ½æ‹¥æœ‰ä¸€ä¸ªRcæˆ–è€…Arcã€‚æ‰€ä»¥å¹¶ä¸è¿åæ‰€æœ‰æƒè§„åˆ™
    // è¿™é‡Œæä¸€ç‚¹:ä¸€èˆ¬æƒ…å†µä¸‹ï¼ŒRustä½¿ç”¨æ ˆæ¥ç®¡ç†å †å†…å­˜ã€‚ä½†æ˜¯Rcå’ŒArcæ˜¯ä¸€ç§ç‰¹åˆ«çš„æœºåˆ¶ï¼Œå®ƒå…è®¸ä¸å—æ ˆå†…å­˜æ§åˆ¶çš„å †å†…å­˜ï¼Œä¹Ÿå°±æ˜¯å…è®¸å†…å­˜æ³„éœ²ã€‚å¯¹äºè¿™ç§æ³„æ¼é€šè¿‡å¼•ç”¨è®¡æ•°æ¥ç®¡ç†

    // 4.1 é€šè¿‡æ ˆå†…å­˜æ¥ç®¡ç†å †å†…å­˜

    {
        let source = String::from("hello");

        let role1 = source;
        println!("{:?}", role1);
        // ä¸¢å¼ƒ

        // println!("{:?}", source); // ä¸èƒ½å†ä½¿ç”¨sourceï¼Œå› ä¸ºsourceå·²ç»ç§»äº¤äº†æ‰€æœ‰æƒ
        // å½“role1ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œä¼šç«‹å³ä¸¢å¼ƒ role1å’Œå †ä¸Šçš„æ•°æ®
    }

    // 4.2 é€šè¿‡å¼•ç”¨è®¡æ•°æ¥ç®¡ç†å †å†…å­˜

    {
        let source = String::from("hello");

        // ä½¿ç”¨RcåŒ…è£¹èµ„æºï¼Œè®©å†…å­˜æ³„æ¼
        let container = Rc::new(source); // å¼•ç”¨è®¡æ•° + 1
                                         //
        let role1 = container.clone(); // å¼•ç”¨è®¡æ•° + 1
        let role2 = container.clone(); // å¼•ç”¨è®¡æ•° + 1

        // å½“å˜é‡ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œrole2ï¼Œrole1ï¼Œcontainerç›¸ç»§ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå¼•ç”¨è®¡æ•°éƒ½ä¼š-1ï¼Œå½“å¼•ç”¨è®¡æ•°ä¸º0æ—¶ï¼Œå †ä¸Šçš„æ•°æ®æ‰ä¼šè¢«é‡Šæ”¾
    }
```

## 2.2 å€Ÿç”¨å’Œç”Ÿå‘½å‘¨æœŸ

æ ¹æ®æ˜¯å¦æ‹¥æœ‰æ•°æ®çš„æ‰€æœ‰æƒï¼ŒRustä¸­çš„å˜é‡å¯ä»¥åˆ†ä¸ºæ‹¥æœ‰æ‰€æœ‰æƒçš„å˜é‡å’Œæ²¡æœ‰æ‰€æœ‰æƒçš„å˜é‡

è€Œæ‹¥æœ‰æ‰€æœ‰æƒçš„å˜é‡æˆ‘ä»¬åªéœ€è¦ææ˜ç™½æ‰€æœ‰æƒè§„åˆ™å°±è¡Œäº†ï¼Œæ‰€ä»¥æœ‰æ‰€æœ‰æƒçš„å˜é‡ç”Ÿå‘½å‘¨æœŸå¹¶æ²¡æœ‰éš¾ç‚¹

ä½†å¯¹äºæ²¡æœ‰æ‰€æœ‰æƒçš„å˜é‡ä¹Ÿå°±æ˜¯å¼•ç”¨ï¼ˆå€Ÿç”¨ï¼‰ï¼Œæ¯”è¾ƒéº»çƒ¦ï¼Œä½†ä¹Ÿä¸»è¦æ˜¯åœ¨å‡½æ•°å‚æ•°ä¼ é€’çš„è¿‡ç¨‹ä¸­

```
 // 1 æœ‰æ‰€æœ‰æƒçš„å˜é‡å’Œæ²¡æœ‰æ‰€æœ‰æƒçš„å˜é‡

    // æœ‰æ‰€æœ‰æƒ

    let have_ownership = String::from("rust");

    // æ²¡æœ‰æ‰€æœ‰æƒ
    let have_no_ownership = "rust"; // å­—ç¬¦ä¸²åˆ‡ç‰‡çš„å¼•ç”¨

    // æœ‰æ‰€æœ‰æƒ
    let num = 42;

    // æ²¡æœ‰æ‰€æœ‰æƒ
    let num_ptr = &num;

    // 2 å˜é‡çš„ç”Ÿå‘½å‘¨æœŸ ï¼ˆä¸ç®¡æ˜¯æœ‰æ‰€æœ‰æƒçš„å˜é‡è¿˜æ˜¯æ²¡æ‰€æœ‰æƒçš„å˜é‡ï¼‰: ä»å£°æ˜å¼€å§‹ï¼Œåˆ°ç¦»å¼€ä½œç”¨åŸŸç»“æŸ

    {
        let x = 32;
        println!("{}", x);

        {
            // å¼•ç”¨çš„ç”Ÿå‘½å‘¨æœŸ
            let x_ptr = &x;

            // x_ptr åœ¨ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œç”Ÿå‘½å‘¨æœŸç»“æŸï¼Œå€¼ä¼šè¢«ä¸¢å¼ƒ
        }

        // println!("{}", x_ptr); // æ— æ³•å†ä½¿ç”¨ x_ptr,å› ä¸ºå®ƒå·²ç»è¢«ä¸¢å¼ƒ

        // x åœ¨ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œç”Ÿå‘½å‘¨æœŸç»“æŸï¼Œå€¼ä¼šè¢«ä¸¢å¼ƒ
    }

    // println!("{}", x); // æ— æ³•å†ä½¿ç”¨ x,å› ä¸ºå®ƒå·²ç»è¢«ä¸¢å¼ƒ

    // 3 ä½¿ç”¨æ³›å‹ç”Ÿå‘½å‘¨æœŸå‚æ•°æ˜¾å¼æ ‡æ³¨å‚æ•°ç”Ÿå‘½å‘¨æœŸ

    // å£°æ˜ä¸€ä¸ªå‡½æ•°ï¼Œå‚æ•°æ˜¯å¼•ç”¨ç±»å‹ï¼Œè¿”å›å€¼ä¹Ÿæ˜¯å¼•ç”¨ç±»å‹
    // å®ƒæ— æ³•ç¼–è¯‘é€šè¿‡ï¼Œå› ä¸ºç¼–è¯‘å™¨æ— æ³•æ¨æ–­å‡ºå‚æ•°å’Œè¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸ
    // äº‹å®ä¸Šï¼Œi32è¿™ç§éå¸¸è½»é‡çš„ç±»å‹ï¼Œæˆ‘ä»¬ç›´æ¥ä¼ å€¼å°±å¯ä»¥äº†ï¼Œä¸éœ€è¦ä¼ å¼•ç”¨

    // fn foo(x: &i32, &y: &i32) -> &i32 {
    //     println!("{}", x);
    // }

    // å¦‚æœæ˜¯æ¯”è¾ƒå¤§çš„ç±»å‹ï¼Œæ¯”å¦‚ç»“æ„ä½“ï¼Œæˆ‘ä»¬å°±éœ€è¦ä¼ å¼•ç”¨äº†

    struct Foo {
        x: i32,
        y: (i32, bool),
        z: String,
    }

    let f1 = Foo {
        x: 32,
        y: (32, true),
        z: String::from("rust"),
    };
    let f2 = Foo {
        x: 32,
        y: (32, true),
        z: String::from("rust"),
    };

    // ä»ç„¶æ— æ³•ç¼–è¯‘é€šè¿‡ï¼Œå› ä¸ºç¼–è¯‘å™¨æ— æ³•æ¨æ–­å‡ºå‚æ•°å’Œè¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸ
    // è¿™æ˜¯å› ä¸ºRustå¯¹äºå‡½æ•°çš„æ£€æŸ¥åªä¼šæ£€æŸ¥ç­¾åï¼Œè€Œä¸æ˜¯å‡½æ•°é‡Œé¢çš„å…·ä½“é€»è¾‘

    // fn bar(x: &Foo, y: &Foo) -> &Foo {
    //     x
    // }

    // ä½†æ˜¯Ruståˆ°åº•åœ¨æ‹…å¿ƒä»€ä¹ˆæƒ…å†µå‘¢ï¼Œæˆ‘ä»¬æ¥çœ‹çœ‹ä¸‹é¢çš„ä»£ç 

    {
        // å‡è®¾ä¸‹é¢çš„å‡½æ•°å¯ä»¥ç¼–è¯‘é€šè¿‡

        // fn bar(x: &Foo, y: &Foo) -> &Foo {
        //     let f3 = &Foo {
        //         x: 32,
        //         y: (32, true),
        //         z: String::from("rust"),
        //     };

        //     f3
        // }

        // å®šä¹‰ä¸¤ä¸ªç”Ÿå‘½å‘¨æœŸä¸åŒçš„å˜é‡

        let mut f1 = &Foo {
            x: 32,
            y: (32, true),
            z: String::from("rust"),
        };

        {
            let f2 = &Foo {
                x: 32,
                y: (32, true),
                z: String::from("rust"),
            };

            // è°ƒç”¨å‡½æ•°ï¼Œä¼ å…¥ä¸¤ä¸ªå¼•ç”¨
            // å‰é¢å‡è®¾å‡½æ•°å¯ä»¥é€šè¿‡ï¼Œä¼šè¿”å›å‡½æ•°å†…éƒ¨å˜é‡çš„å¼•ç”¨

            // let f4 = bar(f1, f2);
            // å°†è¿”å›ç»“æœèµ‹å€¼ç»™f4,æ˜¾ç„¶æ˜¯ä¸åˆç†çš„ï¼Œå› f3åœ¨å‡½æ•°ç»“æŸæ—¶ä¼šè¢«ä¸¢å¼ƒï¼Œf4å°±ä¼šæŒ‡å‘ä¸€ä¸ªæ— æ•ˆçš„å†…å­˜åœ°å€
        }

        // ç°åœ¨ä½¿ç”¨ç”Ÿå‘½å‘¨æœŸå‚æ•°ï¼Œæ¥æ ‡æ³¨å‚æ•°å’Œè¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸ
        // æ³¨æ„Rustä¸­çš„ç”Ÿå‘½å‘¨æœŸå‚æ•°æ˜¯ä»¥å•å¼•å·å¼€å¤´çš„å°å†™å­—æ¯ï¼Œä¹Ÿæ˜¯ä¸€ç§æ³›å‹ï¼Œä½†é€šå¸¸ä½¿ç”¨ 'aï¼Œâ€˜bï¼Œâ€˜cè¿™æ ·çš„å­—æ¯
        // ç”Ÿå‘½å‘¨æœŸå‚æ•°ä¹Ÿåƒæ³›å‹ä¸€æ ·éœ€è¦å…ˆå£°æ˜æ‰èƒ½ä½¿ç”¨
        // ä½¿ç”¨äº†ç”Ÿå‘½å‘¨æœŸå‚æ•°åï¼Œç¼–è¯‘å™¨é€šè¿‡äº†ï¼Œæ³¨æ„è¿™é‡Œæˆ‘ä»¬åªæ˜¯å‘Šè¯‰ç¼–è¯‘å™¨è¿”å›å€¼çš„ç”Ÿå‘½å‘¨æœŸæ˜¯yçš„ç”Ÿå‘½å‘¨æœŸï¼Œå…¶ä»–çš„ä»€ä¹ˆéƒ½æ²¡åš
        // è¿™å®é™…ä¸Šå°±å‘Šè¯‰ç¼–è¯‘å™¨æˆ‘ä»¬æ²¡æœ‰è¿”å›å±€éƒ¨å˜é‡ï¼Œæ‰€ä»¥ä¸ä¼šæœ‰æ‚¬å‚æŒ‡é’ˆçš„é—®é¢˜

        fn bar<'a, 'b>(x: &'a Foo, y: &'b Foo) -> &'b Foo {
            y
        }

        // å¦‚æœä¸ç¡®å®šè¿”å›å“ªä¸ªå‚æ•°çš„å¼•ç”¨ï¼Œå¯ä»¥ä½¿ç”¨ä¸‹é¢çš„å†™æ³•,`'b: 'a` è¡¨ç¤º'b çš„ç”Ÿå‘½å‘¨æœŸè¦ä¸çŸ­äº'açš„ç”Ÿå‘½å‘¨æœŸ

        fn far<'a, 'b: 'a>(x: &'a Foo, y: &'b Foo) -> &'a Foo {
            if x.x > y.x {
                x
            } else {
                y
            }
        }

        {
            let f3 = &Foo {
                x: 32,
                y: (32, true),
                z: String::from("rust"),
            };

            let f3 = bar(f1, f3);

            f1 = f3;

            println!("{}", f1.x);

            // è°ƒç”¨far
            // æˆ‘ä»¬åœ¨å£°æ˜å‡½æ•°çš„æ—¶å€™ï¼Œè¦æ±‚â€˜bä¸çŸ­äºâ€™a,ä½†æ˜¯f3çš„ç”Ÿå‘½å‘¨æœŸæ¯”f1çš„ç”Ÿå‘½å‘¨æœŸçŸ­ï¼Œä½†ä¾ç„¶ä¼šæˆåŠŸæ‰§è¡Œï¼Œè¿™æ˜¯ä¸ºä»€ä¹ˆï¼Ÿ
            let f4 = far(f1, f3);
            let f5 = far(f3, f1);

            // å€Ÿç”¨æ£€æŸ¥å™¨
            // å®é™…ä¸Šï¼Œå½“æˆ‘ä»¬æ ‡æ³¨äº†ç”Ÿå‘½å‘¨æœŸä»¥åï¼ŒRustç¼–è¯‘å™¨ä¼šè¿›è¡Œè®¡ç®—ï¼Œè€Œä¸æ˜¯ç®€å•çš„æ£€æŸ¥ç­¾åä¸­å‚æ•°ç”Ÿå‘½å‘¨æœŸå’Œå‚æ•°å£°æ˜æ—¶çš„ç”Ÿå‘½å‘¨æœŸæ˜¯å¦ä¸€è‡´
            // ç”Ÿå‘½å‘¨æœŸè®¡ç®—è¿‡ç¨‹ï¼šRustå…ˆä¼šå–æ‰€æœ‰å‚æ•°çš„å‘¨æœŸï¼Œè®°å½•ä»£ç æœ€åçš„è¦†ç›–ä½ç½®ï¼Œå‡è®¾è®°ä¸ºxï¼Œç„¶åå¯¹ä¸¤ä¸ªå‚æ•°çš„ç”Ÿå‘½å‘¨æœŸæ±‚äº¤é›†ï¼Œè®°å½•æœ€æ—©ç»“æŸä½ç½®ï¼Œå‡è®¾è®°ä¸ºy
            // x < = y,ç¼–è¯‘å™¨é€šè¿‡æ£€æŸ¥ï¼Œx > y ç¼–è¯‘å™¨ä¼šæŠ¥é”™
        }
    }
```

## 2.3 trait

### 2.3.1 trait æ¦‚å†µç®€ä»‹

Rust ä¸­çš„ trait æ˜¯ä¸€ç§å®šä¹‰è¡Œä¸ºçš„æ–¹å¼ï¼Œå®ƒç±»ä¼¼äºå…¶ä»–è¯­è¨€ä¸­çš„æ¥å£æˆ–æŠ½è±¡ç±»ã€‚ä¸€ä¸ª trait å®šä¹‰äº†ä¸€ç»„æ–¹æ³•çš„ç­¾åï¼Œè¿™äº›æ–¹æ³•å¯ä»¥åœ¨å…¶ä»–ç±»å‹ä¸­å®ç°ï¼Œå¹¶å…è®¸è¿™äº›ç±»å‹è¡¨ç°å‡ºç‰¹å®šçš„è¡Œä¸º

Rustä¸­çš„traitä¸€æ–¹é¢çº¦å®šç±»å‹çš„å…±åŒè¡Œä¸ºï¼Œä½†å¦ä¸€æ–¹é¢ä¹Ÿç»å¸¸ä»¥æ˜¯å¦å®ç°äº†æŸä¸ªtraitä½œä¸ºå¯¹ç±»å‹çš„çº¦æŸ

Rustä¸­çš„traitéå¸¸å¼ºå¤§ï¼Œå®ƒå‡ ä¹å’Œæ‰€æœ‰ç±»å‹ç›¸å…³ï¼Œä½ å¯ä»¥é€šè¿‡æ ‡å‡†åº“ä¸­çš„å¤§é‡å®šä¹‰å¥½çš„traitæ¥å­¦ä¹ ç±»å‹æœ‰å“ªäº›æ–¹æ³•ï¼ˆå¯ä»¥æ‰§è¡Œå“ªäº›è¡Œä¸ºï¼‰ï¼ŒåŒæ—¶ï¼Œä¹Ÿå¯ä»¥è‡ªå®šä¹‰triatï¼Œç²˜åˆä¸åŒçš„ç±»å‹ï¼Œæ„å»ºè‡ªå·±çš„é¡¹ç›®

```
 // 1 traitç±»å‹

    // 1.1 ç©ºtrait

    trait A {}

    // 1.2 æœ‰æ–¹æ³•çš„trait

    trait B {
        fn method1(&self);
        fn method2(&self);

        // ...
    }

    // 1.3 æœ‰å…³è”ç±»å‹çš„trait

    trait C {
        type Type;

        fn method1(&self) -> Self::Type;
    }

    // 1.4 æœ‰é»˜è®¤å®ç°çš„trait

    trait D {
        // è¿™ä¸ªæ–¹æ³•æ˜¯é»˜è®¤å®ç°
        fn method1(&self) {
            println!("method1");
        }
        fn method2(&self);
    }

    // 2 å¦‚ä½•å®ç° trait

    // 2.1 æ‰‹åŠ¨å®ç°

    struct Book;

    trait Read {
        fn read(&self);
    }

    // ä½¿ç”¨implè¯­æ³•
    impl Read for Book {
        fn read(&self) {
            println!("read book");
        }
    }

    // æ³¨æ„å’Œä¸ºç±»å‹å®ç°æ–¹æ³•åšåŒºåˆ«

    impl Book {
        fn read(&self) {
            println!("read book");
        }
    }

    // 2.2 ä½¿ç”¨å®å®ç°
    // æ ‡å‡†åº“å’Œç¬¬ä¸‰æ–¹åº“ä¸­ä¸€äº›traitå¯ä»¥é€šè¿‡æ´¾ç”Ÿå®æ¥å®ç°

    #[derive(Default, Clone)]
    struct Student {
        name: String,
        age: u32,
    }

    // å¯ä»¥ç›´æ¥è°ƒç”¨traitæä¾›çš„æ–¹æ³•
    let s = Student::default();
    let s1 = s.clone();

    // 3 traitçº¦æŸ

    // 3.1 traitç»§æ‰¿ï¼Œå¦‚ä¸‹è¦æ±‚ç±»å‹å¿…é¡»å…ˆå®ç° Cloneå’ŒDefault traitæ‰èƒ½æ˜¯å®ç° S trait
    trait S: Clone + Default {
        fn get_age(&self) -> u32;
    }

    impl S for Student {
        fn get_age(&self) -> u32 {
            self.age
        }
    }

    // trait ä½œä¸ºå‡½æ•°å‚æ•°çš„çº¦æŸï¼šåªæœ‰å®ç°äº†S traitçš„æ³›å‹æ‰èƒ½ä½œä¸ºä¸‹åˆ—å‡½æ•°çš„å‚æ•°

    fn person_age<T: S>(s: T) -> u32 {
        s.get_age()
    }

    struct Teacher {
        name: String,
        age: u32,
    }

    let t = Teacher {
        name: "teacher".to_string(),
        age: 30,
    };

    // person_age(t); // tæ²¡æœ‰å®ç°S traitï¼Œæ‰€ä»¥ä¸èƒ½ä½œä¸ºå‚æ•°
    person_age(s); // å¯ä»¥è°ƒç”¨
```

æ ‡å‡†åº“ä¸­é¢„å¯¼å…¥äº†å¾ˆå¤štraitï¼Œå¯ä»¥ç›´æ¥åœ¨æ–‡ä»¶ä¸­ä½¿ç”¨è€Œä¸ç”¨` use`å¯¼å…¥ï¼Œä½ å¯ä»¥å¤§æ¦‚çœ‹ä¸€ä¸‹ä¸‹åˆ—è¡¨æ ¼ï¼Œæ¶ˆé™¤å¯¹ traitçš„é™Œç”Ÿæ„Ÿ

![image-20230302004216125](https://github.com/CreatorsDAO/rust-co-learn/blob/main/images/prelude_traits.png)

å¦‚ä¸‹æ˜¯ä¸åŒåœºæ™¯ä¸‹ç»å¸¸ä½¿ç”¨çš„trait

![img](https://github.com/CreatorsDAO/rust-co-learn/blob/main/images/traits_fetures.png)

### 2.3.2 traitä¸ç±»å‹è½¬æ¢

traitçº¦å®šäº†ç±»å‹çš„å…±åŒè¡Œä¸ºï¼Œè¿™äº›ç±»å‹æ—¢åŒ…æ‹¬è‡ªå®šä¹‰ç±»å‹ï¼Œä¹ŸåŒ…æ‹¬Rustæ ‡å‡†åº“ä¸­çš„ç±»å‹ã€‚æˆ‘ä»¬ç»“ä¸‹æ¥ä¼šä»‹ç»ä¸€äº›å¸¸ç”¨çš„trait

```
 // 1 ç±»å‹è½¬æ¢traitï¼šFromå’ŒInto
    // å®ç°äº†ä¸Šè¿°traitçš„ç±»å‹å¯ä»¥ç›¸äº’è½¬æ¢,å®é™…ä¸Šï¼Œåªéœ€è¦å®ç°From traitå³å¯ï¼Œè¿™æ„å‘³ç€åªè¦å®ç°äº†From traitï¼Œå°±å¯ä»¥ä½¿ç”¨Into trait

    // 1.1 From

    use std::convert::From;

    #[derive(Debug)]
    struct Number {
        value: i32,
    }

    // ä¸ºè‡ªå®šä¹‰ç±»å‹å®ç°From traitï¼Œæ³¨æ„è¿™é‡ŒTraitå¸¦äº†ä¸€ä¸ªç±»å‹å‚æ•°i32ï¼Œç‰¹æŒ‡å°†i32è½¬æ¢ä¸ºNumber

    impl From<i32> for Number {
        fn from(item: i32) -> Self {
            Number { value: item }
        }
    }

    // ä½¿ç”¨From traitä¸­çš„fromæ–¹æ³•å°†i32è½¬æ¢ä¸ºNumber
    let num = Number::from(30);
    println!("My number is {:?}", num);

    // 1.2 Into

    let int = 5;
    // ä½¿ç”¨Into traitä¸­çš„fromæ–¹æ³•å°†i32è½¬æ¢ä¸ºNumber
    let num: i32 = int.into();
    println!("My number is {:?}", num);

    // ä¸ºè‡ªå®šä¹‰ç±»å‹å®ç°Into traitï¼Œæ³¨æ„è¿™é‡ŒTraitå¸¦äº†ä¸€ä¸ªç±»å‹å‚æ•°Numberï¼Œç‰¹æŒ‡å°†Numberè½¬æ¢ä¸ºi32
    impl From<Number> for i32 {
        fn from(item: Number) -> Self {
            item.value
        }
    }

    let num = Number { value: 30 };

    // ä½¿ç”¨Into traitä¸­çš„intoæ–¹æ³•å°†Numberè½¬æ¢ä¸ºi32
    let int1: i32 = num.into();
    let num = Number { value: 30 };
    let int2: i32 = i32::from(num);

    // ä¸æ­¤ç›¸ä¼¼çš„traitè¿˜æœ‰ TryFrom å’Œ TryInto
    // åœ¨å®é™…ä¸­ï¼ŒTryFrom å’Œ TryInto ç”¨çš„æ¯”è¾ƒå¤šï¼Œå› ä¸ºå®ƒä»¬å¯ä»¥å¤„ç†é”™è¯¯ï¼Œä½†æ˜¯å®ç°é€»è¾‘å’Œ From å’Œ Into æ˜¯ä¸€æ ·

    // 2 AsRef å’Œ AsMut

    // é€šè¿‡AsMutè·å–å¯å˜å¼•ç”¨:æ³¨æ„è¿™é‡Œè·å–ç»“æ„ä½“æˆå‘˜çš„å¯å˜å¼•ç”¨
    impl AsMut<i32> for Number {
        fn as_mut(&mut self) -> &mut i32 {
            &mut self.value
        }
    }

    let mut num = Number { value: 30 };

    let ref_num = num.as_mut();

    // é€šè¿‡AsRefè·å–å˜é‡çš„ä¸å¯å˜å¼•ç”¨:æ³¨æ„è¿™é‡Œè·å–ç»“æ„ä½“æˆå‘˜çš„ä¸å¯å˜å¼•ç”¨
    impl AsRef<i32> for Number {
        fn as_ref(&self) -> &i32 {
            &self.value
        }
    }

    // ç‰¹åˆ«è¯´æ˜ï¼šä»¥ä¸Šä»£ç å±•ç¤ºå¹¶ä¸ä¸€å®šæ˜¯æœ€ä½³å®è·µï¼Œåªæ˜¯ä¸ºäº†ä»‹ç»çŸ¥è¯†ç‚¹è€Œå±•ç¤ºçš„å¯èƒ½æ€§
```

### 2.3.3 traitä¸æ‰€æœ‰æƒ

æˆ‘ä»¬å·²ç»æ·±å…¥çš„ä»‹ç»äº†æ‰€æœ‰æƒè§„åˆ™ï¼šå®ƒæ˜¯Rustå®ç°å†…å­˜ç®¡ç†çš„æ€æ‰‹é”ä¹‹ä¸€ã€‚traitä½œä¸ºRustä¸­é“¾æ¥ç±»å‹å¤§å¦çš„é‡è¦ç¯èŠ‚ï¼Œå’Œç±»å‹çš„æ‰€æœ‰æƒä¹Ÿæœ‰å¾ˆå¤šé‡è¦çš„è”ç³»

```
// 1 Copy trait å’Œ Clone trait

    // ä¹‹å‰æˆ‘ä»¬ä»‹ç»äº†æ‰€æœ‰çš„å›ºå®šå°ºå¯¸ç±»å‹ï¼Œå½“æŠŠä¸€ä¸ªå˜é‡èµ‹å€¼ç»™å¦ä¸€ä¸ªå˜é‡æ—¶ï¼Œä¼šå‘ç”Ÿå€¼çš„å¤åˆ¶

    // owner_one å’Œ owner_two ç°åœ¨å„è‡ªæ‹¥æœ‰ä¸€ä»½å€¼ï¼Œæ•°æ®å‘ç”Ÿäº†æ‹·è´
    let owner_one = 32;
    let owner_two = owner_one;

    // ä½†æ˜¯å¯¹äºä¸€äº›åŠ¨æ€å°ºå¯¸å¤§å°çš„ç±»å‹ï¼Œæ¯”å¦‚strå’Œ[T],æˆ‘ä»¬åœ¨ä½¿ç”¨å®ƒä»¬çš„æŒ‡é’ˆ Stringå’ŒVec<T>æ—¶ï¼Œä¸ä¼šå‘ç”Ÿå€¼çš„å¤åˆ¶ï¼Œè€Œæ˜¯ä¼šç§»äº¤æ‰€æœ‰æƒ

    let owner_one = String::from("hello");
    let owner_two = owner_one;

    // println!("{:?}", owner_one); // ä¸å¯é€šè¿‡owner_oneè®¿é—®æ•°æ®ï¼Œå› ä¸ºå®ƒå·²ç»ç§»äº¤äº†æ‰€æœ‰æƒ

    // ä»traitçš„è§’åº¦æ¥è®²ï¼Œå°±æ˜¯æ‰€æœ‰å›ºå®šå°ºå¯¸ç±»å‹éƒ½å®ç°äº† Copy å’Œ Clone traitï¼Œè€ŒåŠ¨æ€å°ºå¯¸ç±»å‹éƒ½æ²¡æœ‰å®ç° Copy traitï¼Œä½†å¤§å¤šéƒ½å®ç°äº†Clone trait
    // å¹¶ä¸”ç¼–è¯‘å™¨æŠ¥é”™ä¹Ÿä¼šå‘Šè¯‰ä½ ï¼Œå“ªäº›ç±»å‹æ²¡æœ‰å®ç° Copy trait

    // å¦‚æœä½ æƒ³åœ¨å †ä¸Šå¤åˆ¶æƒ³åƒä½¿ç”¨å›ºå®šå°ºå¯¸ç±»å‹é‚£æ ·ä¸€æ ·åœ¨å †ä¸Šå¤åˆ¶ä¸€ä»½æ•°æ®ï¼Œä½ å¯ä»¥æ˜¾å¼è°ƒç”¨Clone traitä¸­çš„ cloneæ–¹æ³•æ¥å®ç°è¿™ä¸€ç‚¹

    let v = vec![1, 2, 3, 4, 5];

    let v1 = v.clone();
    let v2 = v.clone();
    let v3 = v1.clone();

    // æ–°å˜é‡çš„åœ°å€å’ŒåŸå˜é‡çš„åœ°å€å„ä¸ç›¸åŒ

    println!("{:p}", v.as_ptr()); // 0x7fccb3705b30
    println!("{:p}", v1.as_ptr()); // 0x7fccb3705b50
    println!("{:p}", v2.as_ptr()); // 0x7fccb3705b70
    println!("{:p}", v3.as_ptr()); // 0x7fccb3705b90

    // 2 traitå®ç°ä¸æ‰€æœ‰æƒ
    // åœ¨è‡ªå®šä¹‰ traitä¸­çš„æ–¹æ³•æ—¶ï¼Œä½ å¯ä»¥æ ¹æ®éœ€è¦é€‰æ‹©è¦è·å–ç±»å‹çš„ä¸å¯å˜å¼•ç”¨ã€å¯å˜å¼•ç”¨æˆ–è€…æ‰€æœ‰æƒ

    trait A {
        // éœ€è¦æ‰‹åŠ¨å®ç°ï¼Œè·å–æ‰€æœ‰æƒ
        fn take_ownership(self);

        // é»˜è®¤å®ç°ï¼Œè·å–ä¸å¯å˜å¼•ç”¨
        fn take_ref(&self) {
            println!("è¿™ä¸ªæ–¹æ³•è·å–äº†ç±»å‹çš„ä¸å¯å˜å¼•ç”¨")
        }

        // é»˜è®¤å®ç°ï¼Œè·å–å¯å˜å¼•ç”¨
        fn take_mut(&mut self) {
            println!("è¿™ä¸ªæ–¹æ³•è·å–äº†ç±»å‹çš„å¯å˜å¼•ç”¨")
        }
    }

    struct X;

    impl A for X {
        fn take_ownership(self) {
            println!("è¿™ä¸ªæ–¹æ³•è·å–äº†ç±»å‹çš„æ‰€æœ‰æƒ")
        }

        // é»˜è®¤å®ç°ä¸ç”¨æ‰‹åŠ¨å®ç°
    }

    let x = X;

    x.take_ownership(); // è¿™ä¸ªæ–¹æ³•è·å–äº†ç±»å‹çš„æ‰€æœ‰æƒ
                        // x.take_ref();// ä¸èƒ½å†ä½¿ç”¨x,å› ä¸ºä¸Šè¿°æ–¹æ³•å·²ç»è·å–äº†æ‰€æœ‰æƒ

    let mut y = X;
    y.take_ref(); // è¿™ä¸ªæ–¹æ³•è·å–äº†ç±»å‹çš„ä¸å¯å˜å¼•ç”¨
    y.take_mut(); // è¿™ä¸ªæ–¹æ³•è·å–äº†ç±»å‹çš„å¯å˜å¼•ç”¨

    // ç‰¹åˆ«è¯´æ˜ï¼šæ‰€æœ‰æƒæœºåˆ¶å’Œtraitæœ¬è´¨ä¸Šæ˜¯Rustä¸­ä¸¤ä¸ªç‹¬ç«‹çš„æ¦‚å¿µï¼Œå³ä½¿æ²¡æœ‰traitï¼Œæ‰€æœ‰æƒæœºåˆ¶ä¹Ÿæ˜¯æˆç«‹çš„ï¼ˆè¿™ä¹Ÿæ˜¯æˆ‘ä»¬åœ¨ä»‹ç»æ‰€æœ‰æƒæœºåˆ¶æ—¶ä¸ºä»€ä¹ˆæ²¡æœ‰æåŠtraitï¼Œå› ä¸ºä¸éœ€è¦ï¼‰
    // ä½†traitç³»ç»Ÿè®©æ‰€æœ‰æƒæœºåˆ¶æ›´åŠ çš„æ˜¾å¼åŒ–äº†ï¼Œæ›´å¥½ç†è§£ï¼Œä¹Ÿæ›´å¥½ä½¿ç”¨
```

### 2.3.4 trait å¯¹è±¡

ä¹‹å‰æˆ‘ä»¬ä»‹ç»è¿‡ï¼Œå‡½æ•°å‚æ•°å¯ä»¥ä½¿ç”¨traitä½œä¸ºçº¦æŸ

```
 // 1 trait object

    // trait object ç”¨åœ¨å½“ä½ æƒ³è¿”å›ä¸€ä¸ªå®ç°äº†æŸä¸ªtraitçš„ç±»å‹
    // è¯­æ³•ï¼š&dyn Trait or Box<dyn Trait> // Boxæ˜¯Rustä¸­å”¯ä¸€å¯ä»¥æŠŠæ•°æ®å¼ºåˆ¶åˆ†é…åˆ°å †ä¸Šçš„ç±»å‹ï¼Œå…ˆä¸å±•å¼€ï¼Œåé¢ä¼šä»‹ç»

    trait Animal {
        fn speak(&self) -> &'static str;
    }

    struct Dog;
    impl Animal for Dog {
        fn speak(&self) -> &'static str {
            "Woof!"
        }
    }

    struct Cat;
    impl Animal for Cat {
        fn speak(&self) -> &'static str {
            "Meow!"
        }
    }

    fn animal_speak(animal: &dyn Animal) {
        println!("{}", animal.speak());
    }

    fn main() {
        let dog = Dog;
        let cat = Cat;

        animal_speak(&dog);
        animal_speak(&cat);
    }

    // ç‰¹åˆ«è¯´åï¼Œä½¿ç”¨ trait å¯¹è±¡ ä¼šå¸¦æ¥è¿è¡Œæ—¶å¼€é”€
    // å› ä¸ºåœ¨ç¼–è¯‘æ—¶æ— æ³•ç¡®å®šå…·ä½“ç±»å‹ï¼Œæ‰€ä»¥ç¼–è¯‘å™¨éœ€è¦åœ¨è¿è¡Œæ—¶åŠ¨æ€åœ°æŸ¥æ‰¾å¹¶è°ƒç”¨æ­£ç¡®çš„æ–¹æ³•
    // è¿™æ¶‰åŠåˆ°è™šå‡½æ•°è¡¨ï¼ˆvtableï¼‰çš„æ¦‚å¿µï¼Œæ¯ä¸ª trait å¯¹è±¡éƒ½æœ‰ä¸€ä¸ªæŒ‡å‘ç›¸åº” vtable çš„æŒ‡é’ˆ
```

## 2.4 é¡¹ç›®ç»ƒä¹ 

# æ¨¡å—ä¸‰ï¼šRustè¿›é˜¶çŸ¥è¯†

## 3.1 traitè¿›é˜¶

trait åœ¨Rustä¸­æ¶µç›–çš„å†…å®¹éå¸¸å¤šï¼Œå®ƒä¸å…‰ä¸ºä¸€äº›å¸¸è§çš„ç±»å‹å®šä¹‰äº†å¤§é‡çš„æ–¹æ³•ï¼ŒåŒæ—¶è¿˜ä¸ºä¸€äº›æ¯”è¾ƒç‰¹æ®Šçš„ç±»å‹æä¾›äº†æ”¯æŒ

### 3.1.1 traitä¸é—­åŒ…

```
 // 1. å›é¡¾ä¸‰ç§ç±»å‹çš„é—­åŒ…
    // å‰é¢æˆ‘ä»¬ä»‹ç»è¿‡ï¼Œé—­åŒ…æœ‰ä¸‰ç§ç±»å‹ï¼šæœªæ•è·ç¯å¢ƒå˜é‡ï¼Œæ•è·ç¯å¢ƒå˜é‡ä¸ä¿®æ”¹ï¼Œæ•è·ç¯å¢ƒå˜é‡å¹¶ä¿®æ”¹

    // 1.1 æœªæ•è·ç¯å¢ƒå˜é‡çš„é—­åŒ…
    let c1 = || println!("didn't catch env var");
    c1();

    // 1.2 æ•è·ç¯å¢ƒå˜é‡ä¸ä¿®æ”¹çš„é—­åŒ…
    let x = 10;

    let c2 = || println!("catch env var but not modify, x = {}", x);

    c2();

    // 1.3 æ•è·ç¯å¢ƒå˜é‡å¹¶ä¿®æ”¹çš„é—­åŒ…

    let mut x = 10;
    let mut c3 = |a: i32| {
        x = 1 + a;
        println!("catch env var and modify, x = {}", x);
    };
    c3(10);

    // 2. é—­åŒ…å®ç°ä¸trait

    // åœ¨Rustä¸­ï¼Œé—­åŒ…å®é™…ä¸Šæ˜¯ä¸€ä¸ªè¯­æ³•ç³–ï¼Œå®ƒçš„å®ç°åŸç†æ˜¯ä¸€ä¸ªåŒ¿åç»“æ„ä½“ï¼Œè¿™ä¸ªç»“æ„ä½“ä¼šæŠŠç¯å¢ƒå˜é‡æ•è·æˆä¸ºå…¶æˆå‘˜ï¼Œå¹¶å®ç°Fn/FnMut/FnOnce trait
    // Fn/FnMut/FnOnceä¸­å„æœ‰ä¸€ä¸ªæ–¹æ³•åˆ†åˆ«æ˜¯call/call_mut/call_onceï¼Œå¯¹åº”çš„è¯­ä¹‰åˆ†åˆ«æ˜¯è°ƒç”¨ä¸å¯å˜é—­åŒ…ã€è°ƒç”¨å¯å˜é—­åŒ…ã€è°ƒç”¨æ¶ˆè´¹é—­åŒ…
    // å¹¶ä¸”Fn/FnMut/FnOnce traitæ˜¯ä»¥æ¬¡ç»§æ‰¿çš„ï¼Œä¹Ÿå°±æ˜¯è¯´å®ç° Fn trait,å¿…é¡»å®ç° FnMut traitï¼Œå®ç° FnMut trait,å¿…é¡»å®ç° FnOnce trait

    // å½“å£°æ˜ä¸€ä¸ªé—­åŒ…æ—¶ï¼Œç¼–è¯‘å™¨ä¼šæ ¹æ®é—­åŒ…çš„ç±»å‹ï¼Œè‡ªåŠ¨æ¨å¯¼å‡ºå…¶å®ç°çš„traitï¼Œä¸€èˆ¬æƒ…å†µä¸‹ä¸éœ€è¦æ‰‹åŠ¨å®ç°

    // 3. é—­åŒ…ä½œä¸ºå‡½æ•°å‚æ•°ä¼ é€’
    // å€¼å¾—æ³¨æ„çš„æ˜¯ï¼Œåœ¨å°†é—­åŒ…ä½œä¸ºå‚æ•°åœ¨å‡½æ•°ä¸­ä¼ é€’æ—¶ç±»å‹çš„åˆ¶å®šæ˜¯é€šè¿‡traitæ¥å®ç°çš„

    fn call_fn<F: Fn()>(f: F) {
        f();
    }

    fn call_fn_mut<F: FnMut()>(mut f: F) {
        f();
    }

    fn call_fn_once<F: FnOnce()>(f: F) {
        f();
    }

    // é—­åŒ…çš„è°ƒç”¨ case1
    // Rustç¼–è¯‘å™¨ä¼šæ ¹æ®ä½ å¦‚ä½•è°ƒç”¨æ¨å¯¼å‡ºé—­åŒ…çš„ç±»å‹ï¼Œä¹Ÿå°±æ˜¯å®ç°å“ªä¸ªtrait

    let c = || println!("closure");

    call_fn_once(c); // å®ç°äº†FnOnce trait
    call_fn(c); // å®ç°äº†Fn traitï¼ŒFnMut trait,FnOnce trait,åé¢ä¸¤ç§traitéƒ½æ˜¯é€šè¿‡ç»§æ‰¿å®ç°çš„
    call_fn_mut(c); // å®ç°äº†FnMut trait,FnOnce trait

    // é—­åŒ…çš„è°ƒç”¨ case2

    let x = "10";

    let c = || println!("get env var {}", x);

    call_fn_once(c); // å®ç°äº†FnOnce trait
    call_fn(c); // å®ç°äº†Fn traitï¼ŒFnMut trait,FnOnce trait,åé¢ä¸¤ç§traitéƒ½æ˜¯é€šè¿‡ç»§æ‰¿å®ç°çš„
    call_fn_mut(c); // å®ç°äº†FnMut trait,FnOnce trait

    // é—­åŒ…çš„è°ƒç”¨ case3

    let mut x = String::from("10");

    let mut c = || println!("get env var {}", x = String::from("hello"));

    call_fn_once(c); // å®ç°äº†FnOnce trait
    call_fn(c); // å®ç°äº†Fn traitï¼ŒFnMut trait,FnOnce trait,åé¢ä¸¤ç§traitéƒ½æ˜¯é€šè¿‡ç»§æ‰¿å®ç°çš„
    call_fn_mut(c); // å®ç°äº†FnMut trait,FnOnce trait

    // 4. é—­åŒ…ä½œä¸ºå‡½æ•°è¿”å›

    fn return_fn() -> impl Fn() {
        || println!("call_fn")
    }

    fn return_fn_mut() -> impl FnMut() {
        let x = 10;
        // || println!("call_fn_mut {}", x + 1) // ä¸èƒ½è¿”å›å±€éƒ¨å˜é‡
        move || println!("call_fn_mut {}", x + 1) // å¿…é¡»æŠŠå±€éƒ¨å˜é‡ç§»å…¥é—­åŒ…ï¼Œæ‰èƒ½è¿”å›ï¼ˆè¿™é‡Œå®é™…ä¸Šå‘ç”Ÿäº†æ•°æ®çš„å¤åˆ¶ï¼‰
    }

    fn return_fn_once() -> impl FnOnce() {
        let s = String::from("hello");
        // || println!("call_fn_once {:?}", s)
        move || println!("call_fn_once {:?}", s) // å¿…é¡»æŠŠå±€éƒ¨å˜é‡ç§»å…¥é—­åŒ…ï¼Œæ‰èƒ½è¿”å›ï¼ˆè¿™é‡Œå®é™…ä¸Šå‘ç”Ÿäº†æ‰€æœ‰æƒè½¬ç§»ï¼‰
    }
```

### 3.1.2 traitä¸è¿­ä»£å™¨

Rustæä¾›äº†è¿­ä»£å™¨trait,ä»è€Œå®ç°éå†ï¼Œforå¾ªç¯æœ¬è´¨ä¸Šæ˜¯ä¸€ä¸ªè¯­æ³•ç³–

```
 // 1. for å¾ªç¯ä¸è¿­ä»£å™¨

    // åœ¨rustä¸­ï¼Œforå¾ªç¯å®é™…ä¸Šçš„è¿­ä»£å™¨çš„è¯­æ³•ç³–

    // for å¾ªç¯ä»¥åŠè§£ç³–
    let values = vec![1, 2, 3, 4, 5];
    // ä½¿ç”¨ for å¾ªç¯éå†é›†åˆä¸­ä¸ªæ¯ä¸ªå…ƒç´ 
    for x in values {
        println!("{x}");
    }
    // for å¾ªç¯è§£ç³–åç­‰ä»·å¦‚ä¸‹ï¼š
    let v = vec![1, 2, 3, 4, 5];
    // å…ˆå°†é›†åˆè½¬ä¸ºè¿­ä»£å™¨
    let mut v_iter = v.into_iter();
    // åœ¨ loop å¾ªç¯ä¸­ä½¿ç”¨nextæ–¹æ³•å¾ªç¯è·å–é›†åˆä¸­ä¸‹ä¸€ä¸ªå…ƒç´ ï¼Œå½“é›†åˆä¸­å–ä¸åˆ°å€¼æ—¶ä½¿ç”¨breakç»ˆæ­¢ loopå¾ªç¯
    loop {
        match v_iter.next() {
            Some(x) => println!("{}", x),
            None => break,
        }
    }

    // 2. è¿­ä»£å™¨ trait IntoIterator å’Œ Iterator
    // IntoIterator trait ä¸­çš„ into_iteræ–¹æ³•ä¼šè¿”å›ä¸€ä¸ª å®ç°äº† Iterator trait è¿­ä»£å™¨
    // Iterator trait é€šè¿‡å…¶ nextæ–¹æ³•æ¥è·å–é›†åˆä¸­çš„ä¸‹ä¸€ä¸ªå…ƒç´ 

    use std::collections::HashMap;
    use std::slice::Iter;
    use std::slice::IterMut;
    use std::vec::IntoIter;

    let map = HashMap::from([("rust", 1), ("go", 2), ("python", 3)]);
    let map_iter = map.into_iter();
    let vec: Vec<(&str, i32)> = map_iter.collect();
    println!("{:?}", vec); // [("rust", 1), ("go", 2), ("python", 3)]

    // 3. è¿­ä»£å™¨ã€å€Ÿç”¨å’Œæ‰€æœ‰æƒ
    let mut v = vec![1, 2, 3, 4, 5, 6, 7, 8, 9];
    let iter_mut: IterMut<i32> = v.iter_mut(); // è½¬ä¸º  IterMut ç»“æ„ä½“, å¯å˜å€Ÿç”¨
    let iter: Iter<i32> = v.iter(); // è½¬ä¸º Iter ç»“æ„ä½“ï¼Œ ä¸å¯å˜å€Ÿç”¨
    let iter_into: IntoIter<i32> = v.into_iter(); // è½¬ä¸º IntoIter ç»“æ„ä½“ ï¼Œ è·å–æ‰€æœ‰æƒ

    // 4 è¿­ä»£å™¨é€‚é…å™¨
    let vec = vec![1, 2, 3, 4, 5];
    let doubled: Vec<i32> = vec
        .iter()
        .map(|&x| x * 3)
        .take(3)
        .filter(|x| *x > 6)
        .collect();
    println!("{:?}", doubled); // [9]

    // 5 è¿­ä»£å™¨ä¸è¿­ä»£å™¨é€‚é…å™¨ç‰¹æ€§ï¼šlazyï¼ˆæƒ°æ€§ï¼‰
    let v = vec![1, 2, 3, 4, 5];
    v.iter().for_each(|x| println!("{x}"));
    // or
    for x in &v {
        println!("{x}");
    }
```

### 3.1.3 traitä¸æ™ºèƒ½æŒ‡é’ˆ

```
 // åœ¨å±•å¼€Rustçš„æ™ºèƒ½æŒ‡é’ˆä¹‹å‰ï¼Œæˆ‘ä»¬å…ˆåŒºåˆ†ä¸€ä¸‹Rustä¸­çš„æŒ‡é’ˆã€å¼•ç”¨å’Œè£¸æŒ‡é’ˆ

    // 1 æŒ‡é’ˆã€å¼•ç”¨å’Œæ™ºèƒ½æŒ‡é’ˆ

    // 1.1 å¼•ç”¨

    let x = 100;
    let mut y: i64 = 200;
    #[derive(Debug)]
    struct A(i32);
    let a = A(100);

    // ä½¿ç”¨ & è·å–ä¸å˜æˆ–è€…å¯å˜å¼•ç”¨
    let x_pointer = &x;
    let y_pointer = &mut y;
    let a_pointer = &a;

    println!("{:?}", x_pointer); // 100 æ‰“å°æ—¶ä¼šè‡ªåŠ¨â€œè§£å¼•ç”¨â€åˆ°æ•°æ®ï¼Œè€Œä¸æ˜¯åœ°å€
    println!("{:p}", x_pointer); // 0x7ff7b9bae33c å¦‚æœè¦æ‰“å°åœ°å€çš„è¯ï¼Œæ”¹å˜å ä½ç¬¦ï¼Ÿä¸º p

    // let z = &mut y; // å¯å˜å€Ÿç”¨ä¸èƒ½è¶…è¿‡1æ¬¡

    y = *y_pointer + 100; // è§£å¼•ç”¨åä¿®æ”¹

    println!("{:?}", y); //300 æœ¬æ¡ä»£ç ç»“æŸåï¼Œå¯å˜å€Ÿç”¨æ‰é‡Šæ”¾
    println!("{:?}", a_pointer); // A(100)

    // 1.2 è£¸æŒ‡é’ˆ
    let x = 100;
    let mut y: i64 = 200;
    struct B(i32);
    let a = B(100);

    // è£¸æŒ‡é’ˆæ˜¯ä½¿ç”¨ as *const ä»å¼•ç”¨è½¬æ¢è€Œæ¥
    let x_raw_pointer = &x as *const i32;
    let y_raw_pointer = &mut y as *const i64;
    let a_raw_pointer = &a as *const B;

    println!("{:?}", x_raw_pointer); // 0x7ff7b763a46cï¼Œè£¸æŒ‡é’ˆæ‰“å°æ—¶ä¸ä¼šè¢«â€œè§£å¼•ç”¨â€åˆ°æ•°æ®ï¼Œè€Œæ˜¯ä¼šç›´æ¥ä¼šæ‰“å°åœ°å€

    unsafe {
        y = *y_raw_pointer + 300; // è£¸æŒ‡é’ˆè§£å¼•ç”¨éœ€è¦ä½¿ç”¨unsafe è¯­æ³•å—ï¼Œè¿™é‡Œçš„è§£å¼•ç”¨çš„å®‰å…¨çš„

        let z_raw_pointer = &mut y as *const i64; // ç¬¬äºŒæ¬¡ç”Ÿæˆå¯å˜è£¸æŒ‡é’ˆï¼Œunsafe å—ç»•è¿‡äº†å¯å˜å€Ÿç”¨çš„æ¬¡æ•°è§„åˆ™ï¼Œæ˜¯ä¸æ˜¯æ„Ÿè§‰æœ‰ç‚¹å±é™©ï¼Ÿ

        y = *z_raw_pointer + 500; // ç„¶åç»§ç»­æ”¹å˜æ•°æ®

        println!("{:?}", *y_raw_pointer); // 1000
    }
    println!("{:?}", a_raw_pointer); // 0x7ff7b763a47c
    println!("{:?}", y); // 1000

    // 1.3 æ™ºèƒ½æŒ‡é’ˆ

    // Vec å’Œ String ç±»å‹éƒ½æ˜¯æ™ºèƒ½æŒ‡é’ˆ

    let vec = vec![1, 2, 3, 4];
    let s = "rust".to_string();
    let num = Box::new(100);

    let v1 = vec; // å‘ç”Ÿäº†moveè¯­ä¹‰ï¼Œç°åœ¨æ•°æ®çš„æ‰€æœ‰è€…ä¸å†æ˜¯vec è€Œæ˜¯v1ï¼Œæ•°æ®æ²¡å˜ï¼Œæ‹¥æœ‰è€…å˜äº†

    // println!("{:?}", vec); // ä¸èƒ½å†ä½¿ç”¨ vecï¼Œå› ä¸ºå®ƒä¸å†æ‹¥æœ‰æ•°æ®äº†

    let v = [1, 2, 3, 4];
    let v = &v1; // åªæ˜¯å€Ÿç”¨ï¼Œv ä»ç„¶æ‹¥æœ‰æ•°æ®
    println!("{:?}", v); // æ‰€ä»¥å¯ä»¥ä½¿ç”¨ v

    // 2 æ™ºèƒ½æŒ‡é’ˆä¸ç»“æ„ä½“ã€trait
    // Rustä¸­çš„æ™ºèƒ½æŒ‡é’ˆéƒ½æ˜¯ä»¥ç»“æ„ä½“è¿›è¡Œå°è£…ï¼Œç„¶åä¸ºå®ƒå®ç°äº†æŸäº›trait
    // äº‹å®ä¸Šï¼ŒRustä¸­å¾ˆå¤šç‰¹æ®Šçš„ç±»å‹éƒ½æ˜¯åŸºäºç»“æ„ä½“æ¥å®ç°çš„ï¼Œå¹¶ä¸”åœ¨è¿™äº›ç»“æ„ä½“ä¸Šå®ç°äº†å„ç§traitï¼Œè¿™æ˜¯ä¸€ç§é€šç”¨çš„ç±»å‹æ„é€ æ€è·¯

    // æ ‡å‡†åº“ä¸­çš„ä¸€äº›æ™ºèƒ½æŒ‡é’ˆçš„å®šä¹‰
    /*
    pub struct Box<T, A = Global>(_, _)
    where
        A: Allocator,
        T: ?Sized;

    pub struct String {
        vec: Vec<u8>,
    }

    pub struct Vec<T, A: Allocator = Global> {
        buf: RawVec<T, A>,
        len: usize,
    }

    pub struct Rc<T: ?Sized> {
        ptr: NonNull<RcBox<T>>,
        phantom: PhantomData<RcBox<T>>,
    }
    */

    // é‚£ä»€ä¹ˆæ˜¯æ™ºèƒ½æŒ‡é’ˆï¼Ÿæ™ºèƒ½æŒ‡é’ˆæ˜¯å®ç°äº†Deref trait æˆ– Drop trait çš„ç»“æ„ä½“ç±»å‹
    // Derefå…è®¸è‡ªåŠ¨è§£å¼•ç”¨yongï¼ŒDropå…è®¸è‡ªåŠ¨é‡Šæ”¾èµ„æº

    // 2. è‡ªå®šä¹‰æ™ºèƒ½æŒ‡é’ˆ

    // 2.1 å®ç° Drop trait

    #[derive(Debug)]
    struct User {
        name: String,
        age: u32,
    }

    impl Drop for User {
        fn drop(&mut self) {
            println!("{:?}", "rust") // å®ç°ç»†èŠ‚åªæ˜¯åšäº†æ‰“å°
        }
    }

    // 2.2 å®ç° Deref trait
    use std::ops::Deref;

    #[derive(Debug)]
    struct MyBox<T>(T);

    impl<T> Deref for MyBox<T> {
        type Target = T;
        fn deref(&self) -> &T {
            &self.0
        }
    }

    // 2.3 Drop trait å¦‚ä½•èµ·ä½œç”¨çš„ï¼Ÿ
    // å½“ä¸€ä¸ªå€¼ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œå®ƒçš„dropæ–¹æ³•ä¼šè¢«è‡ªåŠ¨è¢«ç¼–è¯‘å™¨è°ƒç”¨ï¼Œæ— éœ€æ‰‹åŠ¨è°ƒç”¨ï¼Œå¼ºè¡Œæ‰‹åŠ¨è°ƒç”¨ç¼–è¯‘å™¨ä¼šæŠ¥é”™

    {
        let mut user = User {
            name: "rust".to_string(),
            age: 12,
        };

        // user.drop(); //æ‰‹åŠ¨è°ƒç”¨ä¹Ÿè¡Œ å› ä¸ºç¼–è¯‘å™¨ä¼šè‡ªåŠ¨è°ƒç”¨ï¼Œæ˜¾å¼è°ƒç”¨äºŒè€…ä¼šå†²çª

        // ä½ ä¼šåœ¨ç»ˆç«¯å‘ç°æ‰“å°äº† â€œRustâ€ï¼ŒæˆåŠŸéªŒè¯ï¼Œç¼–è¯‘å™¨ç¡®å®è°ƒç”¨äº† drop
    }

    // 2.4 Deref trait å¦‚ä½•èµ·ä½œç”¨çš„ï¼Ÿ

    {
        let m = MyBox("rust");
        let ref_my_box = *m; // å®ç°äº† Deref traitçš„æ™ºèƒ½æŒ‡é’ˆå¯ä»¥ä½¿ç”¨ * ç›´æ¥è§£å¼•ç”¨

        // Stringæ˜¯æ™ºèƒ½æŒ‡é’ˆï¼Œå®ƒå®ç°äº†Deref traitï¼Œæ‰€ä»¥å¯ä»¥ç›´æ¥è§£å¼•ç”¨

        fn take_ref_string(s: &str) {
            println!("{:?}", s)
        }

        // å°†Stringè§£å¼•ç”¨ä¸ºstr
        // æ³¨æ„ï¼šStringè¿™ä¸ªæ™ºèƒ½æŒ‡é’ˆåŒ…è£¹çš„ç±»å‹æ˜¯ strï¼Œè§£å¼•ç”¨åå¤§å°ç¼–è¯‘å™¨æ— æ³•ç¡®å®šï¼Œæ‰€ä»¥è¦å†åŠ &ï¼ˆå¼•ç”¨ï¼‰
        let s = String::from("Rust");
        take_ref_string(&s);
    }
```

Rustä¸­æœ‰å¤šä¸ªæ™ºèƒ½æŒ‡é’ˆï¼Œå¯ä»¥å‚è€ƒä¸‹è¡¨ï¼Œè¿™é‡Œæ€»ç»“äº†ä¸€ä¸ªè¡¨ï¼Œæ–¹ä¾¿ä½ é˜…è¯»

![image-20230203001747611](https://github.com/CreatorsDAO/rust-co-learn/blob/main/images/smart_pointers.png)

## 3.2 ç±»å‹è¿›é˜¶

Rustä¸­å¯¹äºæä¾›äº†å¾ˆå¤šç±»å‹ï¼Œç”¨äºå¤„ç†ä¸€äº›ç‰¹æ®Šçš„åœºæ™¯

### 3.2.1 Box <T>

Boxå¯ä»¥å°†å†…å­˜å¼ºåˆ¶åˆ†é…åˆ°å †ä¸Šï¼Œå¹¶ä¸”å®ƒä¹Ÿæ˜¯æ™ºèƒ½æŒ‡é’ˆï¼Œå¯ä»¥è‡ªåŠ¨è§£å¼•ç”¨å’Œç®¡ç†å †å†…å­˜ã€‚æ‰€ä»¥åœ¨ä½¿ç”¨çš„æ—¶å€™åªéœ€è¦ä½¿ç”¨å®ƒå°†æ•°æ®åˆ†é…åˆ°å †ä¸Šï¼Œå¹¶ä¸éœ€è¦å†è€ƒè™‘å¦‚ä½•é‡Šæ”¾å†…å­˜

```
 // 1 Box<T> ä¸æ•°æ®åˆ†é…

    // åœ¨Rustä¸­ï¼Œä½ å¯ä»¥ä½¿ç”¨Boxå°†æ•°æ®å¼ºè¡Œå­˜å‚¨åˆ°å †ä¸Š

    let a = Box::new("rust");
    let b = Box::new(42);

    // å®ƒä¹Ÿæ˜¯å”¯ä¸€å¯ä»¥å°†æ•°æ®æ”¾åˆ°å †ä¸Šçš„é€”å¾„

    // 2 Box<T> æ˜¯ä¸€ä¸ªæ™ºèƒ½æŒ‡é’ˆ
    // å®ƒå®ç°äº†Derefå’ŒDrop trait

    let s = Box::new("rust");
    let s = *s; // è§£å¼•ç”¨

    // ç¦»å¼€ä½œç”¨åŸŸæ—¶ï¼Œä¼šè‡ªåŠ¨è°ƒç”¨dropæ–¹æ³•ï¼Œé‡Šæ”¾å †ä¸Šçš„æ•°æ®

    // è¿™ä¸ªç±»å‹æ¯”è¾ƒç®€å•ï¼Œå†æ¬¡éœ€è¦å¼ºè°ƒçš„æ˜¯å®ƒæ˜¯ä¼—å¤šçš„RuståŸºäºç»“æ„ä½“æ„å’Œtraité€ çš„ç‰¹æ®Šç±»å‹ä¹‹ä¸€

```

### 3.2.2 å¯å˜å®¹å™¨

åœ¨ç¼–è¯‘æœŸï¼Œæˆ‘ä»¬éœ€è¦ä½¿ç”¨mutæ˜¾å¼å£°æ˜å˜é‡çš„å¯å˜æ€§ã€‚åœ¨è¿è¡Œæ—¶ï¼ŒRustæä¾›äº†å¯å˜å®¹å™¨Cellå’ŒRefCellå…è®¸ä¿®æ”¹ä¸å¯å˜å˜é‡ï¼ˆè¿™ä¸ªè¿‡ç¨‹å®é™…ä¸Šæ˜¯é€šè¿‡åŸç”ŸæŒ‡é’ˆæ¥å®Œæˆçš„

```
 // 1.ç¼–è¯‘æœŸï¼šé€šè¿‡ mut æ˜¾å¼å£°æ˜å˜é‡çš„å¯å˜æ€§ï¼Œä¹Ÿå«å¤–éƒ¨å¯å˜æ€§
    use std::cell::Cell;
    let can_not_change = "rust";
    let mut can_change = "go";
    // can_not_change = "cpp"; // ä¸å¯é‡æ–°èµ‹å€¼
    can_change = "c"; // å¯ä»¥æ›´æ”¹

    // 2. è¿è¡ŒæœŸï¼šé€šè¿‡Cellå’ŒRefCellå®ç°å¯å˜æ€§ï¼Œä¹Ÿå«å†…éƒ¨å¯å˜æ€§
    // 2.1 Cell<T> çš„ä¿®æ”¹å’Œè¯»å–
    struct Foo {
        x: u32,
        y: Cell<u32>,
        z: Cell<Vec<String>>,
    }

    let foo = Foo {
        x: 1,
        y: Cell::new(3),
        z: Cell::new(Vec::new()),
    };

    // ä¿®æ”¹å®¹å™¨å†…çš„å˜é‡ä½¿ç”¨setæ–¹æ³•
    foo.y.set(100);
    foo.z.set(vec!["rust".to_owned()]);

    // è¯»å–å®¹å™¨å†…çš„å˜é‡æœ‰ä¸¤ç§ï¼šå›ºå®šå¤§å°ç±»å‹å¯ä»¥ä½¿ç”¨ getå’Œinto_inner; åŠ¨æ€å¤§å°ç±»å‹åªèƒ½ä½¿ç”¨into_inner
    assert_eq!(100, foo.y.get());
    assert_eq!(100, foo.y.into_inner());

    // assert_eq!(vec!["rust".to_owned()], foo.z.get()); ä¸èƒ½ä½¿ç”¨getæ–¹æ³•
    assert_eq!(vec!["rust".to_owned()], foo.z.into_inner());

    // 2.2 RefCell<T> çš„ä¿®æ”¹å’Œè¯»å–
    // é€šè¿‡borrow_mutå®ç°å¯å˜æ€§
    // ä¸»è¦æ˜¯åº”ç”¨äºä¸€äº›åŠ¨æ€å¤§å°ç±»å‹ï¼Œé€šè¿‡borrowè·å–å€¼ï¼Œæœ‰è¿è¡Œæ—¶å¼€é”€

    use std::cell::RefCell;
    let vec = vec![1, 2, 3, 4];

    let ref_vec = RefCell::new(vec);

    println!("{:?}", ref_vec.borrow()); // ä¸å¯å˜å€Ÿç”¨ ä½¿ç”¨borrow
    ref_vec.borrow_mut().push(5); // å¯å˜å€Ÿç”¨æ”¹å˜ï¼Œä½¿ç”¨borrow_mut
    println!("{:?}", ref_vec.borrow());
```

### 3.2.3 å…±äº«å®¹å™¨

å…±äº«å®¹å™¨Rc<T>å’ŒArc<T>ä¹‹å‰åœ¨æ‰€æœ‰æƒå…±äº«ä¸­ä»‹ç»è¿‡ã€‚é€šè¿‡å…±äº«å®¹å™¨æˆ‘ä»¬å¯ä»¥ä½¿å¤šä¸ªå˜é‡æ‹¥æœ‰æ‰€æœ‰æƒï¼ˆæœ¬è´¨ä¸Šæ˜¯é€šè¿‡å¼•ç”¨è®¡æ•°å®ç°çš„ï¼‰ï¼Œä»è€Œå¯¹èµ„æºè¿›è¡Œæ“ä½œã€‚å…·ä½“ç¤ºä¾‹ç»†èŠ‚ä½ å¯ä»¥å‚è€ƒä¹‹å‰çš„ä»£ç 

### 3.2.4 ç‰¹æ®Šç±»å‹

**`PhantomData<T>`** ï¼Œå®ƒé€šå¸¸ç”¨äºåœ¨æ³›å‹ä»£ç ä¸­æ ‡è®°ä¸€äº›ç±»å‹å‚æ•°ï¼Œä½†ä¸å®é™…ä½¿ç”¨å®ƒä»¬ï¼Œä»è€Œå‘ Rust ç¼–è¯‘å™¨ä¼ è¾¾æœ‰å…³ä»£ç ä¸­ç±»å‹å…³ç³»çš„ä¿¡æ¯ã€‚å®ƒè¢«ç§°ä¸º â€œå¹½çµæ•°æ®â€ï¼Œå› ä¸ºå®ƒä¸å ç”¨ä»»ä½•å®é™…å†…å­˜ç©ºé—´ï¼Œåªåœ¨ç¼–è¯‘æ—¶èµ·ä½œç”¨

ä¸€èˆ¬å®ƒèµ·ä¸¤ä¸ªä½œç”¨ï¼š

1 ç”¨äºåœ¨ç±»å‹ç­¾åä¸­ä¼ é€’ç±»å‹ä¿¡æ¯ï¼Œä½†ä¸å®é™…ä½¿ç”¨

2 ä½œä¸ºä¸€ä¸ªç±»å‹å‚æ•°çš„æ ‡è®°ï¼Œç”¨äºå‘Šè¯‰ Rust ç¼–è¯‘å™¨æŸäº›é‡è¦ä¿¡æ¯ï¼Œä¾‹å¦‚ï¼Œå½“éœ€è¦å®ç° `Drop` trait æ—¶ï¼Œä½†æ˜¯ç±»å‹ä¸å®é™…åŒ…å«ä»»ä½•éœ€è¦é‡Šæ”¾çš„èµ„æºï¼Œå¯ä»¥ä½¿ç”¨ `PhantomData` æ¥å æ®ä¸€ä¸ªè™šæ‹Ÿçš„ä½ç½®ï¼Œè¿™æ ·ä»¥ç¡®ä¿ç¼–è¯‘å™¨ä¸ä¼šä¼˜åŒ–æ‰çš„ `Drop` å®ç°

```
use std::marker::PhantomData;

struct MyType<T> {
    _marker: PhantomData<T>,
}

impl<T> MyType<T> {
    fn new() -> MyType<T> {
        MyType { _marker: PhantomData }
    }
}

fn main() {
    let a: MyType<u32> = MyType::new();
    let b: MyType<String> = MyType::new();
}
```

**`Pin<T>`**: é€šå¸¸ç”¨äºè§£å†³ Rust å¼•ç”¨ç±»å‹çš„å®‰å…¨æ€§é—®é¢˜ï¼Œå°¤å…¶æ˜¯ä¸å¼‚æ­¥ç¼–ç¨‹å’Œå†…å­˜ç®¡ç†ç›¸å…³çš„é—®é¢˜ã€‚`Pin<T>` ç±»å‹å¯ä»¥ç¡®ä¿è¢«å¼•ç”¨çš„å€¼ä¸ä¼šè¢«ç§»åŠ¨æˆ–é‡Šæ”¾

ä¸€èˆ¬æƒ…å†µä¸‹ï¼šRustä¼šç¡®ä¿å¼•ç”¨æ€»æ˜¯æœ‰æ•ˆçš„ï¼Œä½†æ˜¯ä¹Ÿæœ‰ä¾‹å¤–æƒ…å†µï¼ˆæ²¡åŠæ³•ï¼Œåˆæ¶‰åŠåˆ°åé¢çš„å†…å®¹äº†ï¼Œè¿™é‡Œä½ å¯ä»¥å…ˆå¤§æ¦‚æœ‰ä¸ªäº†è§£å°±è¡Œï¼‰ï¼š

1. å½“å¼‚æ­¥ä»£ç åœ¨è¿è¡Œæ—¶å¯èƒ½ä¼šç§»åŠ¨æˆ–é‡Šæ”¾è¢«å¼•ç”¨çš„å€¼æ—¶ï¼Œæ¯”å¦‚ Future æˆ– async é—­åŒ…
2. å½“ä½¿ç”¨ `unsafe` ä»£ç æ—¶ï¼Œå¯èƒ½ä¼šé€šè¿‡è£¸æŒ‡é’ˆå°†å¼•ç”¨ç±»å‹è½¬æ¢ä¸ºå¯å˜å¼•ç”¨ç±»å‹ï¼Œä»è€Œç ´åç¼–è¯‘å™¨å¯¹å¼•ç”¨ç±»å‹çš„ä¿æŠ¤

```
// 2 ç‰¹æ®Šç±»å‹ï¼šPin<T>

    use std::pin::Pin;

    struct MType {
        data: String,
    }

    impl MType {
        fn new(data: String) -> MType {
            MType { data }
        }

        fn get_data(self: Pin<&Self>) -> &str {
            unsafe { &self.get_ref().data }
        }
    }

    let my_type = MType::new("hello".to_string());
    let pinned = Pin::new(&my_type);
    let data = pinned.get_data();
    println!("{}", data);
```

## 3.4 é¡¹ç›®ç»ƒä¹ 

# æ¨¡å—å››ï¼šRusté¡¹ç›®åŸºç¡€

## 4.1 é”™è¯¯å¤„ç†

Rustæ•´ä½“çš„é”™è¯¯å¤„ç†æœºåˆ¶æœ‰ä¸€ä¸ªå±‚çº§ï¼Œéšç€é”™è¯¯çš„`ä¸¥é‡ç¨‹åº¦`å¯ä»¥é€‰æ‹©ä¸åŒçš„å¤„ç†æ–¹æ¡ˆã€‚

1. ç±»å‹ç³»ç»Ÿä¿è¯å‡½æ•°å¥‘çº¦ï¼ˆRustä¸¥æ ¼çš„ç±»å‹ç³»ç»Ÿå·²ç»å¸®æˆ‘ä»¬æ¶ˆé™¤äº†è¿™éƒ¨åˆ†çš„é”™è¯¯ï¼Œå¦‚æœç±»å‹ä¸æ­£ç¡®ï¼Œæ˜¯ä¸ä¼šé€šè¿‡ç¼–è¯‘çš„ï¼‰
2. Option<T>æ¶ˆé™¤ç©ºæŒ‡é’ˆå¤±è´¥ (å¤„ç†æœ‰å€¼æˆ–è€…æ— å€¼çš„æƒ…å†µ)
3. Result<T,E> ä¼ æ’­é”™è¯¯ ï¼ˆå¤„ç†æˆåŠŸæˆ–è€…å¤±è´¥çš„æƒ…å†µï¼Œå¤±è´¥æ—¶å¯ä»¥æŠ›å‡ºé”™è¯¯ï¼‰
4. æ–­è¨€ç”¨äºé˜²å¾¡ 
5. Panicææ…Œ 

```
 // 1 ç±»å‹ç³»ç»Ÿä¿è¯å‡½æ•°å¥‘çº¦
    fn sum(a: i32, b: i32) -> i32 {
        a + b
    }

    // sum(1u32, 2u32) è¿åå‡½æ•°å¥‘çº¦

    // 2 ä½¿ç”¨Optionå¤„ç†æœ‰å€¼æˆ–æ— å€¼çš„æƒ…å†µ
    // å½“æŸä¸ªå€¼å¯èƒ½ä¸ºæ— å€¼æ—¶ï¼Œåº”è¯¥ä½¿ç”¨Option<T>æ¥åŒ…è£¹ï¼Œä»¥æ­£ç¡®å¤„ç†æ— å€¼çš„æƒ…å†µ
    fn log(val: f64) -> Option<f64> {
        match val.log2() {
            x if x.is_normal() => Some(x), // æœ‰å€¼æƒ…å†µ
            _ => None,                     // æ— å€¼æƒ…å†µ
        }
    }

    // å½“ä¸€ä¸ªå€¼ä¸ºOption<T>æ—¶ï¼Œç»å¸¸ä½¿ç”¨mapå’Œand_thenç­‰æ–¹æ³•æ¥é“¾å¼å¤„ç†

    fn double(val: f64) -> f64 {
        val * 2.
    }

    fn square(val: f64) -> f64 {
        val.powi(2 as i32)
    }

    fn inverse(val: f64) -> f64 {
        val * -1.
    }

    fn sqrt(val: f64) -> Option<f64> {
        match val.sqrt() {
            x if x.is_normal() => Some(x),
            _ => None,
        }
    }

    let number = 20.;
    let result = Option::from(number)
        .map(inverse)
        .map(double)
        .map(inverse)
        .and_then(log)
        .map(square)
        .and_then(sqrt);
    match result {
        Some(x) => println!("x was {:?}", x),
        None => println!("this failed"),
    }

    // 3 Result ç”¨äºå¤„ç†æˆåŠŸæˆ–å¤±è´¥çš„æƒ…å†µ

    use std::fs::File;
    use std::io::prelude::*;
    use std::io::Error;

    fn read_file_contents(file_path: &str) -> Result<String, Error> {
        let mut file = File::open(file_path)?;
        let mut contents = String::new();
        file.read_to_string(&mut contents)?;
        Ok(contents)
    }

    let file_path = "example.txt";
    match read_file_contents(file_path) {
        Ok(contents) => println!("File contents: {}", contents), // æˆåŠŸæƒ…å†µ
        Err(error) => println!("Error reading file: {}", error), // å¤±è´¥æƒ…å†µï¼ŒæŠ›å‡ºé”™è¯¯
    }

    // 4 æ–­è¨€
    // å½“ä½ ç¡®å®šæŸä¸ªå€¼ä¸€å®šä¼šå‡ºç°æŸç§æƒ…å†µæ—¶ï¼Œå¯ä»¥ä½¿ç”¨æ–­è¨€æ¥ç»ˆæ­¢ç¨‹åº

    fn extend_vec(v: &mut Vec<i32>, i: i32) {
        assert!(v.len() == 5); // æ–­è¨€
        v.push(i)
    }

    let mut vec = vec![1, 2, 3];
    extend_vec(&mut vec, 4);

    assert_eq!(4, vec[3]); // æ–­è¨€

    // 5 ææ…Œ
    // å½“ä½ ç¡®å®šæŸä¸ªå€¼ä¸€å®šä¸ä¼šå‡ºç°æŸç§æƒ…å†µæ—¶ï¼Œå¯ä»¥ä½¿ç”¨ææ…Œæ¥ç»ˆæ­¢ç¨‹åº
    //

    fn factorial(n: u32) -> u32 {
        if n == 0 {
            1
        } else {
            n * factorial(n - 1)
        }
    }

    let result = factorial(10);
    println!("Result: {}", result);
    if result > 1000000 {
        panic!("Result too large!"); // ä½¿ç”¨panic!ææ…Œ
    }

    // æ€»ç»“ï¼šä½¿ç”¨Optionå’ŒResultæ¥å¤„ç†å€¼æˆ–è€…é”™è¯¯ï¼Œä½¿ç”¨ææ…Œå’Œæ–­è¨€æ¥ç»ˆæ­¢ç¨‹åº
```

## 4.2 é¡¹ç›®ç®¡ç†

Rustå·¥ç¨‹ç®¡ç†éå¸¸å‹å¥½ï¼Œå¯ä»¥è½»æ¾ç®¡ç†å¤æ‚åºå¤§çš„å·¥ç¨‹é¡¹ç›®

### 4.2.1 crate

åœ¨Rustä¸­ï¼Œæœ‰ä¸¤ç§ç±»å‹çš„crateï¼Œä¹Ÿå«packageï¼ˆç±»ä¼¼äºå…¶ä»–è¯­è¨€çš„`åŒ…`ï¼‰: binary application package å’Œ library package .å‰è€…ä¸»è¦åº”ç”¨ç¨‹åºå…¥å£ï¼Œåè€…æ›´å¤šçš„æ˜¯ä¸ºå‰è€…æä¾›å„ç§å„æ ·çš„åŠŸèƒ½æ”¯æŒ

å¯ä»¥ä½¿ç”¨`Cargo`æ¥åˆ›å»º

```
 cargo new c1 --lib // åˆ›å»ºlib package
 cargo new c2 --bin // åˆ›å»ºbinary packageï¼Œé»˜è®¤åˆ›å»ºbinary package
```

ä¸¤ç§crateçš„åŒºåˆ«å¹¶ä¸å¤§ï¼Œä½†binary application package å¯ä»¥ç›´æ¥ä½¿ç”¨ cargo run è¿è¡Œï¼Œè€Œlibrary package éœ€è¦é…ç½®æ‰å¯ä»¥ã€‚ä½ å¯å‚è€ƒä¸‹é¢é“¾æ¥äº†è§£å¦‚ä½•é…ç½®

[å¦‚ä½•åœ¨lib crateä¸­è¿è¡Œç¨‹åº](https://zhuanlan.zhihu.com/p/614506900)

### 4.2.2 å·¥ä½œç©ºé—´

å·¥ä½œç©ºé—´ç”¨äºç»„ç»‡å¤šä¸ªcrateï¼Œæœ¬æ–‡æ¡£çš„ä»£ç ç»„ç»‡ç»“æ„å°±æ˜¯ä½¿ç”¨workspaceç»„ç»‡äº†å¤šä¸ªlib crate

```
[workspace]
members = ['module-one','module-two','module-three','module-four','module-five','module-six']
```

ä½ å¯å‚è€ƒä¸‹é¢é“¾æ¥äº†è§£å¦‚ä½•ä¸ºé¡¹ç›®é…ç½®å·¥ä½œç©ºé—´

[å¦‚ä½•é…ç½®workspace](https://zhuanlan.zhihu.com/p/614506900)

## 4.3 æµ‹è¯•

æµ‹è¯•å¯¹äºä»»ä½•è¯­è¨€æ¥è¯´éƒ½éå¸¸é‡è¦ï¼Œåœ¨Rustä¸­ï¼Œä½ å¯ä»¥éå¸¸è½»æ¾çš„æ„å»ºæµ‹è¯•ã€‚æµ‹è¯•éœ€è¦æ”¾åœ¨æµ‹è¯•æ¨¡å—ä¸­ï¼Œä½ å¯ä»¥åœ¨ä»£ç ç¼–å†™å®Œæˆåç›´æ¥åœ¨å½“å‰æ–‡ä»¶ä¸­ç¼–å†™æµ‹è¯•ï¼Œä¹Ÿå¯ä»¥æ–°å»ºä¸€ä¸ªæµ‹è¯•æ–‡æ¡£ä¸“é—¨ç¼–å†™

### 4.3.1 å•å…ƒæµ‹è¯•

å•å…ƒæµ‹è¯•ä¸»è¦å¯¹å±€éƒ¨æ¨¡å—å†…çš„ä»£ç è¿›è¡Œæµ‹è¯•ã€‚æµ‹è¯•ä»£ç æ”¾åœ¨æµ‹è¯•æ¨¡å—ä¸­

```
use std::fs::File;
use std::io::Error;

fn read_file(path: &str) -> Result<File, Error> {
    // 2.1 è¯»å–æ–‡ä»¶
    let file = File::open(path);

    // 2.2 åˆ¤æ–­æ–‡ä»¶æ˜¯å¦å­˜åœ¨
    match file {
        Ok(file) => Ok(file),
        Err(error) => Err(error),
    }
}

#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn can_hold(&self, other: &Rectangle) -> bool {
        self.width > other.width && self.height > other.height
    }
}

pub fn add_two(a: i32) -> i32 {
    a + 2
}

pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {}.", value);
        }

        Guess { value }
    }
}

// æµ‹è¯•æ¨¡å—

#[cfg(test)]
mod tests {
    use super::*;

    // 1 ä½¿ç”¨ assert! å®æ–­è¨€ç»“æœæ˜¯æŠ–ä¸º true

    #[test]
    fn larger_can_hold_smaller() {
        let larger = Rectangle {
            width: 8,
            height: 7,
        };
        let smaller = Rectangle {
            width: 5,
            height: 1,
        };

        assert!(larger.can_hold(&smaller)); // å¯ä»¥ç›´æ¥æ–­è¨€ï¼Œä¹Ÿå¯ä»¥å¸¦ä¸Šæç¤ºä¿¡æ¯
        assert!(
            larger.can_hold(&smaller),
            "larger is {:?}, smaller is {:?}",
            larger,
            smaller
        );
    }

    // 2 ä½¿ç”¨ assert_eq! å®æ–­è¨€ä¸¤ä¸ªå€¼ç›¸ç­‰

    #[test]
    fn it_adds_two() {
        assert_eq!(4, add_two(2));
    }

    // 3 ä½¿ç”¨ assert_ne! å®æ–­è¨€ä¸¤ä¸ªå€¼ä¸ç›¸ç­‰
    #[test]
    fn it_adds_two() {
        assert_ne!(3, add_two(2));
    }

    // 4 ä½¿ç”¨ should_panic å®æ–­è¨€å‡½æ•°ä¼š panic

    #[test]
    #[should_panic]
    fn greater_than_100() {
        Guess::new(200);
    }

    // 5 ä½¿ç”¨Result<T, E>ç±»å‹çš„æ–­è¨€

    #[test]
    fn read_file_should_works() -> Result<(), String> {
        match read_file("rust.txt") {
            Ok(_) => Ok(()),
            Err(_) => Err(String::from("file did not exit")),
        }
    }
}
```

### 4.3.2 æ–‡æ¡£æµ‹è¯•

æ–‡æ¡£æµ‹è¯•ä¹Ÿæ˜¯å•å…ƒæµ‹è¯•ï¼Œåªä¸è¿‡ä¸æŠŠæµ‹è¯•ä»£ç å†™åœ¨æµ‹è¯•æ¨¡å—ä¸­è€Œæ˜¯å†™åœ¨æ–‡æ¡£å¤‡æ³¨ä¸­

```
/// ```
/// fn add(a: i32, b: i32) -> i32 {
/// a + b
/// }
/// let result = add(2, 3);
/// assert_eq!(result, 5);

/// ```
fn add() {}
```

æœ¬æ–‡æ¡£çš„æ‰€æœ‰ä»£ç éƒ½ä»¥æ–‡æ¡£æµ‹è¯•å½¢å¼ç¼–å†™ï¼Œä½ å¯ä»¥ç›´æ¥è¿è¡Œ

### 4.3.3 é›†æˆæµ‹è¯•

é›†æˆæµ‹è¯•å¯¹äºæ•´ä¸ªlib crateæ¥è¯´æ˜¯å¤–éƒ¨çš„ï¼Œç›®çš„åœ¨äºæµ‹è¯•å„ä¸ªæ¨¡å—æ˜¯å¦èƒ½å¤Ÿä¸€èµ·æ­£ç¡®çš„å·¥ä½œï¼Œåˆ›å»ºé›†æˆæµ‹è¯•éœ€è¦åˆ›å»ºäºsrcåŒçº§çš„testsç›®å½•æ‰§è¡Œ

åœ¨lib.rsä¸‹åˆ›å»ºä¸€ä¸ªæ¨¡å—ï¼Œå¹¶å¯¼å‡ºå®šä¹‰çš„å‡½æ•°

```
pub use my_add::*;
mod my_add {

    pub fn add() -> i32 {
        2 + 2
    }
}
```

æ–°å»ºsrcåŒçº§ç›®å½•testsï¼Œå¹¶åˆ›å»ºæ–‡ä»¶add_test.rs,å¹¶åœ¨å…¶ä¸­å…ˆå¼•å…¥å‡½æ•°ï¼Œå†ç¼–å†™æµ‹è¯•

```
use module_four::add;

#[test]
fn it_adds_two() {
    assert_eq!(4, add());
}
```

ç„¶ååœ¨é¡¹ç›®ä¸‹è¿è¡Œ`cargo test`å°±å¯ä»¥æµ‹è¯•äº†

## 4.4 é¡¹ç›®ç»ƒä¹ 

# æ¨¡å—äº”ï¼šå¼‚æ­¥ç¼–ç¨‹å’Œæ— ç•å¹¶å‘

## 1 å¹¶å‘ç¼–ç¨‹

## 2 å¼‚æ­¥ç¼–ç¨‹

## 3 é¡¹ç›®å®æˆ˜

## 4 é¡¹ç›®ç»ƒä¹ 

# æ¨¡å—å…­ï¼šRustå†…å®¹æ‰©å±•ï¼ˆé€‰å­¦ï¼‰

## 1 å®ç¼–ç¨‹

## 2 Unsafe Rust

## 3 é˜…è¯»ææ–™



